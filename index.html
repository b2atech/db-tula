
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Schema Comparison Report</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css" rel="stylesheet" />
    <style>
        .mismatch {
            background-color: #fff3cd;
        }

        .missing {
            background-color: #f8d7da;
        }

        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            z-index: 2;
        }

        .code-block {
            position: relative;
        }
    </style>
</head>
<body class="container my-4">
    <h1>Schema Comparison Report</h1>

    <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
        <div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="mismatchOnly" onchange="applyFilters()">
                <label class="form-check-label" for="mismatchOnly">Show only mismatches</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="missingSourceOnly" onchange="applyFilters()">
                <label class="form-check-label" for="missingSourceOnly">Missing in source</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="missingTargetOnly" onchange="applyFilters()">
                <label class="form-check-label" for="missingTargetOnly">Missing in target</label>
            </div>
        </div>
        <button type="button" class="btn btn-success" data-bs-toggle="modal" data-bs-target="#syncScriptModal">
            Show All Sync Scripts
        </button>
    </div>

    <table class="table table-bordered table-striped">
        <thead class="table-light">
            <tr>
                <th>Type</th>
                <th>Name</th>
                <th>Source</th>
                <th>Destination</th>
                <th>Comparison</th>
                <th>Definition</th>
            </tr>
        </thead>
        <tbody>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>__EFMigrationsHistory</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>account_groups</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>addresses</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>account_types</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>bank_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>banks</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>account_categories</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>cities</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>account_opening_balances</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>chart_of_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>company_upis</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>company_bank_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>company_contacts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>company_finance_year</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>company_preferences</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>company_users</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>companies</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>contacts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>customers</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>description_templates</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>currencies</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>d_permission_details</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>countries</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>departments</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>designations</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>default_organization_users</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>document_meta_datas</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>email_templates</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>images</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_entries</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>general_ledgers</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>finance_year</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>entry_sources</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_voucher_details</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_voucher_header_id</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>organization_users</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>messages</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>logs</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>notification_types</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>organizations</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>opening_balances</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>organization_types</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>permission_templates</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_voucher_headers</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>permission_groups</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>schema_versions</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>roles</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>transaction_source_types</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>upis</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>states</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>permissions</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>user_deletion_request_statuses</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>user_deletion_requests</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>user_global_permissions</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>transaction_headers</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>v_finance_year_id</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>v_is_second_last_leaf</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>transaction_header_2022_2023</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>transaction_header_2023_2024</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>vendors</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>user_roles</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>user_permissions</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>warehouses</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>organization_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>users</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>transaction_header_2024_2025</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>transaction_header_2025_2026</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>permission_template_mappings</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_entries_2025_2026</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>budget_lines</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>budget_statuses</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>budgets</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>budget_workflow</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>bank_statements</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_entries_2022_2023</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_entries_2023_2024</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Table</td>
                    <td>journal_entries_2024_2025</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Table</td>
                    <td>users_bk</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Table</td>
                    <td>journal_entries_bk_20_5_25</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Table</td>
                    <td>transaction_headers_bk_20_5_25</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Table</td>
                    <td>temp_paymnet_data</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Table</td>
                    <td>bank_statement</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Table</td>
                    <td>transaction_headers_19_05_25</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Table</td>
                    <td>v_permission_id</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_trial_balance_of_company_fy</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-0')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-0">
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_of_company_fy(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_type text, account_category text, account_number text, account_name text, total_debits numeric, total_credits numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE coa_hierarchy AS (&#xA;        -- Base case: Fetch the top-level (root) accounts with no parent (e.g., Assets, Liabilities)&#xA;        SELECT&#xA;            coa.id,&#xA;            act.name AS account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::text AS order_sequence&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE&#xA;            coa.is_deleted = FALSE&#xA;            AND coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;  -- Root-level accounts&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursive case: Fetch all child accounts for each parent&#xA;        SELECT &#xA;            coa.id,&#xA;            act.name AS account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            ch.level &#x2B; 1 AS level,&#xA;            ch.order_sequence || &#x27;.&#x27; || coa.account_number::text AS order_sequence&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        INNER JOIN &#xA;            coa_hierarchy ch ON ch.id = coa.parent_account_id&#xA;        WHERE&#xA;            coa.is_deleted = FALSE&#xA;    ),&#xA;    coa_with_balances AS (&#xA;        -- Fetch the current financial year start and end date from the finance_year table&#xA;        SELECT&#xA;            fy.start_date::DATE,  -- Cast start_date to DATE&#xA;            fy.end_date::DATE,    -- Cast end_date to DATE&#xA;            fy.year&#xA;        FROM&#xA;            public.finance_year fy&#xA;        WHERE&#xA;            fy.id = p_finance_year_id&#xA;        LIMIT 1&#xA;    ),&#xA;    journal_entries_filtered AS (&#xA;        -- Fetch accounts that have non-zero balances within the financial year range&#xA;        SELECT &#xA;            je.account_id,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS total_debits,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS total_credits&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            coa_with_balances fy ON th.transaction_date BETWEEN fy.start_date AND fy.end_date  -- Filter by financial year&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY &#xA;            je.account_id&#xA;        HAVING &#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) &gt; 0 OR&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) &gt; 0&#xA;    ),&#xA;    relevant_accounts AS (&#xA;        -- Select accounts that have balances directly&#xA;        SELECT &#xA;            ch.id, &#xA;            ch.account_type, &#xA;            ch.account_number, &#xA;            ch.name, &#xA;            ch.level, &#xA;            ch.order_sequence, &#xA;            ch.parent_account_id,&#xA;            wb.total_debits, &#xA;            wb.total_credits&#xA;        FROM &#xA;            coa_hierarchy ch&#xA;        LEFT JOIN &#xA;            journal_entries_filtered wb ON ch.id = wb.account_id&#xA;        WHERE &#xA;            wb.account_id IS NOT NULL  -- Only accounts with actual balances&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursively select parent accounts, without recalculating balances&#xA;        SELECT &#xA;            ch.id, &#xA;            ch.account_type, &#xA;            ch.account_number, &#xA;            ch.name, &#xA;            ch.level, &#xA;            ch.order_sequence, &#xA;            ch.parent_account_id,&#xA;            NULL AS total_debits, &#xA;            NULL AS total_credits&#xA;        FROM &#xA;            coa_hierarchy ch&#xA;        INNER JOIN &#xA;            relevant_accounts ra ON ch.id = ra.parent_account_id  -- Propagate balance up to parent accounts&#xA;    )&#xA;    -- Final output&#xA;    SELECT DISTINCT ON (ra.order_sequence)&#xA;        ra.account_type::TEXT AS account_type,         -- Account type&#xA;        ac.name::TEXT AS account_category,             -- Account category&#xA;        ra.account_number::TEXT AS account_number,     -- Account number&#xA;        LPAD(&#x27;&#x27;, ra.level * 4, &#x27; &#x27;) || ra.name::TEXT AS account_name,  -- Indented account name&#xA;        COALESCE(ra.total_debits, 0) AS total_debits,  -- Sum of debits&#xA;        COALESCE(ra.total_credits, 0) AS total_credits -- Sum of credits&#xA;                        -- Cast end date of the financial year to DATE&#xA;    FROM &#xA;        relevant_accounts ra&#xA;    LEFT JOIN &#xA;        public.chart_of_accounts coa ON ra.id = coa.id  -- Join chart of accounts&#xA;    LEFT JOIN &#xA;        public.account_types at ON coa.account_type_id = at.id  -- Join account types&#xA;    LEFT JOIN &#xA;        public.account_categories ac ON at.account_category_id = ac.id  -- Join account categories&#xA;    CROSS JOIN &#xA;        coa_with_balances fy                            -- Include the financial year details&#xA;    ORDER BY &#xA;        ra.order_sequence;  -- Maintain hierarchy in the output&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_of_company_fy(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_type text, account_category text, account_number text, account_name text, total_debits numeric, total_credits numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE coa_hierarchy AS (&#xA;        -- Base case: Fetch the top-level (root) accounts with no parent (e.g., Assets, Liabilities)&#xA;        SELECT&#xA;            coa.id,&#xA;            act.name AS account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::text AS order_sequence&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE&#xA;            coa.is_deleted = FALSE&#xA;            AND coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;  -- Root-level accounts&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursive case: Fetch all child accounts for each parent&#xA;        SELECT &#xA;            coa.id,&#xA;            act.name AS account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            ch.level &#x2B; 1 AS level,&#xA;            ch.order_sequence || &#x27;.&#x27; || coa.account_number::text AS order_sequence&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        INNER JOIN &#xA;            coa_hierarchy ch ON ch.id = coa.parent_account_id&#xA;        WHERE&#xA;            coa.is_deleted = FALSE&#xA;    ),&#xA;    coa_with_balances AS (&#xA;        -- Fetch the current financial year start and end date from the finance_year table&#xA;        SELECT&#xA;            fy.start_date::DATE,  -- Cast start_date to DATE&#xA;            fy.end_date::DATE,    -- Cast end_date to DATE&#xA;            fy.year&#xA;        FROM&#xA;            public.finance_year fy&#xA;        WHERE&#xA;            fy.id = p_finance_year_id&#xA;        LIMIT 1&#xA;    ),&#xA;    journal_entries_filtered AS (&#xA;        -- Fetch accounts that have non-zero balances within the financial year range&#xA;        SELECT &#xA;            je.account_id,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS total_debits,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS total_credits&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            coa_with_balances fy ON th.transaction_date BETWEEN fy.start_date AND fy.end_date  -- Filter by financial year&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY &#xA;            je.account_id&#xA;        HAVING &#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) &gt; 0 OR&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) &gt; 0&#xA;    ),&#xA;    relevant_accounts AS (&#xA;        -- Select accounts that have balances directly&#xA;        SELECT &#xA;            ch.id, &#xA;            ch.account_type, &#xA;            ch.account_number, &#xA;            ch.name, &#xA;            ch.level, &#xA;            ch.order_sequence, &#xA;            ch.parent_account_id,&#xA;            wb.total_debits, &#xA;            wb.total_credits&#xA;        FROM &#xA;            coa_hierarchy ch&#xA;        LEFT JOIN &#xA;            journal_entries_filtered wb ON ch.id = wb.account_id&#xA;        WHERE &#xA;            wb.account_id IS NOT NULL  -- Only accounts with actual balances&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursively select parent accounts, without recalculating balances&#xA;        SELECT &#xA;            ch.id, &#xA;            ch.account_type, &#xA;            ch.account_number, &#xA;            ch.name, &#xA;            ch.level, &#xA;            ch.order_sequence, &#xA;            ch.parent_account_id,&#xA;            NULL AS total_debits, &#xA;            NULL AS total_credits&#xA;        FROM &#xA;            coa_hierarchy ch&#xA;        INNER JOIN &#xA;            relevant_accounts ra ON ch.id = ra.parent_account_id  -- Propagate balance up to parent accounts&#xA;    )&#xA;    -- Final output&#xA;    SELECT DISTINCT ON (ra.order_sequence)&#xA;        ra.account_type::TEXT AS account_type,         -- Account type&#xA;        ac.name::TEXT AS account_category,             -- Account category&#xA;        ra.account_number::TEXT AS account_number,     -- Account number&#xA;        LPAD(&#x27;&#x27;, ra.level * 4, &#x27; &#x27;) || ra.name::TEXT AS account_name,  -- Indented account name&#xA;        COALESCE(ra.total_debits, 0) AS total_debits,  -- Sum of debits&#xA;        COALESCE(ra.total_credits, 0) AS total_credits -- Sum of credits&#xA;                        -- Cast end date of the financial year to DATE&#xA;    FROM &#xA;        relevant_accounts ra&#xA;    LEFT JOIN &#xA;        public.chart_of_accounts coa ON ra.id = coa.id  -- Join chart of accounts&#xA;    LEFT JOIN &#xA;        public.account_types at ON coa.account_type_id = at.id  -- Join account types&#xA;    LEFT JOIN &#xA;        public.account_categories ac ON at.account_category_id = ac.id  -- Join account categories&#xA;    CROSS JOIN &#xA;        coa_with_balances fy                            -- Include the financial year details&#xA;    ORDER BY &#xA;        ra.order_sequence;  -- Maintain hierarchy in the output&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_account_total_amount</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-1')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-1">
                                            CREATE OR REPLACE FUNCTION public.get_account_total_amount(p_company_id uuid, p_finance_id integer, p_account_id uuid)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_amount NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Check if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total amount for the specific account within the financial year,&#xA;    -- ensuring the `organization_id` matches&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_amount&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND je.account_id = p_account_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE;&#xA;&#xA;    -- Step 6: Return the total amount&#xA;    RETURN v_total_amount;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_account_total_amount(p_company_id uuid, p_finance_id integer, p_account_id uuid)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_amount NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Check if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total amount for the specific account within the financial year,&#xA;    -- ensuring the `organization_id` matches&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_amount&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND je.account_id = p_account_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE;&#xA;&#xA;    -- Step 6: Return the total amount&#xA;    RETURN v_total_amount;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_account_ledger</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-2')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-2">
                                            CREATE OR REPLACE FUNCTION public.get_account_ledger(p_account_id uuid, p_company_id uuid, p_organization_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, transaction_source_type integer, document_number text, document_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH account_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date, -- Cast to date&#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            je.account_id,&#xA;            th.transaction_source_type,   &#xA;            th.document_number,           &#xA;            th.document_id              &#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            je.account_id = p_account_id&#xA;            AND th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date  &#xA;            AND th.transaction_date &lt;= p_end_date  &#xA;    )&#xA;    SELECT &#xA;        at.transaction_date,&#xA;        at.account_name,&#xA;        at.debit,&#xA;        at.credit,&#xA;        SUM(at.debit - at.credit) OVER (PARTITION BY at.account_id ORDER BY at.transaction_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS balance,&#xA;        at.transaction_source_type,   &#xA;        at.document_number,          &#xA;        at.document_id                &#xA;    FROM &#xA;        account_transactions at&#xA;&#x9;WHERE&#xA;&#x9;&#x9;NOT (at.debit = 0 AND at.credit = 0)&#xA;    ORDER BY &#xA;        at.transaction_date;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_account_ledger(p_account_id uuid, p_company_id uuid, p_organization_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, transaction_source_type integer, document_number text, document_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH account_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date, -- Cast to date&#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            je.account_id,&#xA;            th.transaction_source_type,   &#xA;            th.document_number,           &#xA;            th.document_id              &#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            je.account_id = p_account_id&#xA;            AND th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date  &#xA;            AND th.transaction_date &lt;= p_end_date  &#xA;    )&#xA;    SELECT &#xA;        at.transaction_date,&#xA;        at.account_name,&#xA;        at.debit,&#xA;        at.credit,&#xA;        SUM(at.debit - at.credit) OVER (PARTITION BY at.account_id ORDER BY at.transaction_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS balance,&#xA;        at.transaction_source_type,   &#xA;        at.document_number,          &#xA;        at.document_id                &#xA;    FROM &#xA;        account_transactions at&#xA;&#x9;WHERE&#xA;&#x9;&#x9;NOT (at.debit = 0 AND at.credit = 0)&#xA;    ORDER BY &#xA;        at.transaction_date;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_trial_balance_test</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-3')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-3">
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_test(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_type text, account_category text, account_number text, account_name text, total_debits numeric, total_credits numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH financial_year_range AS (&#xA;        SELECT&#xA;            fy.start_date::DATE AS start_date,&#xA;            fy.end_date::DATE AS end_date&#xA;        FROM&#xA;            public.finance_year fy&#xA;        WHERE&#xA;            fy.id = p_finance_year_id&#xA;        LIMIT 1&#xA;    ),&#xA;    account_balances AS (&#xA;        SELECT&#xA;            je.account_id,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS total_debits,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS total_credits&#xA;        FROM&#xA;            public.journal_entries je&#xA;        JOIN&#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        CROSS JOIN&#xA;            financial_year_range fy&#xA;        WHERE&#xA;            th.company_id = p_company_id&#xA;            AND je.is_deleted = FALSE&#xA;            AND th.transaction_date BETWEEN fy.start_date AND fy.end_date&#xA;        GROUP BY&#xA;            je.account_id&#xA;    )&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        ac.name::text AS account_category,  -- Explicitly cast to text&#xA;        coa.account_number,&#xA;        coa.name AS account_name,&#xA;        COALESCE(ab.total_debits, 0) AS total_debits,&#xA;        COALESCE(ab.total_credits, 0) AS total_credits&#xA;    FROM&#xA;        public.chart_of_accounts coa&#xA;    INNER JOIN&#xA;        public.account_types at ON coa.account_type_id = at.id&#xA;    LEFT JOIN&#xA;        public.account_categories ac ON at.account_category_id = ac.id&#xA;    LEFT JOIN&#xA;        account_balances ab ON coa.id = ab.account_id&#xA;    WHERE&#xA;        coa.organization_id = p_company_id&#xA;        AND coa.is_deleted = FALSE&#xA;    ORDER BY&#xA;        coa.account_number;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_test(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_type text, account_category text, account_number text, account_name text, total_debits numeric, total_credits numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH financial_year_range AS (&#xA;        SELECT&#xA;            fy.start_date::DATE AS start_date,&#xA;            fy.end_date::DATE AS end_date&#xA;        FROM&#xA;            public.finance_year fy&#xA;        WHERE&#xA;            fy.id = p_finance_year_id&#xA;        LIMIT 1&#xA;    ),&#xA;    account_balances AS (&#xA;        SELECT&#xA;            je.account_id,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS total_debits,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS total_credits&#xA;        FROM&#xA;            public.journal_entries je&#xA;        JOIN&#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        CROSS JOIN&#xA;            financial_year_range fy&#xA;        WHERE&#xA;            th.company_id = p_company_id&#xA;            AND je.is_deleted = FALSE&#xA;            AND th.transaction_date BETWEEN fy.start_date AND fy.end_date&#xA;        GROUP BY&#xA;            je.account_id&#xA;    )&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        ac.name::text AS account_category,  -- Explicitly cast to text&#xA;        coa.account_number,&#xA;        coa.name AS account_name,&#xA;        COALESCE(ab.total_debits, 0) AS total_debits,&#xA;        COALESCE(ab.total_credits, 0) AS total_credits&#xA;    FROM&#xA;        public.chart_of_accounts coa&#xA;    INNER JOIN&#xA;        public.account_types at ON coa.account_type_id = at.id&#xA;    LEFT JOIN&#xA;        public.account_categories ac ON at.account_category_id = ac.id&#xA;    LEFT JOIN&#xA;        account_balances ab ON coa.id = ab.account_id&#xA;    WHERE&#xA;        coa.organization_id = p_company_id&#xA;        AND coa.is_deleted = FALSE&#xA;    ORDER BY&#xA;        coa.account_number;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_account_total_amount_by_date_range</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-4')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-4">
                                            CREATE OR REPLACE FUNCTION public.get_account_total_amount_by_date_range(p_company_id uuid, p_finance_id integer, p_account_id uuid, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_amount NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Check if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total amount for the specific account within the given date range&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_amount&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND je.account_id = p_account_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN COALESCE(p_start_date, v_financial_year_start) -- Use provided start date or financial year start&#xA;                                AND COALESCE(p_end_date, v_financial_year_end)       -- Use provided end date or financial year end&#xA;      AND je.is_deleted = FALSE;&#xA;&#xA;    -- Step 6: Return the total amount&#xA;    RETURN v_total_amount;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_account_total_amount_by_date_range(p_company_id uuid, p_finance_id integer, p_account_id uuid, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_amount NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Check if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total amount for the specific account within the given date range&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_amount&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND je.account_id = p_account_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN COALESCE(p_start_date, v_financial_year_start) -- Use provided start date or financial year start&#xA;                                AND COALESCE(p_end_date, v_financial_year_end)       -- Use provided end date or financial year end&#xA;      AND je.is_deleted = FALSE;&#xA;&#xA;    -- Step 6: Return the total amount&#xA;    RETURN v_total_amount;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Function</td>
                    <td>dummy_hello_function</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_account_type_hierarchy</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-5')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-5">
                                            CREATE OR REPLACE FUNCTION public.get_account_type_hierarchy(parent_id integer)&#xA; RETURNS TABLE(id integer, name text, parent_account_type_id integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE account_hierarchy AS (&#xA;        -- Base case: Start with the given parent account type&#xA;        SELECT &#xA;            p.id, &#xA;            p.name, &#xA;            p.parent_account_type_id&#xA;        FROM &#xA;            public.account_types p&#xA;        WHERE &#xA;            p.id = parent_id&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursive case: Include child account types&#xA;        SELECT &#xA;            at.id, &#xA;            at.name, &#xA;            at.parent_account_type_id&#xA;        FROM &#xA;            public.account_types at&#xA;        INNER JOIN &#xA;            account_hierarchy ah ON at.parent_account_type_id = ah.id&#xA;    )&#xA;    SELECT &#xA;        acch.id, &#xA;        acch.name, &#xA;        acch.parent_account_type_id&#xA;    FROM &#xA;        account_hierarchy acch&#xA;&#x9;ORDER BY acch.id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_account_type_hierarchy(parent_id integer)&#xA; RETURNS TABLE(id integer, name text, parent_account_type_id integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE account_hierarchy AS (&#xA;        -- Base case: Start with the given parent account type&#xA;        SELECT &#xA;            p.id, &#xA;            p.name, &#xA;            p.parent_account_type_id&#xA;        FROM &#xA;            public.account_types p&#xA;        WHERE &#xA;            p.id = parent_id&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursive case: Include child account types&#xA;        SELECT &#xA;            at.id, &#xA;            at.name, &#xA;            at.parent_account_type_id&#xA;        FROM &#xA;            public.account_types at&#xA;        INNER JOIN &#xA;            account_hierarchy ah ON at.parent_account_type_id = ah.id&#xA;    )&#xA;    SELECT &#xA;        acch.id, &#xA;        acch.name, &#xA;        acch.parent_account_type_id&#xA;    FROM &#xA;        account_hierarchy acch&#xA;&#x9;ORDER BY acch.id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_accounts_by_classification</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-6')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-6">
                                            CREATE OR REPLACE FUNCTION public.get_accounts_by_classification(classification_type text)&#xA; RETURNS TABLE(account_id uuid, account_name text, account_type_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        coa.id AS account_id,&#xA;        coa.name AS account_name,&#xA;        at.name AS account_type_name&#xA;    FROM&#xA;        chart_of_accounts coa&#xA;    INNER JOIN&#xA;        account_types at&#xA;    ON&#xA;        coa.account_type_id = at.id&#xA;    WHERE&#xA;        at.classification = classification_type; -- Filter by classification parameter&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_accounts_by_classification(classification_type text)&#xA; RETURNS TABLE(account_id uuid, account_name text, account_type_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        coa.id AS account_id,&#xA;        coa.name AS account_name,&#xA;        at.name AS account_type_name&#xA;    FROM&#xA;        chart_of_accounts coa&#xA;    INNER JOIN&#xA;        account_types at&#xA;    ON&#xA;        coa.account_type_id = at.id&#xA;    WHERE&#xA;        at.classification = classification_type; -- Filter by classification parameter&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_accounts_by_company_and_type</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-7')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-7">
                                            CREATE OR REPLACE FUNCTION public.get_accounts_by_company_and_type(p_company_id uuid, p_account_type integer)&#xA; RETURNS TABLE(id uuid, account_type_id integer, name text, description text, is_default_account boolean)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_is_apartment BOOLEAN;&#xA;&#xA;    v_default_sales UUID;&#xA;    v_default_purchase UUID;&#xA;    v_default_cash UUID;&#xA;    v_default_bank UUID;&#xA;BEGIN&#xA;    -- &#x2705; Fix ambiguous column: use alias &#x27;c&#x27;&#xA;    SELECT c.organization_id, c.is_apartment&#xA;    INTO v_organization_id, v_is_apartment&#xA;    FROM companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- &#x2705; Fix ambiguous column: use alias &#x27;cp&#x27;&#xA;    SELECT cp.default_sales_account_id,&#xA;           cp.default_purchase_account_id,&#xA;           cp.default_cash_account_id,&#xA;           cp.default_bank_account_id&#xA;    INTO v_default_sales, v_default_purchase, v_default_cash, v_default_bank&#xA;    FROM company_preferences cp&#xA;    WHERE cp.company_id = p_company_id;&#xA;&#xA;    -- &#x2705; Main query using table alias &#x27;coa&#x27;&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        coa.id,&#xA;        coa.account_type_id,&#xA;        coa.name,&#xA;        coa.description,&#xA;        CASE &#xA;            WHEN coa.id = v_default_sales THEN TRUE&#xA;            WHEN coa.id = v_default_purchase THEN TRUE&#xA;            WHEN coa.id = v_default_cash THEN TRUE&#xA;            WHEN coa.id = v_default_bank THEN TRUE&#xA;            ELSE FALSE&#xA;        END AS is_default_account&#xA;    FROM chart_of_accounts coa&#xA;    WHERE coa.organization_id = v_organization_id&#xA;      AND NOT EXISTS (&#xA;          SELECT 1 FROM chart_of_accounts ca2 WHERE ca2.parent_account_id = coa.id&#xA;      )&#xA;      AND (&#xA;        (&#xA;          v_is_apartment = TRUE AND (&#xA;            (p_account_type = 14 AND coa.account_type_id IN (19, 20)) OR -- SALES_REVENUE&#xA;            (p_account_type IN (16, 17) AND coa.account_type_id IN (21, 22)) OR -- COGS or OPERATING&#xA;            (p_account_type = 9 AND coa.account_type_id = 9) OR -- BANK&#xA;            (p_account_type = 8 AND coa.account_type_id = 8) OR -- CASH&#xA;            (p_account_type = 23 AND coa.account_type_id IN (8, 9)) -- BANK_AND_CASH&#xA;          )&#xA;        )&#xA;        OR&#xA;        (&#xA;          v_is_apartment = FALSE AND (&#xA;            (p_account_type = coa.account_type_id) OR&#xA;            (p_account_type = 23 AND coa.account_type_id IN (8, 9)) -- BANK_AND_CASH&#xA;          )&#xA;        )&#xA;      );&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_accounts_by_company_and_type(p_company_id uuid, p_account_type integer)&#xA; RETURNS TABLE(id uuid, account_type_id integer, name text, description text, is_default_account boolean)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_is_apartment BOOLEAN;&#xA;&#xA;    v_default_sales UUID;&#xA;    v_default_purchase UUID;&#xA;    v_default_cash UUID;&#xA;    v_default_bank UUID;&#xA;BEGIN&#xA;    -- &#x2705; Fix ambiguous column: use alias &#x27;c&#x27;&#xA;    SELECT c.organization_id, c.is_apartment&#xA;    INTO v_organization_id, v_is_apartment&#xA;    FROM companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- &#x2705; Fix ambiguous column: use alias &#x27;cp&#x27;&#xA;    SELECT cp.default_sales_account_id,&#xA;           cp.default_purchase_account_id,&#xA;           cp.default_cash_account_id,&#xA;           cp.default_bank_account_id&#xA;    INTO v_default_sales, v_default_purchase, v_default_cash, v_default_bank&#xA;    FROM company_preferences cp&#xA;    WHERE cp.company_id = p_company_id;&#xA;&#xA;    -- &#x2705; Main query using table alias &#x27;coa&#x27;&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        coa.id,&#xA;        coa.account_type_id,&#xA;        coa.name,&#xA;        coa.description,&#xA;        CASE &#xA;            WHEN coa.id = v_default_sales THEN TRUE&#xA;            WHEN coa.id = v_default_purchase THEN TRUE&#xA;            WHEN coa.id = v_default_cash THEN TRUE&#xA;            WHEN coa.id = v_default_bank THEN TRUE&#xA;            ELSE FALSE&#xA;        END AS is_default_account&#xA;    FROM chart_of_accounts coa&#xA;    WHERE coa.organization_id = v_organization_id&#xA;      AND NOT EXISTS (&#xA;          SELECT 1 FROM chart_of_accounts ca2 WHERE ca2.parent_account_id = coa.id&#xA;      )&#xA;      AND (&#xA;        (&#xA;          v_is_apartment = TRUE AND (&#xA;            (p_account_type = 14 AND coa.account_type_id IN (19, 20)) OR -- SALES_REVENUE&#xA;            (p_account_type IN (16, 17) AND coa.account_type_id IN (21, 22)) OR -- COGS or OPERATING&#xA;            (p_account_type = 9 AND coa.account_type_id = 9) OR -- BANK&#xA;            (p_account_type = 8 AND coa.account_type_id = 8) OR -- CASH&#xA;            (p_account_type = 23 AND coa.account_type_id IN (8, 9)) -- BANK_AND_CASH&#xA;          )&#xA;        )&#xA;        OR&#xA;        (&#xA;          v_is_apartment = FALSE AND (&#xA;            (p_account_type = coa.account_type_id) OR&#xA;            (p_account_type = 23 AND coa.account_type_id IN (8, 9)) -- BANK_AND_CASH&#xA;          )&#xA;        )&#xA;      );&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_all_companies</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-8')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-8">
                                            CREATE OR REPLACE FUNCTION public.get_all_companies(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, organization_id uuid, name character varying, contact_name character varying, contact_count integer, mobile_number character varying, gst_in character varying, email character varying, city_name character varying, is_apartment boolean, created_by uuid, created_by_name character varying, modified_by uuid, modified_by_name character varying, created_on_utc timestamp without time zone, modified_on_utc timestamp without time zone)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        cmp.id,&#xA;        cmp.organization_id,&#xA;        cmp.name::character varying,&#xA;        COALESCE(&#xA;            (SELECT con.first_name || &#x27; &#x27; || con.last_name &#xA;             FROM public.contacts con&#xA;             JOIN public.company_contacts cc &#xA;             ON con.id = cc.contact_id &#xA;             WHERE cc.company_id = cmp.id AND con.is_primary = true&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS primary_contact_name,&#xA;        (SELECT COUNT(*) &#xA;         FROM public.contacts con&#xA;         JOIN public.company_contacts cc &#xA;         ON con.id = cc.contact_id &#xA;         WHERE cc.company_id = cmp.id)::integer AS contact_count,&#xA;        COALESCE(&#xA;            (SELECT con.mobile_number &#xA;             FROM public.contacts con&#xA;             JOIN public.company_contacts cc &#xA;             ON con.id = cc.contact_id &#xA;             WHERE cc.company_id = cmp.id AND con.is_primary = true&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS primary_contact_mobile,&#xA;        cmp.gstin::character varying AS gst_in,&#xA;        COALESCE(&#xA;            (SELECT con.email &#xA;             FROM public.contacts con&#xA;             JOIN public.company_contacts cc &#xA;             ON con.id = cc.contact_id &#xA;             WHERE cc.company_id = cmp.id AND con.is_primary = true&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS primary_contact_email,&#xA;        COALESCE(&#xA;            (SELECT ct.name &#xA;             FROM public.cities ct&#xA;             WHERE ct.id = (&#xA;                 SELECT ad.city_id &#xA;                 FROM public.addresses ad &#xA;                 WHERE ad.id = cmp.billing_address_id&#xA;                 LIMIT 1)&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS city_name,&#xA;        cmp.is_apartment,&#xA;        cmp.created_by,&#xA;        COALESCE(&#xA;            (SELECT u.first_name || &#x27; &#x27; || u.last_name &#xA;             FROM public.users u &#xA;             WHERE u.id = cmp.created_by), &#x27;&#x27;&#xA;        )::character varying AS created_by_name,&#xA;        cmp.modified_by,&#xA;        COALESCE(&#xA;            (SELECT u.first_name || &#x27; &#x27; || u.last_name &#xA;             FROM public.users u &#xA;             WHERE u.id = cmp.modified_by), &#x27;&#x27;&#xA;        )::character varying AS modified_by_name,&#xA;        cmp.created_on_utc,&#xA;        cmp.modified_on_utc&#xA;    FROM &#xA;        public.companies cmp&#xA;    WHERE &#xA;        cmp.organization_id = p_organization_id&#xA;        AND cmp.is_deleted = false;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_all_companies(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, organization_id uuid, name character varying, contact_name character varying, contact_count integer, mobile_number character varying, gst_in character varying, email character varying, city_name character varying, is_apartment boolean, created_by uuid, created_by_name character varying, modified_by uuid, modified_by_name character varying, created_on_utc timestamp without time zone, modified_on_utc timestamp without time zone)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        cmp.id,&#xA;        cmp.organization_id,&#xA;        cmp.name::character varying,&#xA;        COALESCE(&#xA;            (SELECT con.first_name || &#x27; &#x27; || con.last_name &#xA;             FROM public.contacts con&#xA;             JOIN public.company_contacts cc &#xA;             ON con.id = cc.contact_id &#xA;             WHERE cc.company_id = cmp.id AND con.is_primary = true&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS primary_contact_name,&#xA;        (SELECT COUNT(*) &#xA;         FROM public.contacts con&#xA;         JOIN public.company_contacts cc &#xA;         ON con.id = cc.contact_id &#xA;         WHERE cc.company_id = cmp.id)::integer AS contact_count,&#xA;        COALESCE(&#xA;            (SELECT con.mobile_number &#xA;             FROM public.contacts con&#xA;             JOIN public.company_contacts cc &#xA;             ON con.id = cc.contact_id &#xA;             WHERE cc.company_id = cmp.id AND con.is_primary = true&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS primary_contact_mobile,&#xA;        cmp.gstin::character varying AS gst_in,&#xA;        COALESCE(&#xA;            (SELECT con.email &#xA;             FROM public.contacts con&#xA;             JOIN public.company_contacts cc &#xA;             ON con.id = cc.contact_id &#xA;             WHERE cc.company_id = cmp.id AND con.is_primary = true&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS primary_contact_email,&#xA;        COALESCE(&#xA;            (SELECT ct.name &#xA;             FROM public.cities ct&#xA;             WHERE ct.id = (&#xA;                 SELECT ad.city_id &#xA;                 FROM public.addresses ad &#xA;                 WHERE ad.id = cmp.billing_address_id&#xA;                 LIMIT 1)&#xA;             LIMIT 1), &#x27;&#x27;&#xA;        )::character varying AS city_name,&#xA;        cmp.is_apartment,&#xA;        cmp.created_by,&#xA;        COALESCE(&#xA;            (SELECT u.first_name || &#x27; &#x27; || u.last_name &#xA;             FROM public.users u &#xA;             WHERE u.id = cmp.created_by), &#x27;&#x27;&#xA;        )::character varying AS created_by_name,&#xA;        cmp.modified_by,&#xA;        COALESCE(&#xA;            (SELECT u.first_name || &#x27; &#x27; || u.last_name &#xA;             FROM public.users u &#xA;             WHERE u.id = cmp.modified_by), &#x27;&#x27;&#xA;        )::character varying AS modified_by_name,&#xA;        cmp.created_on_utc,&#xA;        cmp.modified_on_utc&#xA;    FROM &#xA;        public.companies cmp&#xA;    WHERE &#xA;        cmp.organization_id = p_organization_id&#xA;        AND cmp.is_deleted = false;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_all_expense_categories</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-9')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-9">
                                            CREATE OR REPLACE FUNCTION public.get_all_expense_categories(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_name text, account_number text, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start date;&#xA;    v_financial_year_end date;&#xA;BEGIN&#xA;    -- Get financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date &#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Handle case where no financial year is found&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE AccountHierarchy AS (&#xA;        -- Base case: Select root accounts (only considering expense accounts, i.e., account_type_id = 5)&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.account_number,&#xA;            coa.parent_account_id&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        WHERE &#xA;            coa.account_type_id = 5&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursive case: Select all child accounts under the root accounts&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.account_number,&#xA;            coa.parent_account_id&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN &#xA;            AccountHierarchy ah ON coa.parent_account_id = ah.account_id&#xA;    )&#xA;    &#xA;    -- Calculate total expenses grouped by account, filtering by company_id in transaction_headers&#xA;    SELECT &#xA;        ah.name AS account_name,&#xA;        ah.account_number,&#xA;        COALESCE(SUM(je.amount), 0) AS total_expense&#xA;    FROM &#xA;        AccountHierarchy ah&#xA;    JOIN &#xA;        public.journal_entries je ON je.account_id = ah.account_id&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    WHERE &#xA;        th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;        AND je.is_deleted = FALSE&#xA;    GROUP BY &#xA;        ah.name, ah.account_number&#xA;    ORDER BY &#xA;        total_expense DESC;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_all_expense_categories(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_name text, account_number text, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start date;&#xA;    v_financial_year_end date;&#xA;BEGIN&#xA;    -- Get financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date &#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Handle case where no financial year is found&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE AccountHierarchy AS (&#xA;        -- Base case: Select root accounts (only considering expense accounts, i.e., account_type_id = 5)&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.account_number,&#xA;            coa.parent_account_id&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        WHERE &#xA;            coa.account_type_id = 5&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursive case: Select all child accounts under the root accounts&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.account_number,&#xA;            coa.parent_account_id&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN &#xA;            AccountHierarchy ah ON coa.parent_account_id = ah.account_id&#xA;    )&#xA;    &#xA;    -- Calculate total expenses grouped by account, filtering by company_id in transaction_headers&#xA;    SELECT &#xA;        ah.name AS account_name,&#xA;        ah.account_number,&#xA;        COALESCE(SUM(je.amount), 0) AS total_expense&#xA;    FROM &#xA;        AccountHierarchy ah&#xA;    JOIN &#xA;        public.journal_entries je ON je.account_id = ah.account_id&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    WHERE &#xA;        th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;        AND je.is_deleted = FALSE&#xA;    GROUP BY &#xA;        ah.name, ah.account_number&#xA;    ORDER BY &#xA;        total_expense DESC;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_coa_by_account_type</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-10')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-10">
                                            CREATE OR REPLACE FUNCTION public.get_coa_by_account_type(account_type_id_input integer)&#xA; RETURNS TABLE(coa_id uuid, coa_name text, coa_account_number text, coa_description text, coa_current_balance numeric, coa_opening_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        coa.id AS coa_id,&#xA;        coa.name AS coa_name,&#xA;        coa.account_number AS coa_account_number,&#xA;        coa.description AS coa_description,&#xA;        coa.current_balance AS coa_current_balance,&#xA;        coa.opening_balance AS coa_opening_balance&#xA;    FROM &#xA;        chart_of_accounts coa&#xA;    WHERE &#xA;        coa.account_type_id = account_type_id_input&#xA;        AND coa.is_deleted = FALSE; -- Ensuring only active records are returned&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_coa_by_account_type(account_type_id_input integer)&#xA; RETURNS TABLE(coa_id uuid, coa_name text, coa_account_number text, coa_description text, coa_current_balance numeric, coa_opening_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        coa.id AS coa_id,&#xA;        coa.name AS coa_name,&#xA;        coa.account_number AS coa_account_number,&#xA;        coa.description AS coa_description,&#xA;        coa.current_balance AS coa_current_balance,&#xA;        coa.opening_balance AS coa_opening_balance&#xA;    FROM &#xA;        chart_of_accounts coa&#xA;    WHERE &#xA;        coa.account_type_id = account_type_id_input&#xA;        AND coa.is_deleted = FALSE; -- Ensuring only active records are returned&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_collection</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-11')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-11">
                                            CREATE OR REPLACE FUNCTION public.get_collection(p_company_id uuid)&#xA; RETURNS TABLE(year numeric, total_income numeric, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    financial_year_start date;&#xA;    financial_year_end date;&#xA;    current_year integer;&#xA;BEGIN&#xA;    -- Determine the current year  &#xA;    current_year := EXTRACT(YEAR FROM CURRENT_DATE);&#xA;&#xA;    -- Determine the financial year start and end dates &#xA;    IF EXTRACT(MONTH FROM CURRENT_DATE) &gt;= 4 THEN&#xA;        -- If the current month is April or later, financial year starts from April 1 of the current year&#xA;        financial_year_start := TO_DATE(current_year || &#x27;-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;        financial_year_end := TO_DATE((current_year &#x2B; 1) || &#x27;-03-31&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;    ELSE&#xA;        -- If the current month is before April, financial year starts from April 1 of the previous year&#xA;        financial_year_start := TO_DATE((current_year - 1) || &#x27;-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;        financial_year_end := TO_DATE(current_year || &#x27;-03-31&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;    END IF;&#xA;&#xA;    -- Return the yearly income and expense overview&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        EXTRACT(YEAR FROM je.transaction_date) AS year,&#xA;        SUM(CASE &#xA;            WHEN ac.id = 4 THEN je.amount -- Revenue&#xA;            ELSE 0 &#xA;        END) AS total_income,&#xA;        SUM(CASE &#xA;            WHEN ac.id = 5 THEN je.amount -- Expenses&#xA;            ELSE 0 &#xA;        END) AS total_expense&#xA;    FROM &#xA;        journal_entries je&#xA;    JOIN &#xA;        chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        account_types act ON coa.account_type_id = act.id&#xA;    JOIN &#xA;        account_categories ac ON act.account_category_id = ac.id&#xA;    WHERE &#xA;        je.transaction_date BETWEEN financial_year_start AND financial_year_end&#xA;        AND je.company_id = p_company_id&#xA;    GROUP BY &#xA;        year&#xA;    ORDER BY &#xA;        year;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_collection(p_company_id uuid)&#xA; RETURNS TABLE(year numeric, total_income numeric, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    financial_year_start date;&#xA;    financial_year_end date;&#xA;    current_year integer;&#xA;BEGIN&#xA;    -- Determine the current year  &#xA;    current_year := EXTRACT(YEAR FROM CURRENT_DATE);&#xA;&#xA;    -- Determine the financial year start and end dates &#xA;    IF EXTRACT(MONTH FROM CURRENT_DATE) &gt;= 4 THEN&#xA;        -- If the current month is April or later, financial year starts from April 1 of the current year&#xA;        financial_year_start := TO_DATE(current_year || &#x27;-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;        financial_year_end := TO_DATE((current_year &#x2B; 1) || &#x27;-03-31&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;    ELSE&#xA;        -- If the current month is before April, financial year starts from April 1 of the previous year&#xA;        financial_year_start := TO_DATE((current_year - 1) || &#x27;-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;        financial_year_end := TO_DATE(current_year || &#x27;-03-31&#x27;, &#x27;YYYY-MM-DD&#x27;);&#xA;    END IF;&#xA;&#xA;    -- Return the yearly income and expense overview&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        EXTRACT(YEAR FROM je.transaction_date) AS year,&#xA;        SUM(CASE &#xA;            WHEN ac.id = 4 THEN je.amount -- Revenue&#xA;            ELSE 0 &#xA;        END) AS total_income,&#xA;        SUM(CASE &#xA;            WHEN ac.id = 5 THEN je.amount -- Expenses&#xA;            ELSE 0 &#xA;        END) AS total_expense&#xA;    FROM &#xA;        journal_entries je&#xA;    JOIN &#xA;        chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        account_types act ON coa.account_type_id = act.id&#xA;    JOIN &#xA;        account_categories ac ON act.account_category_id = ac.id&#xA;    WHERE &#xA;        je.transaction_date BETWEEN financial_year_start AND financial_year_end&#xA;        AND je.company_id = p_company_id&#xA;    GROUP BY &#xA;        year&#xA;    ORDER BY &#xA;        year;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_company_details</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-12')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-12">
                                            CREATE OR REPLACE FUNCTION public.get_company_details(p_company_id uuid)&#xA; RETURNS TABLE(id uuid, organization_id uuid, name text, short_name text, gst_in text, pan text, tan text, currency text, proprietor_name text, outstanding_limit numeric, is_non_work boolean, is_apartment boolean, interest_percentage numeric, billing_address_id uuid, billing_address jsonb, shipping_address_id uuid, shipping_address jsonb, bank_accounts jsonb, contacts jsonb, description text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        com.id,&#xA;        com.organization_id,&#xA;        com.name,&#xA;        com.short_name,&#xA;        com.gstin,&#xA;        com.pan,&#xA;        com.tan,&#xA;        com.currency,&#xA;        com.proprietor_name,&#xA;        com.outstanding_limit,&#xA;        com.is_non_work,&#xA;        com.is_apartment,&#xA;        com.interest_percentage,&#xA;        com.billing_address_id,&#xA;        CASE &#xA;            WHEN ba.id IS NOT NULL   &#xA;            THEN jsonb_build_object(&#xA;                &#x27;AddressLine1&#x27;, ba.address_line1,&#xA;                &#x27;AddressLine2&#x27;, ba.address_line2,&#xA;                &#x27;ZipCode&#x27;, ba.zip_code,&#xA;                &#x27;CountryId&#x27;, ba.country_id,&#xA;                &#x27;CountryName&#x27;, bc.name,&#xA;                &#x27;StateId&#x27;, ba.state_id,&#xA;                &#x27;StateName&#x27;, bs.name,&#xA;                &#x27;CityId&#x27;, ba.city_id,&#xA;                &#x27;CityName&#x27;, bci.name&#xA;            ) &#xA;            ELSE NULL&#xA;        END AS billing_address,&#xA;        com.shipping_address_id,&#xA;        CASE &#xA;            WHEN sa.id IS NOT NULL   &#xA;            THEN jsonb_build_object(&#xA;                &#x27;AddressLine1&#x27;, sa.address_line1,&#xA;                &#x27;AddressLine2&#x27;, sa.address_line2,&#xA;                &#x27;ZipCode&#x27;, sa.zip_code,&#xA;                &#x27;CountryId&#x27;, sa.country_id,&#xA;                &#x27;CountryName&#x27;, sc.name,&#xA;                &#x27;StateId&#x27;, sa.state_id,&#xA;                &#x27;StateName&#x27;, ss.name,&#xA;                &#x27;CityId&#x27;, sa.city_id,&#xA;                &#x27;CityName&#x27;, sci.name&#xA;            ) &#xA;            ELSE NULL&#xA;        END AS shipping_address,&#xA;        COALESCE(&#xA;            (&#xA;                SELECT jsonb_agg(&#xA;                    jsonb_build_object(&#xA;                        &#x27;Id&#x27;, ba.id,&#xA;                        &#x27;BankId&#x27;, ba.bank_id,&#xA;                        &#x27;BankName&#x27;, b.name,&#xA;                        &#x27;BranchName&#x27;, ba.branch_name,&#xA;                        &#x27;AccountNumber&#x27;, ba.account_number,&#xA;                        &#x27;IFSC&#x27;, ba.ifsc&#xA;                    )&#xA;                )&#xA;                FROM company_bank_accounts AS cba&#xA;                JOIN bank_accounts AS ba ON ba.id = cba.bank_account_id&#xA;                JOIN banks AS b ON b.id = ba.bank_id&#xA;                WHERE cba.company_id = com.id  AND ba.is_deleted = false&#xA;            ),&#xA;            &#x27;[]&#x27;::jsonb&#xA;        ) AS bank_accounts,&#xA;        COALESCE(&#xA;            (&#xA;                SELECT jsonb_agg(&#xA;                    jsonb_build_object(&#xA;                        &#x27;Id&#x27;, c.id,&#xA;                        &#x27;Salutation&#x27;, c.salutation,&#xA;                        &#x27;FirstName&#x27;, c.first_name,&#xA;                        &#x27;LastName&#x27;, c.last_name,&#xA;                        &#x27;Email&#x27;, c.email,&#xA;                        &#x27;PhoneNumber&#x27;, c.phone_number,&#xA;                        &#x27;MobileNumber&#x27;, c.mobile_number,&#xA;                        &#x27;IsPrimary&#x27;, c.is_primary&#xA;                    )&#xA;                )&#xA;                FROM company_contacts AS cc&#xA;                JOIN contacts AS c ON c.id = cc.contact_id&#xA;                WHERE cc.company_id = com.id  AND c.is_deleted = false&#xA;            ),&#xA;            &#x27;[]&#x27;::jsonb&#xA;        ) AS contacts,&#xA;        com.description&#xA;    FROM companies AS com&#xA;    LEFT JOIN addresses AS ba ON ba.id = com.billing_address_id&#xA;    LEFT JOIN countries AS bc ON bc.id = ba.country_id&#xA;    LEFT JOIN states AS bs ON bs.id = ba.state_id&#xA;    LEFT JOIN cities AS bci ON bci.id = ba.city_id&#xA;    LEFT JOIN addresses AS sa ON sa.id = com.shipping_address_id&#xA;    LEFT JOIN countries AS sc ON sc.id = sa.country_id&#xA;    LEFT JOIN states AS ss ON ss.id = sa.state_id&#xA;    LEFT JOIN cities AS sci ON sci.id = sa.city_id&#xA;    WHERE com.id = p_company_id AND com.is_deleted = false;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_company_details(p_company_id uuid)&#xA; RETURNS TABLE(id uuid, organization_id uuid, name text, short_name text, gst_in text, pan text, tan text, currency text, proprietor_name text, outstanding_limit numeric, is_non_work boolean, is_apartment boolean, interest_percentage numeric, billing_address_id uuid, billing_address jsonb, shipping_address_id uuid, shipping_address jsonb, bank_accounts jsonb, contacts jsonb, description text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        com.id,&#xA;        com.organization_id,&#xA;        com.name,&#xA;        com.short_name,&#xA;        com.gstin,&#xA;        com.pan,&#xA;        com.tan,&#xA;        com.currency,&#xA;        com.proprietor_name,&#xA;        com.outstanding_limit,&#xA;        com.is_non_work,&#xA;        com.is_apartment,&#xA;        com.interest_percentage,&#xA;        com.billing_address_id,&#xA;        CASE &#xA;            WHEN ba.id IS NOT NULL   &#xA;            THEN jsonb_build_object(&#xA;                &#x27;AddressLine1&#x27;, ba.address_line1,&#xA;                &#x27;AddressLine2&#x27;, ba.address_line2,&#xA;                &#x27;ZipCode&#x27;, ba.zip_code,&#xA;                &#x27;CountryId&#x27;, ba.country_id,&#xA;                &#x27;CountryName&#x27;, bc.name,&#xA;                &#x27;StateId&#x27;, ba.state_id,&#xA;                &#x27;StateName&#x27;, bs.name,&#xA;                &#x27;CityId&#x27;, ba.city_id,&#xA;                &#x27;CityName&#x27;, bci.name&#xA;            ) &#xA;            ELSE NULL&#xA;        END AS billing_address,&#xA;        com.shipping_address_id,&#xA;        CASE &#xA;            WHEN sa.id IS NOT NULL   &#xA;            THEN jsonb_build_object(&#xA;                &#x27;AddressLine1&#x27;, sa.address_line1,&#xA;                &#x27;AddressLine2&#x27;, sa.address_line2,&#xA;                &#x27;ZipCode&#x27;, sa.zip_code,&#xA;                &#x27;CountryId&#x27;, sa.country_id,&#xA;                &#x27;CountryName&#x27;, sc.name,&#xA;                &#x27;StateId&#x27;, sa.state_id,&#xA;                &#x27;StateName&#x27;, ss.name,&#xA;                &#x27;CityId&#x27;, sa.city_id,&#xA;                &#x27;CityName&#x27;, sci.name&#xA;            ) &#xA;            ELSE NULL&#xA;        END AS shipping_address,&#xA;        COALESCE(&#xA;            (&#xA;                SELECT jsonb_agg(&#xA;                    jsonb_build_object(&#xA;                        &#x27;Id&#x27;, ba.id,&#xA;                        &#x27;BankId&#x27;, ba.bank_id,&#xA;                        &#x27;BankName&#x27;, b.name,&#xA;                        &#x27;BranchName&#x27;, ba.branch_name,&#xA;                        &#x27;AccountNumber&#x27;, ba.account_number,&#xA;                        &#x27;IFSC&#x27;, ba.ifsc&#xA;                    )&#xA;                )&#xA;                FROM company_bank_accounts AS cba&#xA;                JOIN bank_accounts AS ba ON ba.id = cba.bank_account_id&#xA;                JOIN banks AS b ON b.id = ba.bank_id&#xA;                WHERE cba.company_id = com.id  AND ba.is_deleted = false&#xA;            ),&#xA;            &#x27;[]&#x27;::jsonb&#xA;        ) AS bank_accounts,&#xA;        COALESCE(&#xA;            (&#xA;                SELECT jsonb_agg(&#xA;                    jsonb_build_object(&#xA;                        &#x27;Id&#x27;, c.id,&#xA;                        &#x27;Salutation&#x27;, c.salutation,&#xA;                        &#x27;FirstName&#x27;, c.first_name,&#xA;                        &#x27;LastName&#x27;, c.last_name,&#xA;                        &#x27;Email&#x27;, c.email,&#xA;                        &#x27;PhoneNumber&#x27;, c.phone_number,&#xA;                        &#x27;MobileNumber&#x27;, c.mobile_number,&#xA;                        &#x27;IsPrimary&#x27;, c.is_primary&#xA;                    )&#xA;                )&#xA;                FROM company_contacts AS cc&#xA;                JOIN contacts AS c ON c.id = cc.contact_id&#xA;                WHERE cc.company_id = com.id  AND c.is_deleted = false&#xA;            ),&#xA;            &#x27;[]&#x27;::jsonb&#xA;        ) AS contacts,&#xA;        com.description&#xA;    FROM companies AS com&#xA;    LEFT JOIN addresses AS ba ON ba.id = com.billing_address_id&#xA;    LEFT JOIN countries AS bc ON bc.id = ba.country_id&#xA;    LEFT JOIN states AS bs ON bs.id = ba.state_id&#xA;    LEFT JOIN cities AS bci ON bci.id = ba.city_id&#xA;    LEFT JOIN addresses AS sa ON sa.id = com.shipping_address_id&#xA;    LEFT JOIN countries AS sc ON sc.id = sa.country_id&#xA;    LEFT JOIN states AS ss ON ss.id = sa.state_id&#xA;    LEFT JOIN cities AS sci ON sci.id = sa.city_id&#xA;    WHERE com.id = p_company_id AND com.is_deleted = false;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_comparative_accounts_overview</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-13')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-13">
                                            CREATE OR REPLACE FUNCTION public.get_comparative_accounts_overview(p_company_id uuid, p_fin_year_id integer, p_chart_of_account_id uuid)&#xA; RETURNS TABLE(account_id uuid, parent_account_name text, parent_account_id uuid, financial_year integer, apr numeric, may numeric, jun numeric, jul numeric, aug numeric, sep numeric, oct numeric, nov numeric, &quot;dec&quot; numeric, jan numeric, feb numeric, mar numeric, total_sum numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE &#xA;    v_current_year INTEGER := p_fin_year_id;&#xA;    v_previous_year INTEGER := p_fin_year_id - 1;&#xA;    v_organization_id UUID;&#xA;    v_is_second_last_leaf BOOLEAN;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id &#xA;    INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;-- Search for 2nd last leaf account&#xA;&#x9;&#x9; SELECT NOT EXISTS (&#xA;&#x9;&#x9;    SELECT 1 FROM chart_of_accounts ca1&#xA;&#x9;&#x9;    WHERE ca1.parent_account_id = p_chart_of_account_id&#xA;&#x9;&#x9;    )&#xA;&#x9;&#x9; INTO v_is_second_last_leaf;&#xA;&#x9;&#x9; &#xA;&#xA;&#xA;    RAISE notice &#x27;it is leaf account %&#x27;, v_is_second_last_leaf;&#xA;&#xA;    -- If it is a LEAF account, fetch its transactions directly&#xA;    IF v_is_second_last_leaf THEN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE child_accounts AS (&#xA;        -- Get the given parent account and all its child accounts&#xA;        SELECT id, parent_account_id, name &#xA;        FROM chart_of_accounts &#xA;        WHERE parent_account_id = p_chart_of_account_id&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursively get all child accounts&#xA;        SELECT ca.id, ca.parent_account_id, ca.name &#xA;        FROM chart_of_accounts ca&#xA;        INNER JOIN child_accounts c ON ca.parent_account_id = c.id&#xA;    ),&#xA;    financial_years AS (&#xA;        -- Get previous and current financial years&#xA;        SELECT fy.id AS fin_year_id, fy.start_date, fy.end_date &#xA;        FROM finance_year fy &#xA;        WHERE fy.id IN (v_previous_year, v_current_year)&#xA;    )&#xA;    SELECT &#xA;        je.id AS transaction_id,&#xA;        je.account_id,&#xA;        ca.name AS account_name,&#xA;        ca.parent_account_id,&#xA;        fy.fin_year_id AS financial_year,&#xA;        je.transaction_date,&#xA;        EXTRACT(MONTH FROM je.transaction_date) AS calendar_month,&#xA;        &#xA;        -- Convert Calendar Month to Financial Month (April - March Cycle)&#xA;        CASE &#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 4 THEN &#x27;Apr&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 5 THEN &#x27;May&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 6 THEN &#x27;Jun&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 7 THEN &#x27;Jul&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 8 THEN &#x27;Aug&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 9 THEN &#x27;Sep&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 10 THEN &#x27;Oct&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 11 THEN &#x27;Nov&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 12 THEN &#x27;Dec&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 1 THEN &#x27;Jan&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 2 THEN &#x27;Feb&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 3 THEN &#x27;Mar&#x27;&#xA;        END AS financial_month,&#xA;&#xA;        je.amount,&#xA;        je.description&#xA;    FROM journal_entries je&#xA;    INNER JOIN child_accounts ca ON je.account_id = ca.id&#xA;    INNER JOIN financial_years fy ON je.transaction_date BETWEEN fy.start_date AND fy.end_date&#xA;    ORDER BY fy.fin_year_id, financial_month, ca.name, je.transaction_date;&#xA;&#xA;    ELSE&#xA;        -- If it is NOT a leaf account, use the ORIGINAL FUNCTIONALITY (recursive aggregation)&#xA;       RETURN QUERY&#xA;    WITH direct_children AS (&#xA;        -- Step 1: Get Direct Children of Given Parent&#xA;        SELECT ca.id AS account_id, ca.parent_account_id, ca.name&#xA;        FROM chart_of_accounts ca&#xA;        WHERE ca.parent_account_id = p_chart_of_account_id&#xA;&#x9;&#x9; AND ca.organization_id = v_organization_id&#xA;    ),&#xA;&#xA;    descendant_accounts AS (&#xA;        -- Step 2: Recursively Get All Descendants of Each Direct Child&#xA;        WITH RECURSIVE hierarchy AS (&#xA;            -- Start with direct children&#xA;            SELECT dc.account_id, dc.parent_account_id, dc.name&#xA;            FROM direct_children dc&#xA;&#xA;            UNION ALL&#xA;&#xA;            -- Then, recursively get all their descendants&#xA;            SELECT coa.id AS account_id, coa.parent_account_id, coa.name&#xA;            FROM chart_of_accounts coa&#xA;            INNER JOIN hierarchy h ON coa.parent_account_id = h.account_id&#xA;        )&#xA;        SELECT * FROM hierarchy&#xA;    ),&#xA;&#xA;    financial_years AS (&#xA;        -- Step 3: Get Start and End Dates for Given Financial Years&#xA;        SELECT id AS fin_year_id, start_date, end_date &#xA;        FROM finance_year &#xA;        WHERE id IN (v_previous_year, v_current_year)&#xA;    ),&#xA;&#xA;    aggregated_data AS (&#xA;        -- Step 4: Ensure Each Account Appears for Both Financial Years&#xA;        SELECT &#xA;            dc.account_id,            -- Include Account ID&#xA;            dc.name AS parent_account_name, &#xA;            dc.parent_account_id,      -- Ensure Parent Account ID is properly referenced&#xA;            fy.fin_year_id AS financial_year,&#xA;&#xA;            -- Monthly Values (April to March)&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 4 THEN je.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 5 THEN je.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 6 THEN je.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 7 THEN je.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 8 THEN je.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 9 THEN je.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 10 THEN je.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 11 THEN je.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 12 THEN je.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 1 THEN je.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 2 THEN je.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 3 THEN je.amount ELSE 0 END), 0) AS mar,&#xA;&#xA;            -- Total Sum of All Months&#xA;            COALESCE(SUM(je.amount), 0) AS total_sum&#xA;&#xA;        FROM direct_children dc&#xA;        CROSS JOIN financial_years fy  -- Ensures each account appears for both years&#xA;        LEFT JOIN descendant_accounts da ON da.parent_account_id = dc.account_id&#xA;        LEFT JOIN journal_entries je &#xA;            ON je.account_id = da.account_id&#xA;            AND je.transaction_date BETWEEN fy.start_date AND fy.end_date  -- Ensure correct year filtering&#xA;           -- AND je.company_id = p_company_id -- Filter by Company ID&#xA;&#xA;        GROUP BY dc.account_id, dc.parent_account_id, dc.name, fy.fin_year_id&#xA;    )&#xA;&#xA;    -- Step 5: Compute Difference Between Two Financial Years&#xA;    SELECT &#xA;        a1.account_id,&#xA;        a1.parent_account_name,&#xA;        a1.parent_account_id,&#xA;        a1.financial_year,&#xA;&#xA;        -- Monthly Values&#xA;        a1.apr, a1.may, a1.jun, a1.jul, a1.aug, a1.sep, a1.oct, a1.nov, a1.&quot;dec&quot;,&#xA;        a1.jan, a1.feb, a1.mar,&#xA;&#xA;        -- Total Sum for Financial Year&#xA;        a1.total_sum,&#xA;&#xA;        -- Difference (Current Year - Previous Year)&#xA;        (COALESCE(a1.total_sum, 0) - COALESCE(a2.total_sum, 0)) AS difference&#xA;&#xA;    FROM aggregated_data a1&#xA;    LEFT JOIN aggregated_data a2&#xA;        ON a1.account_id = a2.account_id&#xA;        AND a1.financial_year = v_current_year  -- Current Year&#xA;        AND a2.financial_year = v_previous_year  -- Previous Year&#xA;&#xA;    ORDER BY a1.parent_account_name, a1.financial_year;&#xA;    END IF;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_comparative_accounts_overview(p_company_id uuid, p_fin_year_id integer, p_chart_of_account_id uuid)&#xA; RETURNS TABLE(account_id uuid, parent_account_name text, parent_account_id uuid, financial_year integer, apr numeric, may numeric, jun numeric, jul numeric, aug numeric, sep numeric, oct numeric, nov numeric, &quot;dec&quot; numeric, jan numeric, feb numeric, mar numeric, total_sum numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE &#xA;    v_current_year INTEGER := p_fin_year_id;&#xA;    v_previous_year INTEGER := p_fin_year_id - 1;&#xA;    v_organization_id UUID;&#xA;    v_is_second_last_leaf BOOLEAN;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id &#xA;    INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;-- Search for 2nd last leaf account&#xA;&#x9;&#x9; SELECT NOT EXISTS (&#xA;&#x9;&#x9;    SELECT 1 FROM chart_of_accounts ca1&#xA;&#x9;&#x9;    WHERE ca1.parent_account_id = p_chart_of_account_id&#xA;&#x9;&#x9;    )&#xA;&#x9;&#x9; INTO v_is_second_last_leaf;&#xA;&#x9;&#x9; &#xA;&#xA;&#xA;    RAISE notice &#x27;it is leaf account %&#x27;, v_is_second_last_leaf;&#xA;&#xA;    -- If it is a LEAF account, fetch its transactions directly&#xA;    IF v_is_second_last_leaf THEN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE child_accounts AS (&#xA;        -- Get the given parent account and all its child accounts&#xA;        SELECT id, parent_account_id, name &#xA;        FROM chart_of_accounts &#xA;        WHERE parent_account_id = p_chart_of_account_id&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Recursively get all child accounts&#xA;        SELECT ca.id, ca.parent_account_id, ca.name &#xA;        FROM chart_of_accounts ca&#xA;        INNER JOIN child_accounts c ON ca.parent_account_id = c.id&#xA;    ),&#xA;    financial_years AS (&#xA;        -- Get previous and current financial years&#xA;        SELECT fy.id AS fin_year_id, fy.start_date, fy.end_date &#xA;        FROM finance_year fy &#xA;        WHERE fy.id IN (v_previous_year, v_current_year)&#xA;    )&#xA;    SELECT &#xA;        je.id AS transaction_id,&#xA;        je.account_id,&#xA;        ca.name AS account_name,&#xA;        ca.parent_account_id,&#xA;        fy.fin_year_id AS financial_year,&#xA;        je.transaction_date,&#xA;        EXTRACT(MONTH FROM je.transaction_date) AS calendar_month,&#xA;        &#xA;        -- Convert Calendar Month to Financial Month (April - March Cycle)&#xA;        CASE &#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 4 THEN &#x27;Apr&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 5 THEN &#x27;May&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 6 THEN &#x27;Jun&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 7 THEN &#x27;Jul&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 8 THEN &#x27;Aug&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 9 THEN &#x27;Sep&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 10 THEN &#x27;Oct&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 11 THEN &#x27;Nov&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 12 THEN &#x27;Dec&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 1 THEN &#x27;Jan&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 2 THEN &#x27;Feb&#x27;&#xA;            WHEN EXTRACT(MONTH FROM je.transaction_date) = 3 THEN &#x27;Mar&#x27;&#xA;        END AS financial_month,&#xA;&#xA;        je.amount,&#xA;        je.description&#xA;    FROM journal_entries je&#xA;    INNER JOIN child_accounts ca ON je.account_id = ca.id&#xA;    INNER JOIN financial_years fy ON je.transaction_date BETWEEN fy.start_date AND fy.end_date&#xA;    ORDER BY fy.fin_year_id, financial_month, ca.name, je.transaction_date;&#xA;&#xA;    ELSE&#xA;        -- If it is NOT a leaf account, use the ORIGINAL FUNCTIONALITY (recursive aggregation)&#xA;       RETURN QUERY&#xA;    WITH direct_children AS (&#xA;        -- Step 1: Get Direct Children of Given Parent&#xA;        SELECT ca.id AS account_id, ca.parent_account_id, ca.name&#xA;        FROM chart_of_accounts ca&#xA;        WHERE ca.parent_account_id = p_chart_of_account_id&#xA;&#x9;&#x9; AND ca.organization_id = v_organization_id&#xA;    ),&#xA;&#xA;    descendant_accounts AS (&#xA;        -- Step 2: Recursively Get All Descendants of Each Direct Child&#xA;        WITH RECURSIVE hierarchy AS (&#xA;            -- Start with direct children&#xA;            SELECT dc.account_id, dc.parent_account_id, dc.name&#xA;            FROM direct_children dc&#xA;&#xA;            UNION ALL&#xA;&#xA;            -- Then, recursively get all their descendants&#xA;            SELECT coa.id AS account_id, coa.parent_account_id, coa.name&#xA;            FROM chart_of_accounts coa&#xA;            INNER JOIN hierarchy h ON coa.parent_account_id = h.account_id&#xA;        )&#xA;        SELECT * FROM hierarchy&#xA;    ),&#xA;&#xA;    financial_years AS (&#xA;        -- Step 3: Get Start and End Dates for Given Financial Years&#xA;        SELECT id AS fin_year_id, start_date, end_date &#xA;        FROM finance_year &#xA;        WHERE id IN (v_previous_year, v_current_year)&#xA;    ),&#xA;&#xA;    aggregated_data AS (&#xA;        -- Step 4: Ensure Each Account Appears for Both Financial Years&#xA;        SELECT &#xA;            dc.account_id,            -- Include Account ID&#xA;            dc.name AS parent_account_name, &#xA;            dc.parent_account_id,      -- Ensure Parent Account ID is properly referenced&#xA;            fy.fin_year_id AS financial_year,&#xA;&#xA;            -- Monthly Values (April to March)&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 4 THEN je.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 5 THEN je.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 6 THEN je.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 7 THEN je.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 8 THEN je.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 9 THEN je.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 10 THEN je.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 11 THEN je.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 12 THEN je.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 1 THEN je.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 2 THEN je.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 3 THEN je.amount ELSE 0 END), 0) AS mar,&#xA;&#xA;            -- Total Sum of All Months&#xA;            COALESCE(SUM(je.amount), 0) AS total_sum&#xA;&#xA;        FROM direct_children dc&#xA;        CROSS JOIN financial_years fy  -- Ensures each account appears for both years&#xA;        LEFT JOIN descendant_accounts da ON da.parent_account_id = dc.account_id&#xA;        LEFT JOIN journal_entries je &#xA;            ON je.account_id = da.account_id&#xA;            AND je.transaction_date BETWEEN fy.start_date AND fy.end_date  -- Ensure correct year filtering&#xA;           -- AND je.company_id = p_company_id -- Filter by Company ID&#xA;&#xA;        GROUP BY dc.account_id, dc.parent_account_id, dc.name, fy.fin_year_id&#xA;    )&#xA;&#xA;    -- Step 5: Compute Difference Between Two Financial Years&#xA;    SELECT &#xA;        a1.account_id,&#xA;        a1.parent_account_name,&#xA;        a1.parent_account_id,&#xA;        a1.financial_year,&#xA;&#xA;        -- Monthly Values&#xA;        a1.apr, a1.may, a1.jun, a1.jul, a1.aug, a1.sep, a1.oct, a1.nov, a1.&quot;dec&quot;,&#xA;        a1.jan, a1.feb, a1.mar,&#xA;&#xA;        -- Total Sum for Financial Year&#xA;        a1.total_sum,&#xA;&#xA;        -- Difference (Current Year - Previous Year)&#xA;        (COALESCE(a1.total_sum, 0) - COALESCE(a2.total_sum, 0)) AS difference&#xA;&#xA;    FROM aggregated_data a1&#xA;    LEFT JOIN aggregated_data a2&#xA;        ON a1.account_id = a2.account_id&#xA;        AND a1.financial_year = v_current_year  -- Current Year&#xA;        AND a2.financial_year = v_previous_year  -- Previous Year&#xA;&#xA;    ORDER BY a1.parent_account_name, a1.financial_year;&#xA;    END IF;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>create_user</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-14')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-14">
                                            CREATE OR REPLACE FUNCTION public.create_user(p_user_id uuid, p_company_id uuid, p_email text, p_phone_number text, p_first_name text, p_last_name text, p_address_id uuid, p_created_by uuid)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_existing_user_id UUID; -- Variable to store the user ID&#xA;BEGIN&#xA;    -- Step 1: Check if the user already exists based on email&#xA;    SELECT id INTO v_existing_user_id&#xA;    FROM public.users&#xA;    WHERE email = p_email;&#xA;&#xA;    -- If user already exists, return the existing user_id&#xA;    IF v_existing_user_id IS NOT NULL THEN&#xA;        RETURN v_existing_user_id;&#xA;    END IF;&#xA;&#xA;    -- Step 2: Insert into users table&#xA;    INSERT INTO public.users (&#xA;        id,&#xA;&#x9;&#x9;company_id,&#xA;        email,&#xA;        phone_number,&#xA;        first_name,&#xA;        last_name,&#xA;        password_hash,&#xA;        address_id,&#xA;        created_on_utc,&#xA;        created_by&#xA;    ) VALUES (&#xA;        p_user_id,      -- Generate a new UUID for the user ID&#xA;&#x9;&#x9;p_company_id,&#xA;        p_email,                -- User email&#xA;        p_phone_number,         -- User phone number&#xA;        p_first_name,                 -- User first name&#xA;        p_last_name,                     -- Default empty last name&#xA;        &#x27;&#x27;,                     -- Default empty password hash&#xA;        p_address_id,           -- Provided Address ID&#xA;        NOW(),                  -- Current timestamp&#xA;        p_created_by           -- Created by&#xA;    );&#xA;&#xA;    -- Return the new user ID&#xA;    RETURN p_user_id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.create_user(p_user_id uuid, p_company_id uuid, p_email text, p_phone_number text, p_first_name text, p_last_name text, p_address_id uuid, p_created_by uuid)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_existing_user_id UUID; -- Variable to store the user ID&#xA;BEGIN&#xA;    -- Step 1: Check if the user already exists based on email&#xA;    SELECT id INTO v_existing_user_id&#xA;    FROM public.users&#xA;    WHERE email = p_email;&#xA;&#xA;    -- If user already exists, return the existing user_id&#xA;    IF v_existing_user_id IS NOT NULL THEN&#xA;        RETURN v_existing_user_id;&#xA;    END IF;&#xA;&#xA;    -- Step 2: Insert into users table&#xA;    INSERT INTO public.users (&#xA;        id,&#xA;&#x9;&#x9;company_id,&#xA;        email,&#xA;        phone_number,&#xA;        first_name,&#xA;        last_name,&#xA;        password_hash,&#xA;        address_id,&#xA;        created_on_utc,&#xA;        created_by&#xA;    ) VALUES (&#xA;        p_user_id,      -- Generate a new UUID for the user ID&#xA;&#x9;&#x9;p_company_id,&#xA;        p_email,                -- User email&#xA;        p_phone_number,         -- User phone number&#xA;        p_first_name,                 -- User first name&#xA;        p_last_name,                     -- Default empty last name&#xA;        &#x27;&#x27;,                     -- Default empty password hash&#xA;        p_address_id,           -- Provided Address ID&#xA;        NOW(),                  -- Current timestamp&#xA;        p_created_by           -- Created by&#xA;    );&#xA;&#xA;    -- Return the new user ID&#xA;    RETURN p_user_id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>fn_check_account_id_exists</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-15')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-15">
                                            CREATE OR REPLACE FUNCTION public.fn_check_account_id_exists(account_id uuid)&#xA; RETURNS boolean&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN EXISTS (&#xA;        SELECT 1 FROM public.vendors WHERE id = account_id&#xA;    ) OR EXISTS (&#xA;        SELECT 1 FROM public.customers WHERE id = account_id&#xA;    ) OR EXISTS (&#xA;        SELECT 1 FROM public.chart_of_accounts WHERE id = account_id&#xA;    );&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.fn_check_account_id_exists(account_id uuid)&#xA; RETURNS boolean&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN EXISTS (&#xA;        SELECT 1 FROM public.vendors WHERE id = account_id&#xA;    ) OR EXISTS (&#xA;        SELECT 1 FROM public.customers WHERE id = account_id&#xA;    ) OR EXISTS (&#xA;        SELECT 1 FROM public.chart_of_accounts WHERE id = account_id&#xA;    );&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_account_expense</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-16')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-16">
                                            CREATE OR REPLACE FUNCTION public.get_account_expense(p_company_id uuid, p_finance_id integer, p_period_type integer, p_period integer)&#xA; RETURNS TABLE(account_name text, account_number text, total_expense numeric, financial_year text)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_finance_year TEXT;&#xA;&#xA;    -- Period type constants&#xA;    CONST_MONTHLY CONSTANT INTEGER := 1;&#xA;    CONST_QUARTERLY CONSTANT INTEGER := 2;&#xA;    CONST_HALF_YEARLY CONSTANT INTEGER := 3;&#xA;    CONST_YEARLY CONSTANT INTEGER := 4;&#xA;    EXPENSE_CATEGORY_ID CONSTANT INTEGER := 5; -- Expense category ID&#xA;&#xA;BEGIN&#xA;    -- Fetch financial year details&#xA;    SELECT fy.start_date, fy.end_date, fy.year &#xA;    INTO v_financial_year_start, v_financial_year_end, v_finance_year&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Validate financial year&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Invalid financial year ID: %&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Handling different period types&#xA;    IF p_period_type = CONST_MONTHLY THEN&#xA;        -- Handle Monthly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND EXTRACT(MONTH FROM je.transaction_date) = (p_period &#x2B; 3) % 12 &#x2B; 1&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_QUARTERLY THEN&#xA;        -- Handle Quarterly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) IN (4, 5, 6)) OR&#xA;                (p_period = 2 AND EXTRACT(MONTH FROM je.transaction_date) IN (7, 8, 9)) OR&#xA;                (p_period = 3 AND EXTRACT(MONTH FROM je.transaction_date) IN (10, 11, 12)) OR&#xA;                (p_period = 4 AND EXTRACT(MONTH FROM je.transaction_date) IN (1, 2, 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_HALF_YEARLY THEN&#xA;        -- Handle Half-Yearly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) BETWEEN 4 AND 9) OR&#xA;                (p_period = 2 AND (EXTRACT(MONTH FROM je.transaction_date) BETWEEN 10 AND 12 OR EXTRACT(MONTH FROM je.transaction_date) BETWEEN 1 AND 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_YEARLY THEN&#xA;        -- Handle Yearly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSE&#xA;        RAISE EXCEPTION &#x27;Invalid period type: %&#x27;, p_period_type;&#xA;    END IF;&#xA;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_account_expense(p_company_id uuid, p_finance_id integer, p_period_type integer, p_period integer)&#xA; RETURNS TABLE(account_name text, account_number text, total_expense numeric, financial_year text)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_finance_year TEXT;&#xA;&#xA;    -- Period type constants&#xA;    CONST_MONTHLY CONSTANT INTEGER := 1;&#xA;    CONST_QUARTERLY CONSTANT INTEGER := 2;&#xA;    CONST_HALF_YEARLY CONSTANT INTEGER := 3;&#xA;    CONST_YEARLY CONSTANT INTEGER := 4;&#xA;    EXPENSE_CATEGORY_ID CONSTANT INTEGER := 5; -- Expense category ID&#xA;&#xA;BEGIN&#xA;    -- Fetch financial year details&#xA;    SELECT fy.start_date, fy.end_date, fy.year &#xA;    INTO v_financial_year_start, v_financial_year_end, v_finance_year&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Validate financial year&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Invalid financial year ID: %&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Handling different period types&#xA;    IF p_period_type = CONST_MONTHLY THEN&#xA;        -- Handle Monthly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND EXTRACT(MONTH FROM je.transaction_date) = (p_period &#x2B; 3) % 12 &#x2B; 1&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_QUARTERLY THEN&#xA;        -- Handle Quarterly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) IN (4, 5, 6)) OR&#xA;                (p_period = 2 AND EXTRACT(MONTH FROM je.transaction_date) IN (7, 8, 9)) OR&#xA;                (p_period = 3 AND EXTRACT(MONTH FROM je.transaction_date) IN (10, 11, 12)) OR&#xA;                (p_period = 4 AND EXTRACT(MONTH FROM je.transaction_date) IN (1, 2, 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_HALF_YEARLY THEN&#xA;        -- Handle Half-Yearly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) BETWEEN 4 AND 9) OR&#xA;                (p_period = 2 AND (EXTRACT(MONTH FROM je.transaction_date) BETWEEN 10 AND 12 OR EXTRACT(MONTH FROM je.transaction_date) BETWEEN 1 AND 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_YEARLY THEN&#xA;        -- Handle Yearly&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        JOIN &#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        JOIN &#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        JOIN &#xA;            public.account_categories ac ON act.account_category_id = ac.id&#xA;        WHERE &#xA;            th.company_id = p_company_id &#xA;            AND ac.id = EXPENSE_CATEGORY_ID&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  -- Exclude specific accounts&#xA;        GROUP BY &#xA;            coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY &#xA;            total_expense DESC;&#xA;&#xA;    ELSE&#xA;        RAISE EXCEPTION &#x27;Invalid period type: %&#x27;, p_period_type;&#xA;    END IF;&#xA;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_account_expense_breakdown</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-17')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-17">
                                            CREATE OR REPLACE FUNCTION public.get_account_expense_breakdown(p_company_id uuid, p_finance_id integer, p_period_type integer, p_period integer)&#xA; RETURNS TABLE(account_id uuid, account_name text, account_number text, total_expense numeric, financial_year text)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_finance_year TEXT;&#xA;&#xA;    -- Period type constants&#xA;    CONST_MONTHLY CONSTANT INTEGER := 1;&#xA;    CONST_QUARTERLY CONSTANT INTEGER := 2;&#xA;    CONST_HALF_YEARLY CONSTANT INTEGER := 3;&#xA;    CONST_YEARLY CONSTANT INTEGER := 4;&#xA;BEGIN&#xA;    -- Fetch financial year details&#xA;    SELECT fy.start_date, fy.end_date, fy.year &#xA;    INTO v_financial_year_start, v_financial_year_end, v_finance_year&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Validate financial year&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Invalid financial year ID: %&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Period-based filtering&#xA;    IF p_period_type = CONST_MONTHLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND EXTRACT(MONTH FROM je.transaction_date) = (p_period &#x2B; 3) % 12 &#x2B; 1&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_QUARTERLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) IN (4, 5, 6)) OR&#xA;                (p_period = 2 AND EXTRACT(MONTH FROM je.transaction_date) IN (7, 8, 9)) OR&#xA;                (p_period = 3 AND EXTRACT(MONTH FROM je.transaction_date) IN (10, 11, 12)) OR&#xA;                (p_period = 4 AND EXTRACT(MONTH FROM je.transaction_date) IN (1, 2, 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_HALF_YEARLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) BETWEEN 4 AND 9) OR&#xA;                (p_period = 2 AND (EXTRACT(MONTH FROM je.transaction_date) BETWEEN 10 AND 12 OR EXTRACT(MONTH FROM je.transaction_date) BETWEEN 1 AND 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_YEARLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSE&#xA;        RAISE EXCEPTION &#x27;Invalid period type: %&#x27;, p_period_type;&#xA;    END IF;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_account_expense_breakdown(p_company_id uuid, p_finance_id integer, p_period_type integer, p_period integer)&#xA; RETURNS TABLE(account_id uuid, account_name text, account_number text, total_expense numeric, financial_year text)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_finance_year TEXT;&#xA;&#xA;    -- Period type constants&#xA;    CONST_MONTHLY CONSTANT INTEGER := 1;&#xA;    CONST_QUARTERLY CONSTANT INTEGER := 2;&#xA;    CONST_HALF_YEARLY CONSTANT INTEGER := 3;&#xA;    CONST_YEARLY CONSTANT INTEGER := 4;&#xA;BEGIN&#xA;    -- Fetch financial year details&#xA;    SELECT fy.start_date, fy.end_date, fy.year &#xA;    INTO v_financial_year_start, v_financial_year_end, v_finance_year&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Validate financial year&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Invalid financial year ID: %&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Period-based filtering&#xA;    IF p_period_type = CONST_MONTHLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND EXTRACT(MONTH FROM je.transaction_date) = (p_period &#x2B; 3) % 12 &#x2B; 1&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_QUARTERLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) IN (4, 5, 6)) OR&#xA;                (p_period = 2 AND EXTRACT(MONTH FROM je.transaction_date) IN (7, 8, 9)) OR&#xA;                (p_period = 3 AND EXTRACT(MONTH FROM je.transaction_date) IN (10, 11, 12)) OR&#xA;                (p_period = 4 AND EXTRACT(MONTH FROM je.transaction_date) IN (1, 2, 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_HALF_YEARLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND (&#xA;                (p_period = 1 AND EXTRACT(MONTH FROM je.transaction_date) BETWEEN 4 AND 9) OR&#xA;                (p_period = 2 AND (EXTRACT(MONTH FROM je.transaction_date) BETWEEN 10 AND 12 OR EXTRACT(MONTH FROM je.transaction_date) BETWEEN 1 AND 3))&#xA;            )&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSIF p_period_type = CONST_YEARLY THEN&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name AS account_name,&#xA;            coa.account_number,&#xA;            ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense,&#xA;            v_finance_year AS financial_year&#xA;        FROM &#xA;            public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.is_deleted = FALSE&#xA;            AND coa.name NOT IN (&#x27;Rounding Gain&#x27;)  &#xA;        GROUP BY coa.id, coa.name, coa.account_number, v_finance_year&#xA;        ORDER BY total_expense DESC;&#xA;&#xA;    ELSE&#xA;        RAISE EXCEPTION &#x27;Invalid period type: %&#x27;, p_period_type;&#xA;    END IF;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_account_expense_monthly_breakdown</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-18')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-18">
                                            CREATE OR REPLACE FUNCTION public.get_account_expense_monthly_breakdown(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_name text, year integer, apr numeric, apr_diff numeric, may numeric, may_diff numeric, jun numeric, jun_diff numeric, jul numeric, jul_diff numeric, aug numeric, aug_diff numeric, sep numeric, sep_diff numeric, oct numeric, oct_diff numeric, nov numeric, nov_diff numeric, &quot;dec&quot; numeric, dec_diff numeric, jan numeric, jan_diff numeric, feb numeric, feb_diff numeric, mar numeric, mar_diff numeric, total numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT pfy.start_date, pfy.end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year pfy&#xA;    WHERE pfy.id = (p_finance_year_id - 1);  &#xA;&#xA;    RETURN QUERY &#xA;    WITH expense_accounts AS (&#xA;        -- Fetch all expense accounts&#xA;        SELECT DISTINCT coa.id AS account_id, coa.name&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types at ON coa.account_type_id = at.id&#xA;        WHERE at.id IN (SELECT id FROM get_account_type_hierarchy(5)) &#xA;          AND coa.organization_id = v_organization_id&#xA;    ),&#xA;    years AS (&#xA;        -- Ensure two years are always present&#xA;        SELECT p_finance_year_id AS year&#xA;        UNION ALL&#xA;        SELECT p_finance_year_id - 1&#xA;    ),&#xA;    all_accounts AS (&#xA;        -- Ensure all accounts have both years&#xA;        SELECT ea.account_id, ea.name, y.year&#xA;        FROM expense_accounts ea&#xA;        CROSS JOIN years y&#xA;    ),&#xA;    monthly_expenses AS (&#xA;        -- Get monthly totals for the selected and previous financial years&#xA;        SELECT &#xA;            je.account_id,&#xA;            CASE &#xA;                WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN p_finance_year_id&#xA;                WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN (p_finance_year_id - 1)&#xA;            END AS year,&#xA;            EXTRACT(MONTH FROM je.transaction_date) AS month,&#xA;            SUM(je.amount) AS amount&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  &#xA;        GROUP BY je.account_id, year, EXTRACT(MONTH FROM je.transaction_date)&#xA;    ),&#xA;    pivoted_expenses AS (&#xA;        -- Pivoting data to month-wise columns&#xA;        SELECT &#xA;            aa.name AS account_name,&#xA;            aa.year,&#xA;            COALESCE(SUM(CASE WHEN me.month = 4 THEN me.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN me.month = 5 THEN me.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN me.month = 6 THEN me.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN me.month = 7 THEN me.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN me.month = 8 THEN me.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN me.month = 9 THEN me.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN me.month = 10 THEN me.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN me.month = 11 THEN me.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN me.month = 12 THEN me.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN me.month = 1 THEN me.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN me.month = 2 THEN me.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN me.month = 3 THEN me.amount ELSE 0 END), 0) AS mar,&#xA;            COALESCE(SUM(me.amount), 0) AS total&#xA;        FROM all_accounts aa&#xA;        LEFT JOIN monthly_expenses me ON aa.account_id = me.account_id AND aa.year = me.year&#xA;        GROUP BY aa.account_id, aa.name, aa.year&#xA;    )&#xA;    -- Final table with the difference calculation&#xA;    SELECT &#xA;        pe.account_name,&#xA;        pe.year,&#xA;        pe.apr, COALESCE(pe.apr - LAG(pe.apr) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS apr_diff,&#xA;        pe.may, COALESCE(pe.may - LAG(pe.may) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS may_diff,&#xA;        pe.jun, COALESCE(pe.jun - LAG(pe.jun) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS jun_diff,&#xA;        pe.jul, COALESCE(pe.jul - LAG(pe.jul) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS jul_diff,&#xA;        pe.aug, COALESCE(pe.aug - LAG(pe.aug) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS aug_diff,&#xA;        pe.sep, COALESCE(pe.sep - LAG(pe.sep) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS sep_diff,&#xA;        pe.oct, COALESCE(pe.oct - LAG(pe.oct) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS oct_diff,&#xA;        pe.nov, COALESCE(pe.nov - LAG(pe.nov) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS nov_diff,&#xA;        pe.dec, COALESCE(pe.dec - LAG(pe.dec) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS dec_diff,&#xA;        pe.jan, COALESCE(pe.jan - LAG(pe.jan) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS jan_diff,&#xA;        pe.feb, COALESCE(pe.feb - LAG(pe.feb) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS feb_diff,&#xA;        pe.mar, COALESCE(pe.mar - LAG(pe.mar) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS mar_diff,&#xA;        pe.total,&#xA;        COALESCE(pe.total - LAG(pe.total) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS difference&#xA;    FROM pivoted_expenses pe&#xA;    ORDER BY pe.account_name, pe.year;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_account_expense_monthly_breakdown(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_name text, year integer, apr numeric, apr_diff numeric, may numeric, may_diff numeric, jun numeric, jun_diff numeric, jul numeric, jul_diff numeric, aug numeric, aug_diff numeric, sep numeric, sep_diff numeric, oct numeric, oct_diff numeric, nov numeric, nov_diff numeric, &quot;dec&quot; numeric, dec_diff numeric, jan numeric, jan_diff numeric, feb numeric, feb_diff numeric, mar numeric, mar_diff numeric, total numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT pfy.start_date, pfy.end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year pfy&#xA;    WHERE pfy.id = (p_finance_year_id - 1);  &#xA;&#xA;    RETURN QUERY &#xA;    WITH expense_accounts AS (&#xA;        -- Fetch all expense accounts&#xA;        SELECT DISTINCT coa.id AS account_id, coa.name&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types at ON coa.account_type_id = at.id&#xA;        WHERE at.id IN (SELECT id FROM get_account_type_hierarchy(5)) &#xA;          AND coa.organization_id = v_organization_id&#xA;    ),&#xA;    years AS (&#xA;        -- Ensure two years are always present&#xA;        SELECT p_finance_year_id AS year&#xA;        UNION ALL&#xA;        SELECT p_finance_year_id - 1&#xA;    ),&#xA;    all_accounts AS (&#xA;        -- Ensure all accounts have both years&#xA;        SELECT ea.account_id, ea.name, y.year&#xA;        FROM expense_accounts ea&#xA;        CROSS JOIN years y&#xA;    ),&#xA;    monthly_expenses AS (&#xA;        -- Get monthly totals for the selected and previous financial years&#xA;        SELECT &#xA;            je.account_id,&#xA;            CASE &#xA;                WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN p_finance_year_id&#xA;                WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN (p_finance_year_id - 1)&#xA;            END AS year,&#xA;            EXTRACT(MONTH FROM je.transaction_date) AS month,&#xA;            SUM(je.amount) AS amount&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  &#xA;        GROUP BY je.account_id, year, EXTRACT(MONTH FROM je.transaction_date)&#xA;    ),&#xA;    pivoted_expenses AS (&#xA;        -- Pivoting data to month-wise columns&#xA;        SELECT &#xA;            aa.name AS account_name,&#xA;            aa.year,&#xA;            COALESCE(SUM(CASE WHEN me.month = 4 THEN me.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN me.month = 5 THEN me.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN me.month = 6 THEN me.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN me.month = 7 THEN me.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN me.month = 8 THEN me.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN me.month = 9 THEN me.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN me.month = 10 THEN me.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN me.month = 11 THEN me.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN me.month = 12 THEN me.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN me.month = 1 THEN me.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN me.month = 2 THEN me.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN me.month = 3 THEN me.amount ELSE 0 END), 0) AS mar,&#xA;            COALESCE(SUM(me.amount), 0) AS total&#xA;        FROM all_accounts aa&#xA;        LEFT JOIN monthly_expenses me ON aa.account_id = me.account_id AND aa.year = me.year&#xA;        GROUP BY aa.account_id, aa.name, aa.year&#xA;    )&#xA;    -- Final table with the difference calculation&#xA;    SELECT &#xA;        pe.account_name,&#xA;        pe.year,&#xA;        pe.apr, COALESCE(pe.apr - LAG(pe.apr) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS apr_diff,&#xA;        pe.may, COALESCE(pe.may - LAG(pe.may) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS may_diff,&#xA;        pe.jun, COALESCE(pe.jun - LAG(pe.jun) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS jun_diff,&#xA;        pe.jul, COALESCE(pe.jul - LAG(pe.jul) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS jul_diff,&#xA;        pe.aug, COALESCE(pe.aug - LAG(pe.aug) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS aug_diff,&#xA;        pe.sep, COALESCE(pe.sep - LAG(pe.sep) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS sep_diff,&#xA;        pe.oct, COALESCE(pe.oct - LAG(pe.oct) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS oct_diff,&#xA;        pe.nov, COALESCE(pe.nov - LAG(pe.nov) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS nov_diff,&#xA;        pe.dec, COALESCE(pe.dec - LAG(pe.dec) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS dec_diff,&#xA;        pe.jan, COALESCE(pe.jan - LAG(pe.jan) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS jan_diff,&#xA;        pe.feb, COALESCE(pe.feb - LAG(pe.feb) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS feb_diff,&#xA;        pe.mar, COALESCE(pe.mar - LAG(pe.mar) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS mar_diff,&#xA;        pe.total,&#xA;        COALESCE(pe.total - LAG(pe.total) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS difference&#xA;    FROM pivoted_expenses pe&#xA;    ORDER BY pe.account_name, pe.year;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_address_id</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-19')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-19">
                                            CREATE OR REPLACE FUNCTION public.get_address_id(p_country_id uuid, p_state_id uuid, p_city_id uuid, p_address_line1 text, p_zip_code text, p_created_by uuid, p_address_line2 text DEFAULT NULL::text)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_address_id UUID;&#xA;BEGIN&#xA;    -- Insert into addresses table&#xA;    INSERT INTO public.addresses (&#xA;        id,&#xA;        country_id, &#xA;        state_id, &#xA;        city_id, &#xA;        address_line1, &#xA;&#x9;&#x9;address_line2,&#xA;        zip_code,&#xA;        created_on_utc,&#xA;        created_by&#xA;    ) VALUES (&#xA;        gen_random_uuid(),                          -- Generated address ID&#xA;        p_country_id,                          -- Fetched country ID&#xA;        p_state_id,                            -- Fetched state ID&#xA;        p_city_id,                           -- City ID&#xA;        p_address_line1,                      -- Address Line 1&#xA;        p_address_line2,&#xA;&#x9;&#x9;p_zip_code,                          -- Zip Code&#xA;        NOW(),                               -- Created on timestamp&#xA;        p_created_by                         -- Created by&#xA;    )RETURNING id INTO v_address_id;&#xA;&#xA;    RETURN v_address_id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_address_id(p_country_id uuid, p_state_id uuid, p_city_id uuid, p_address_line1 text, p_zip_code text, p_created_by uuid, p_address_line2 text DEFAULT NULL::text)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_address_id UUID;&#xA;BEGIN&#xA;    -- Insert into addresses table&#xA;    INSERT INTO public.addresses (&#xA;        id,&#xA;        country_id, &#xA;        state_id, &#xA;        city_id, &#xA;        address_line1, &#xA;&#x9;&#x9;address_line2,&#xA;        zip_code,&#xA;        created_on_utc,&#xA;        created_by&#xA;    ) VALUES (&#xA;        gen_random_uuid(),                          -- Generated address ID&#xA;        p_country_id,                          -- Fetched country ID&#xA;        p_state_id,                            -- Fetched state ID&#xA;        p_city_id,                           -- City ID&#xA;        p_address_line1,                      -- Address Line 1&#xA;        p_address_line2,&#xA;&#x9;&#x9;p_zip_code,                          -- Zip Code&#xA;        NOW(),                               -- Created on timestamp&#xA;        p_created_by                         -- Created by&#xA;    )RETURNING id INTO v_address_id;&#xA;&#xA;    RETURN v_address_id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_all_account_groups</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-20')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-20">
                                            CREATE OR REPLACE FUNCTION public.get_all_account_groups(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, organization_id uuid, code integer, group_code integer, top_group_code integer, parent_group_code integer, name text, level integer, order_sequence character varying, schedule text, is_main_group boolean)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;#variable_conflict use_column&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;begin&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;RETURN query&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;WITH RECURSIVE account_group_view AS (&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;organization_id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;name,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;0 AS level,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CAST(code AS varchar(50)) AS order_sequence,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;schedule,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is_main_group&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;WHERE &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;organization_id = p_organization_id AND&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent_group_code is null&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;UNION ALL&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.organization_id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.parent_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.name,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;level &#x2B; 1 AS level,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CAST(order_sequence || &#x27;_&#x27; || CAST(parent.code AS VARCHAR (50)) AS VARCHAR(50)) AS order_sequence,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.schedule,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.is_main_group&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups parent&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;JOIN &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_group_view ag &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON parent.parent_group_code = ag.code AND parent.organization_id = p_organization_id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;organization_id,&#xA;&#x9;&#x9;   &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;RIGHT(&#x27;            &#x27;,level*3) || name AS name,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;level,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;order_sequence,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;schedule,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is_main_group&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_group_view&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ORDER BY &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;order_sequence;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_all_account_groups(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, organization_id uuid, code integer, group_code integer, top_group_code integer, parent_group_code integer, name text, level integer, order_sequence character varying, schedule text, is_main_group boolean)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;#variable_conflict use_column&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;begin&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;RETURN query&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;WITH RECURSIVE account_group_view AS (&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;organization_id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;name,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;0 AS level,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CAST(code AS varchar(50)) AS order_sequence,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;schedule,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is_main_group&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;WHERE &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;organization_id = p_organization_id AND&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent_group_code is null&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;UNION ALL&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.organization_id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.parent_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.name,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;level &#x2B; 1 AS level,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CAST(order_sequence || &#x27;_&#x27; || CAST(parent.code AS VARCHAR (50)) AS VARCHAR(50)) AS order_sequence,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.schedule,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.is_main_group&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups parent&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;JOIN &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_group_view ag &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON parent.parent_group_code = ag.code AND parent.organization_id = p_organization_id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;id,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;organization_id,&#xA;&#x9;&#x9;   &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;RIGHT(&#x27;            &#x27;,level*3) || name AS name,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;level,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;order_sequence,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;schedule,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is_main_group&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_group_view&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ORDER BY &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;order_sequence;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_all_child_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-21')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-21">
                                            CREATE OR REPLACE FUNCTION public.get_all_child_accounts(p_organization_id uuid, p_group_id uuid)&#xA; RETURNS TABLE(id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    IF p_organization_id IS NULL OR p_group_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID and COA ID cannot be null&#x27;;&#xA;    END IF;&#xA;&#xA;    RETURN QUERY&#xA;        WITH RECURSIVE account_group_view AS (&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.parent_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups ag&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LEFT OUTER JOIN public.account_groups tgc&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON tgc.code = ag.top_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;WHERE &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9; ag.organization_id = p_organization_id AND&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;     ag.id = p_group_id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;UNION ALL&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;    parent.parent_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups parent&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LEFT OUTER JOIN public.account_groups tgc&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON tgc.code = parent.top_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;JOIN &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_group_view ag &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON parent.parent_group_code = ag.code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;    AND parent.organization_id = p_organization_id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;coa.id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.chart_of_accounts coa&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INNER JOIN account_group_view agv  on coa.account_group_code = agv.code;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_all_child_accounts(p_organization_id uuid, p_group_id uuid)&#xA; RETURNS TABLE(id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    IF p_organization_id IS NULL OR p_group_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID and COA ID cannot be null&#x27;;&#xA;    END IF;&#xA;&#xA;    RETURN QUERY&#xA;        WITH RECURSIVE account_group_view AS (&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ag.parent_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups ag&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LEFT OUTER JOIN public.account_groups tgc&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON tgc.code = ag.top_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;WHERE &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9; ag.organization_id = p_organization_id AND&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;     ag.id = p_group_id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;UNION ALL&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;parent.top_group_code,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;    parent.parent_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.account_groups parent&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LEFT OUTER JOIN public.account_groups tgc&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON tgc.code = parent.top_group_code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;JOIN &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_group_view ag &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON parent.parent_group_code = ag.code&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;    AND parent.organization_id = p_organization_id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;coa.id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FROM &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;public.chart_of_accounts coa&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INNER JOIN account_group_view agv  on coa.account_group_code = agv.code;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_all_coa</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-22')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-22">
                                            CREATE OR REPLACE FUNCTION public.get_all_coa(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, account_type text, account_number integer, name text, opening_balance numeric, level integer, order_sequence character varying, is_default_account boolean, schedule text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN query&#xA;    WITH RECURSIVE coa_view AS (   &#xA;        SELECT&#xA;            coa.id,&#xA;&#x9;&#x9;&#x9;act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::text AS order_sequence,&#xA;            coa.is_default_account, -- Include is_default_account,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE&#xA;            coa.organization_id = p_organization_id  &#xA;            AND (coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27; or coa.parent_account_id is null)&#xA;&#x9;        AND coa.is_deleted = FALSE&#xA;        UNION ALL&#xA;        SELECT &#xA;&#x9;&#x9;&#x9;coa.id,&#xA;&#x9;&#x9;&#x9;act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            view.level &#x2B; 1 AS level,&#xA;            view.order_sequence || &#x27;.&#x27; || coa.account_number::text AS order_sequence,&#xA;&#x9;&#x9; &#x9;coa.is_default_account, -- Include is_default_account,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN &#xA;            coa_view view ON view.id = coa.parent_account_id&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;&#x9;    WHERE&#xA;&#x9;&#x9;&#x9;coa.organization_id = p_organization_id  &#xA;&#x9;        AND coa.is_deleted = FALSE&#xA;        )&#xA;        SELECT &#xA;            view.id,&#xA;&#x9;&#x9;&#x9;view.account_type,&#xA;            view.account_number,&#xA;            LPAD(&#x27;&#x27;, view.level * 4, &#x27; &#x27;) || view.name AS name,&#xA;            0::numeric AS opening_balance,&#xA;            view.level,&#xA;            view.order_sequence::character varying AS order_sequence,&#xA;&#x9;&#x9;&#x9;view.is_default_account, -- Include is_default_account in final output&#xA;            view.schedule&#xA;        FROM &#xA;            coa_view view&#xA;        ORDER BY &#xA;            view.order_sequence;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_all_coa(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, account_type text, account_number integer, name text, opening_balance numeric, level integer, order_sequence character varying, is_default_account boolean, schedule text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN query&#xA;    WITH RECURSIVE coa_view AS (   &#xA;        SELECT&#xA;            coa.id,&#xA;&#x9;&#x9;&#x9;act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::text AS order_sequence,&#xA;            coa.is_default_account, -- Include is_default_account,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE&#xA;            coa.organization_id = p_organization_id  &#xA;            AND (coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27; or coa.parent_account_id is null)&#xA;&#x9;        AND coa.is_deleted = FALSE&#xA;        UNION ALL&#xA;        SELECT &#xA;&#x9;&#x9;&#x9;coa.id,&#xA;&#x9;&#x9;&#x9;act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            view.level &#x2B; 1 AS level,&#xA;            view.order_sequence || &#x27;.&#x27; || coa.account_number::text AS order_sequence,&#xA;&#x9;&#x9; &#x9;coa.is_default_account, -- Include is_default_account,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN &#xA;            coa_view view ON view.id = coa.parent_account_id&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;&#x9;    WHERE&#xA;&#x9;&#x9;&#x9;coa.organization_id = p_organization_id  &#xA;&#x9;        AND coa.is_deleted = FALSE&#xA;        )&#xA;        SELECT &#xA;            view.id,&#xA;&#x9;&#x9;&#x9;view.account_type,&#xA;            view.account_number,&#xA;            LPAD(&#x27;&#x27;, view.level * 4, &#x27; &#x27;) || view.name AS name,&#xA;            0::numeric AS opening_balance,&#xA;            view.level,&#xA;            view.order_sequence::character varying AS order_sequence,&#xA;&#x9;&#x9;&#x9;view.is_default_account, -- Include is_default_account in final output&#xA;            view.schedule&#xA;        FROM &#xA;            coa_view view&#xA;        ORDER BY &#xA;            view.order_sequence;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_all_coa_by_account_type_id</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-23')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-23">
                                            CREATE OR REPLACE FUNCTION public.get_all_coa_by_account_type_id(p_organization_id uuid, p_account_type_id integer)&#xA; RETURNS TABLE(id uuid, account_type text, account_number integer, name text, opening_balance numeric, level integer, order_sequence character varying, schedule text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN query&#xA;    WITH RECURSIVE coa_view AS (&#xA;        SELECT&#xA;            coa.id,&#xA;            act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::text AS order_sequence,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE &#xA;            coa.parent_account_id IS NULL&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND coa.account_type_id = p_account_type_id&#xA;        UNION ALL&#xA;        SELECT &#xA;            coa.id,&#xA;            act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            view.level &#x2B; 1 AS level,&#xA;            view.order_sequence || &#x27;.&#x27; || coa.account_number::text AS order_sequence,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN &#xA;            coa_view view ON view.id = coa.parent_account_id&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE &#xA;            coa.organization_id = p_organization_id&#xA;            AND coa.account_type_id = p_account_type_id&#xA;    )&#xA;    SELECT &#xA;        view.id,&#xA;        view.account_type,&#xA;        view.account_number,&#xA;        LPAD(&#x27;&#x27;, view.level * 4, &#x27; &#x27;) || view.name AS name,&#xA;        0::numeric AS opening_balance,&#xA;        view.level,&#xA;        view.order_sequence::character varying AS order_sequence,&#xA;        view.schedule&#xA;    FROM &#xA;        coa_view view&#xA;    ORDER BY &#xA;        view.order_sequence;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_all_coa_by_account_type_id(p_organization_id uuid, p_account_type_id integer)&#xA; RETURNS TABLE(id uuid, account_type text, account_number integer, name text, opening_balance numeric, level integer, order_sequence character varying, schedule text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN query&#xA;    WITH RECURSIVE coa_view AS (&#xA;        SELECT&#xA;            coa.id,&#xA;            act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::text AS order_sequence,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE &#xA;            coa.parent_account_id IS NULL&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND coa.account_type_id = p_account_type_id&#xA;        UNION ALL&#xA;        SELECT &#xA;            coa.id,&#xA;            act.name as account_type,&#xA;            coa.account_number::integer,&#xA;            coa.name,&#xA;            coa.parent_account_id,&#xA;            view.level &#x2B; 1 AS level,&#xA;            view.order_sequence || &#x27;.&#x27; || coa.account_number::text AS order_sequence,&#xA;            NULL::text AS schedule&#xA;        FROM &#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN &#xA;            coa_view view ON view.id = coa.parent_account_id&#xA;        INNER JOIN&#xA;            public.account_types act ON coa.account_type_id = act.id&#xA;        WHERE &#xA;            coa.organization_id = p_organization_id&#xA;            AND coa.account_type_id = p_account_type_id&#xA;    )&#xA;    SELECT &#xA;        view.id,&#xA;        view.account_type,&#xA;        view.account_number,&#xA;        LPAD(&#x27;&#x27;, view.level * 4, &#x27; &#x27;) || view.name AS name,&#xA;        0::numeric AS opening_balance,&#xA;        view.level,&#xA;        view.order_sequence::character varying AS order_sequence,&#xA;        view.schedule&#xA;    FROM &#xA;        coa_view view&#xA;    ORDER BY &#xA;        view.order_sequence;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_balance_sheet</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-24')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-24">
                                            CREATE OR REPLACE FUNCTION public.get_balance_sheet(p_company_id uuid, p_finance_year_id integer, p_is_get_all_for_organizations boolean)&#xA; RETURNS TABLE(account_type text, account_name text, amount numeric, category text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_company_ids UUID[];&#xA;&#x9;v_organization_id UUID;&#xA;    asset_account_ids integer[];&#xA;    liability_account_ids integer[];&#xA;    equity_account_ids integer[];&#xA;BEGIN&#xA;    -- Fetch financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;&#x9;select c.organization_id into v_organization_id&#xA;&#x9;from public.companies c&#xA;&#x9;where c.id = p_company_id;&#xA;&#xA;    -- Get account type hierarchies for assets, liabilities, and equity&#xA;    asset_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(1)); -- Assets&#xA;    liability_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(2)); -- Liabilities&#xA;    equity_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(3)); -- Equity&#xA;&#xA;    -- Determine company IDs to fetch data for (single or all organizations)&#xA;    IF p_is_get_all_for_organizations THEN&#xA;        SELECT ARRAY_AGG(id)&#xA;        INTO v_company_ids&#xA;        FROM public.companies&#xA;        WHERE organization_id = (SELECT organization_id FROM public.companies WHERE id = p_company_id);&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    -- Return Assets&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;            SUM(&#xA;                CASE &#xA;                    WHEN ob.entry_type = &#x27;D&#x27; THEN ob.balance&#xA;                    ELSE -ob.balance                        &#xA;                END&#xA;            ), 0) &#x2B;&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount  -- Debit increases asset balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN -je.amount -- Credit decreases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS amount,&#xA;        &#x27;Assets&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    LEFT JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    LEFT JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;&#x9;LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;        AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_finance_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(asset_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;    -- Return Liabilities&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;            SUM(&#xA;                CASE &#xA;                    WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance  &#xA;                    ELSE -ob.balance                        &#xA;                END&#xA;            ), 0) &#x2B;&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN -je.amount&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS amount,&#xA;        &#x27;Liabilities&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    LEFT JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    LEFT JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;&#x9;LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;        AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_finance_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(liability_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;    -- Return Equity&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;            SUM(&#xA;                CASE &#xA;                    WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance&#xA;                    ELSE -ob.balance                        &#xA;                END&#xA;            ), 0) &#x2B;&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount&#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN -je.amount&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS amount,&#xA;        &#x27;Equity&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    LEFT JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    LEFT JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;        AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_finance_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(equity_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_balance_sheet(p_company_id uuid, p_finance_year_id integer, p_is_get_all_for_organizations boolean)&#xA; RETURNS TABLE(account_type text, account_name text, amount numeric, category text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_company_ids UUID[];&#xA;&#x9;v_organization_id UUID;&#xA;    asset_account_ids integer[];&#xA;    liability_account_ids integer[];&#xA;    equity_account_ids integer[];&#xA;BEGIN&#xA;    -- Fetch financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;&#x9;select c.organization_id into v_organization_id&#xA;&#x9;from public.companies c&#xA;&#x9;where c.id = p_company_id;&#xA;&#xA;    -- Get account type hierarchies for assets, liabilities, and equity&#xA;    asset_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(1)); -- Assets&#xA;    liability_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(2)); -- Liabilities&#xA;    equity_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(3)); -- Equity&#xA;&#xA;    -- Determine company IDs to fetch data for (single or all organizations)&#xA;    IF p_is_get_all_for_organizations THEN&#xA;        SELECT ARRAY_AGG(id)&#xA;        INTO v_company_ids&#xA;        FROM public.companies&#xA;        WHERE organization_id = (SELECT organization_id FROM public.companies WHERE id = p_company_id);&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    -- Return Assets&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;            SUM(&#xA;                CASE &#xA;                    WHEN ob.entry_type = &#x27;D&#x27; THEN ob.balance&#xA;                    ELSE -ob.balance                        &#xA;                END&#xA;            ), 0) &#x2B;&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount  -- Debit increases asset balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN -je.amount -- Credit decreases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS amount,&#xA;        &#x27;Assets&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    LEFT JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    LEFT JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;&#x9;LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;        AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_finance_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(asset_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;    -- Return Liabilities&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;            SUM(&#xA;                CASE &#xA;                    WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance  &#xA;                    ELSE -ob.balance                        &#xA;                END&#xA;            ), 0) &#x2B;&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN -je.amount&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS amount,&#xA;        &#x27;Liabilities&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    LEFT JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    LEFT JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;&#x9;LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;        AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_finance_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(liability_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;    -- Return Equity&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;            SUM(&#xA;                CASE &#xA;                    WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance&#xA;                    ELSE -ob.balance                        &#xA;                END&#xA;            ), 0) &#x2B;&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount&#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN -je.amount&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS amount,&#xA;        &#x27;Equity&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    LEFT JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    LEFT JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;        AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_finance_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(equity_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_cash_flow_statement</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-25')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-25">
                                            CREATE OR REPLACE FUNCTION public.get_cash_flow_statement(p_company_id uuid, p_finance_year_id integer, p_is_get_for_organization boolean)&#xA; RETURNS TABLE(account_category text, account_type_id integer, account_type text, account_name text, net_cash_flow numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_company_ids UUID[];&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Fetch the Organization ID for the given Company ID&#xA;    SELECT organization_id INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;    &#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Fetch the start and end dates of the financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;    &#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Determine the company IDs to include (for all companies in the same organization or a single company)&#xA;    IF p_is_get_for_organization THEN&#xA;        SELECT ARRAY_AGG(id) INTO v_company_ids&#xA;        FROM public.companies&#xA;        WHERE organization_id = v_organization_id;&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    -- Combining Operating, Investing, and Financing Activities into a single result&#xA;    RETURN QUERY&#xA;    WITH cash_flow_activities AS (&#xA;        -- Operating Activities: Assets, Liabilities, Revenue, and Expenses&#xA;        SELECT&#xA;           &#x27;Operating&#x27; AS account_category,&#xA;&#x9;&#x9;    at.id as account_type_id,&#xA;&#x9;&#x9;&#x9;at.name as account_type,&#xA;            coa.name AS account_name,&#xA;            SUM(CASE &#xA;                -- Assets&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (6, 8, 9) THEN je.amount   -- Debit for Assets increases balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (6, 8, 9) THEN -je.amount  -- Credit for Assets decreases balance&#xA;                &#xA;                -- Liabilities&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id = 10 THEN je.amount  -- Credit for Liabilities increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id = 10 THEN -je.amount -- Debit for Liabilities decreases balance&#xA;                &#xA;                -- Revenue&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (14, 15, 19, 20) THEN je.amount   -- Credit for Revenue increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (14, 15, 19, 20) THEN -je.amount  -- Debit for Revenue decreases balance&#xA;                &#xA;                -- Expenses&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (16, 17, 18, 21, 22) THEN je.amount  -- Debit for Expenses increases balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (16, 17, 18, 21, 22) THEN -je.amount  -- Credit for Expenses decreases balance&#xA;                ELSE 0&#xA;            END) AS net_cash_flow&#xA;        FROM&#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;        INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;        INNER JOIN public.transaction_headers th ON th.id = je.transaction_id&#xA;        WHERE&#xA;            th.company_id = ANY(v_company_ids)&#xA;            AND th.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND NOT th.is_deleted&#xA;            AND NOT je.is_deleted&#xA;            AND coa.account_type_id IN (6, 8, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22)&#xA;        GROUP BY&#xA;            at.id, at.name, coa.name&#xA;&#xA;        UNION ALL&#xA;        &#xA;        -- Investing Activities: Non-Current Assets&#xA;        SELECT&#xA;            &#x27;Investing&#x27; AS account_category,&#xA;&#x9;&#x9;&#x9;at.id as account_type_id,&#xA;&#x9;&#x9;    at.name as account_type,&#xA;            coa.name AS account_name,&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id = 7 THEN je.amount   -- Debit for Non-Current Assets increases balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id = 7 THEN -je.amount  -- Credit for Non-Current Assets decreases balance&#xA;                ELSE 0&#xA;            END) AS net_cash_flow&#xA;        FROM&#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;        INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;        INNER JOIN public.transaction_headers th ON th.id = je.transaction_id&#xA;        WHERE&#xA;            th.company_id = ANY(v_company_ids)&#xA;            AND th.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND NOT th.is_deleted&#xA;            AND NOT je.is_deleted&#xA;            AND coa.account_type_id = 7&#xA;        GROUP BY&#xA;            at.id, at.name, coa.name&#xA;&#xA;        UNION ALL&#xA;        &#xA;        -- Financing Activities: Equity and Long-Term Liabilities&#xA;        SELECT&#xA;            &#x27;Financing&#x27; AS account_category,&#xA;      &#x9;&#x9;at.id as account_type_id,&#xA;&#x9;&#x9;    at.name as account_type,&#xA;            coa.name AS account_name,&#xA;            SUM(CASE &#xA;                -- Liabilities&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id = 11 THEN je.amount  -- Credit for Liabilities increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id = 11 THEN -je.amount -- Debit for Liabilities decreases balance&#xA;                &#xA;                -- Equity&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (12, 13) THEN je.amount  -- Credit for Equity increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (12, 13) THEN -je.amount -- Debit for Equity decreases balance&#xA;                ELSE 0&#xA;            END) AS net_cash_flow&#xA;        FROM&#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;        INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;        INNER JOIN public.transaction_headers th ON th.id = je.transaction_id&#xA;        WHERE&#xA;            th.company_id = ANY(v_company_ids)&#xA;            AND th.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND NOT th.is_deleted&#xA;            AND NOT je.is_deleted&#xA;            AND coa.account_type_id IN (11, 12, 13)&#xA;        GROUP BY&#xA;            at.id, at.name, coa.name&#xA;    )&#xA;    SELECT &#xA;&#x9;&#x9;cfa.account_category,&#xA;&#x9;&#x9;cfa.account_type_id,&#xA;        cfa.account_type,&#xA;        cfa.account_name,&#xA;        cfa.net_cash_flow &#xA;    FROM cash_flow_activities cfa&#xA;    WHERE cfa.net_cash_flow != 0  -- Exclude records with zero net cash flow&#xA;    ORDER BY cfa.account_category, cfa.account_type_id, cfa.account_type, cfa.account_name;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_cash_flow_statement(p_company_id uuid, p_finance_year_id integer, p_is_get_for_organization boolean)&#xA; RETURNS TABLE(account_category text, account_type_id integer, account_type text, account_name text, net_cash_flow numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_company_ids UUID[];&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Fetch the Organization ID for the given Company ID&#xA;    SELECT organization_id INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;    &#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Fetch the start and end dates of the financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;    &#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Determine the company IDs to include (for all companies in the same organization or a single company)&#xA;    IF p_is_get_for_organization THEN&#xA;        SELECT ARRAY_AGG(id) INTO v_company_ids&#xA;        FROM public.companies&#xA;        WHERE organization_id = v_organization_id;&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    -- Combining Operating, Investing, and Financing Activities into a single result&#xA;    RETURN QUERY&#xA;    WITH cash_flow_activities AS (&#xA;        -- Operating Activities: Assets, Liabilities, Revenue, and Expenses&#xA;        SELECT&#xA;           &#x27;Operating&#x27; AS account_category,&#xA;&#x9;&#x9;    at.id as account_type_id,&#xA;&#x9;&#x9;&#x9;at.name as account_type,&#xA;            coa.name AS account_name,&#xA;            SUM(CASE &#xA;                -- Assets&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (6, 8, 9) THEN je.amount   -- Debit for Assets increases balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (6, 8, 9) THEN -je.amount  -- Credit for Assets decreases balance&#xA;                &#xA;                -- Liabilities&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id = 10 THEN je.amount  -- Credit for Liabilities increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id = 10 THEN -je.amount -- Debit for Liabilities decreases balance&#xA;                &#xA;                -- Revenue&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (14, 15, 19, 20) THEN je.amount   -- Credit for Revenue increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (14, 15, 19, 20) THEN -je.amount  -- Debit for Revenue decreases balance&#xA;                &#xA;                -- Expenses&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (16, 17, 18, 21, 22) THEN je.amount  -- Debit for Expenses increases balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (16, 17, 18, 21, 22) THEN -je.amount  -- Credit for Expenses decreases balance&#xA;                ELSE 0&#xA;            END) AS net_cash_flow&#xA;        FROM&#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;        INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;        INNER JOIN public.transaction_headers th ON th.id = je.transaction_id&#xA;        WHERE&#xA;            th.company_id = ANY(v_company_ids)&#xA;            AND th.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND NOT th.is_deleted&#xA;            AND NOT je.is_deleted&#xA;            AND coa.account_type_id IN (6, 8, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22)&#xA;        GROUP BY&#xA;            at.id, at.name, coa.name&#xA;&#xA;        UNION ALL&#xA;        &#xA;        -- Investing Activities: Non-Current Assets&#xA;        SELECT&#xA;            &#x27;Investing&#x27; AS account_category,&#xA;&#x9;&#x9;&#x9;at.id as account_type_id,&#xA;&#x9;&#x9;    at.name as account_type,&#xA;            coa.name AS account_name,&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id = 7 THEN je.amount   -- Debit for Non-Current Assets increases balance&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id = 7 THEN -je.amount  -- Credit for Non-Current Assets decreases balance&#xA;                ELSE 0&#xA;            END) AS net_cash_flow&#xA;        FROM&#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;        INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;        INNER JOIN public.transaction_headers th ON th.id = je.transaction_id&#xA;        WHERE&#xA;            th.company_id = ANY(v_company_ids)&#xA;            AND th.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND NOT th.is_deleted&#xA;            AND NOT je.is_deleted&#xA;            AND coa.account_type_id = 7&#xA;        GROUP BY&#xA;            at.id, at.name, coa.name&#xA;&#xA;        UNION ALL&#xA;        &#xA;        -- Financing Activities: Equity and Long-Term Liabilities&#xA;        SELECT&#xA;            &#x27;Financing&#x27; AS account_category,&#xA;      &#x9;&#x9;at.id as account_type_id,&#xA;&#x9;&#x9;    at.name as account_type,&#xA;            coa.name AS account_name,&#xA;            SUM(CASE &#xA;                -- Liabilities&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id = 11 THEN je.amount  -- Credit for Liabilities increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id = 11 THEN -je.amount -- Debit for Liabilities decreases balance&#xA;                &#xA;                -- Equity&#xA;                WHEN je.entry_type = &#x27;C&#x27; AND coa.account_type_id IN (12, 13) THEN je.amount  -- Credit for Equity increases balance&#xA;                WHEN je.entry_type = &#x27;D&#x27; AND coa.account_type_id IN (12, 13) THEN -je.amount -- Debit for Equity decreases balance&#xA;                ELSE 0&#xA;            END) AS net_cash_flow&#xA;        FROM&#xA;            public.chart_of_accounts coa&#xA;        INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;        INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;        INNER JOIN public.transaction_headers th ON th.id = je.transaction_id&#xA;        WHERE&#xA;            th.company_id = ANY(v_company_ids)&#xA;            AND th.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND NOT th.is_deleted&#xA;            AND NOT je.is_deleted&#xA;            AND coa.account_type_id IN (11, 12, 13)&#xA;        GROUP BY&#xA;            at.id, at.name, coa.name&#xA;    )&#xA;    SELECT &#xA;&#x9;&#x9;cfa.account_category,&#xA;&#x9;&#x9;cfa.account_type_id,&#xA;        cfa.account_type,&#xA;        cfa.account_name,&#xA;        cfa.net_cash_flow &#xA;    FROM cash_flow_activities cfa&#xA;    WHERE cfa.net_cash_flow != 0  -- Exclude records with zero net cash flow&#xA;    ORDER BY cfa.account_category, cfa.account_type_id, cfa.account_type, cfa.account_name;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_chart_of_accounts_hierarchy</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-26')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-26">
                                            CREATE OR REPLACE FUNCTION public.get_chart_of_accounts_hierarchy(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, account_type text, account_number text, account_name text, parent_account_id uuid, is_default_account boolean, level integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE coa_hierarchy AS (&#xA;&#x9;    SELECT &#xA;&#x9;        coa.id,&#xA;&#x9;        act.name AS account_type,&#xA;&#x9;        coa.account_number,&#xA;&#x9;        coa.name as account_name,&#xA;&#x9;        coa.parent_account_id,&#xA;&#x9;        coa.is_default_account,&#xA;&#x9;        0 AS level&#xA;&#x9;    FROM&#xA;&#x9;        public.chart_of_accounts coa &#xA;&#x9;    INNER JOIN&#xA;&#x9;        public.account_types act ON coa.account_type_id = act.id&#xA;&#x9;    WHERE &#xA;&#x9;        coa.is_deleted = false&#xA;&#x9;        AND coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;&#xA;&#x9;        AND coa.organization_id = p_organization_id&#xA;        &#xA;&#x9;    UNION ALL&#xA;&#x9;&#xA;&#x9;    SELECT &#xA;&#x9;        coa.id,&#xA;&#x9;        act.name AS account_type,&#xA;&#x9;        coa.account_number,&#xA;&#x9;        coa.name as account_name,&#xA;&#x9;        coa.parent_account_id,&#xA;&#x9;        coa.is_default_account,&#xA;&#x9;        ch.level &#x2B; 1 AS level&#xA;&#x9;    FROM &#xA;&#x9;        public.chart_of_accounts coa&#xA;&#x9;    INNER JOIN&#xA;&#x9;        public.account_types act ON coa.account_type_id = act.id&#xA;&#x9;    INNER JOIN &#xA;&#x9;        coa_hierarchy ch ON ch.id = coa.parent_account_id&#xA;&#x9;    WHERE&#xA;&#x9;        coa.is_deleted = FALSE&#xA;)&#xA;&#x9;SELECT &#xA;&#x9;    ch.id,&#xA;&#x9;    ch.account_type,&#xA;&#x9;    ch.account_number,&#xA;&#x9;    LPAD(ch.account_name, LENGTH(ch.account_name) &#x2B; ch.level * 4, &#x27; &#x27;) AS account_name,&#xA;&#x9;    ch.parent_account_id,&#xA;&#x9;    ch.is_default_account,&#xA;&#x9;    ch.level&#xA;&#x9;FROM coa_hierarchy ch&#xA;&#x9;ORDER BY ch.account_number;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_chart_of_accounts_hierarchy(p_organization_id uuid)&#xA; RETURNS TABLE(id uuid, account_type text, account_number text, account_name text, parent_account_id uuid, is_default_account boolean, level integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE coa_hierarchy AS (&#xA;&#x9;    SELECT &#xA;&#x9;        coa.id,&#xA;&#x9;        act.name AS account_type,&#xA;&#x9;        coa.account_number,&#xA;&#x9;        coa.name as account_name,&#xA;&#x9;        coa.parent_account_id,&#xA;&#x9;        coa.is_default_account,&#xA;&#x9;        0 AS level&#xA;&#x9;    FROM&#xA;&#x9;        public.chart_of_accounts coa &#xA;&#x9;    INNER JOIN&#xA;&#x9;        public.account_types act ON coa.account_type_id = act.id&#xA;&#x9;    WHERE &#xA;&#x9;        coa.is_deleted = false&#xA;&#x9;        AND coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;&#xA;&#x9;        AND coa.organization_id = p_organization_id&#xA;        &#xA;&#x9;    UNION ALL&#xA;&#x9;&#xA;&#x9;    SELECT &#xA;&#x9;        coa.id,&#xA;&#x9;        act.name AS account_type,&#xA;&#x9;        coa.account_number,&#xA;&#x9;        coa.name as account_name,&#xA;&#x9;        coa.parent_account_id,&#xA;&#x9;        coa.is_default_account,&#xA;&#x9;        ch.level &#x2B; 1 AS level&#xA;&#x9;    FROM &#xA;&#x9;        public.chart_of_accounts coa&#xA;&#x9;    INNER JOIN&#xA;&#x9;        public.account_types act ON coa.account_type_id = act.id&#xA;&#x9;    INNER JOIN &#xA;&#x9;        coa_hierarchy ch ON ch.id = coa.parent_account_id&#xA;&#x9;    WHERE&#xA;&#x9;        coa.is_deleted = FALSE&#xA;)&#xA;&#x9;SELECT &#xA;&#x9;    ch.id,&#xA;&#x9;    ch.account_type,&#xA;&#x9;    ch.account_number,&#xA;&#x9;    LPAD(ch.account_name, LENGTH(ch.account_name) &#x2B; ch.level * 4, &#x27; &#x27;) AS account_name,&#xA;&#x9;    ch.parent_account_id,&#xA;&#x9;    ch.is_default_account,&#xA;&#x9;    ch.level&#xA;&#x9;FROM coa_hierarchy ch&#xA;&#x9;ORDER BY ch.account_number;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_city_id</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-27')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-27">
                                            CREATE OR REPLACE FUNCTION public.get_city_id(p_city_name text, p_zip_code text, p_state_id uuid, p_created_by uuid)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_city_id UUID;&#xA;BEGIN&#xA;    SELECT id INTO v_city_id&#xA;    FROM public.cities&#xA;    WHERE LOWER(name) = LOWER(p_city_name) AND zip_code = p_zip_code;&#xA;&#xA;    IF v_city_id IS NULL THEN&#xA;        INSERT INTO public.cities (id, name, state_id, zip_code, created_on_utc, created_by)&#xA;        VALUES (gen_random_uuid(), p_city_name, p_state_id, p_zip_code, NOW(), p_created_by)&#xA;        RETURNING id INTO v_city_id;&#xA;    END IF;&#xA;&#xA;    RETURN v_city_id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_city_id(p_city_name text, p_zip_code text, p_state_id uuid, p_created_by uuid)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_city_id UUID;&#xA;BEGIN&#xA;    SELECT id INTO v_city_id&#xA;    FROM public.cities&#xA;    WHERE LOWER(name) = LOWER(p_city_name) AND zip_code = p_zip_code;&#xA;&#xA;    IF v_city_id IS NULL THEN&#xA;        INSERT INTO public.cities (id, name, state_id, zip_code, created_on_utc, created_by)&#xA;        VALUES (gen_random_uuid(), p_city_name, p_state_id, p_zip_code, NOW(), p_created_by)&#xA;        RETURNING id INTO v_city_id;&#xA;    END IF;&#xA;&#xA;    RETURN v_city_id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_customer_dues</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-28')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-28">
                                            CREATE OR REPLACE FUNCTION public.get_customer_dues()&#xA; RETURNS TABLE(type text, name text, account_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        &#x27;Customer&#x27; AS type,&#xA;        c.name AS name,&#xA;        coa.name AS account_name,&#xA;        je.amount,&#xA;        th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; AS due_date,  -- Assuming a 30-day payment term&#xA;        CASE &#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;        END AS aging_bucket&#xA;    FROM &#xA;        public.journal_entries je&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN &#xA;        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        public.customers c ON th.customer_id = c.id&#xA;    WHERE &#xA;        coa.account_type_id = (SELECT id FROM account_types WHERE name = &#x27;Accounts Receivable&#x27;)&#xA;        AND je.is_deleted = false&#xA;        AND th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE&#xA;    ORDER BY &#xA;        name, due_date;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_customer_dues()&#xA; RETURNS TABLE(type text, name text, account_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        &#x27;Customer&#x27; AS type,&#xA;        c.name AS name,&#xA;        coa.name AS account_name,&#xA;        je.amount,&#xA;        th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; AS due_date,  -- Assuming a 30-day payment term&#xA;        CASE &#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;        END AS aging_bucket&#xA;    FROM &#xA;        public.journal_entries je&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN &#xA;        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        public.customers c ON th.customer_id = c.id&#xA;    WHERE &#xA;        coa.account_type_id = (SELECT id FROM account_types WHERE name = &#x27;Accounts Receivable&#x27;)&#xA;        AND je.is_deleted = false&#xA;        AND th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE&#xA;    ORDER BY &#xA;        name, due_date;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_customer_ledger</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-29')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-29">
                                            CREATE OR REPLACE FUNCTION public.get_customer_ledger(p_company_id uuid, p_organization_id uuid, p_customer_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, document_number text, document_id uuid, transaction_source_type integer, sort_order integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_opening_balance NUMERIC;&#xA;BEGIN&#xA;&#x9;SELECT COALESCE(&#xA;&#x9;        SUM(&#xA;&#x9;            CASE &#xA;&#x9;                WHEN ob.entry_type = &#x27;D&#x27; THEN ob.balance  -- Debit increases balance&#xA;&#x9;                ELSE -ob.balance                         -- Credit reduces balance&#xA;&#x9;            END&#xA;&#x9;        ), 0)&#xA;    INTO v_opening_balance&#xA;    FROM public.opening_balances ob&#xA;    WHERE ob.organization_id = p_organization_id &#xA;      AND ob.customer_id = p_customer_id&#xA;      AND ob.is_deleted = FALSE;&#xA;&#xA;    RETURN QUERY&#xA;    WITH customer_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date,&#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            th.customer_id, &#xA;            je.account_id,&#xA;            th.document_number,           &#xA;            th.document_id,&#xA;&#x9;&#x9;&#x9;th.transaction_source_type,&#xA;            2 AS sort_order&#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.customer_id = p_customer_id &#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date  &#xA;            AND th.transaction_date &lt;= p_end_date  &#xA;    )&#xA;    SELECT &#xA;        p_start_date AS transaction_date, &#xA;        &#x27;Opening Balance&#x27; AS account_name,&#xA;        0 AS debit,&#xA;        0 AS credit,&#xA;        v_opening_balance AS balance,&#xA;        NULL AS document_number,&#xA;        NULL AS document_id,&#xA;        NULL AS transaction_source_type,&#xA;        1 AS sort_order &#xA;         &#xA;    UNION ALL &#xA;&#xA;    SELECT &#xA;        ct.transaction_date,&#xA;        ct.account_name,&#xA;        ct.debit,&#xA;        ct.credit,&#xA;        v_opening_balance &#xA;        &#x2B; SUM(ct.debit - ct.credit) &#xA;        OVER (ORDER BY ct.transaction_date, ct.document_number ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)&#xA;        AS balance,&#xA;        ct.document_number,          &#xA;        ct.document_id,&#xA;        ct.transaction_source_type,&#xA;        ct.sort_order &#xA;    FROM &#xA;        customer_transactions ct&#xA;    WHERE &#xA;        NOT (ct.debit = 0 AND ct.credit = 0)&#xA;    ORDER BY &#xA;        transaction_date,&#xA;        sort_order ASC; -- Then order by transaction date&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_customer_ledger(p_company_id uuid, p_organization_id uuid, p_customer_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, document_number text, document_id uuid, transaction_source_type integer, sort_order integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_opening_balance NUMERIC;&#xA;BEGIN&#xA;&#x9;SELECT COALESCE(&#xA;&#x9;        SUM(&#xA;&#x9;            CASE &#xA;&#x9;                WHEN ob.entry_type = &#x27;D&#x27; THEN ob.balance  -- Debit increases balance&#xA;&#x9;                ELSE -ob.balance                         -- Credit reduces balance&#xA;&#x9;            END&#xA;&#x9;        ), 0)&#xA;    INTO v_opening_balance&#xA;    FROM public.opening_balances ob&#xA;    WHERE ob.organization_id = p_organization_id &#xA;      AND ob.customer_id = p_customer_id&#xA;      AND ob.is_deleted = FALSE;&#xA;&#xA;    RETURN QUERY&#xA;    WITH customer_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date,&#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            th.customer_id, &#xA;            je.account_id,&#xA;            th.document_number,           &#xA;            th.document_id,&#xA;&#x9;&#x9;&#x9;th.transaction_source_type,&#xA;            2 AS sort_order&#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.customer_id = p_customer_id &#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date  &#xA;            AND th.transaction_date &lt;= p_end_date  &#xA;    )&#xA;    SELECT &#xA;        p_start_date AS transaction_date, &#xA;        &#x27;Opening Balance&#x27; AS account_name,&#xA;        0 AS debit,&#xA;        0 AS credit,&#xA;        v_opening_balance AS balance,&#xA;        NULL AS document_number,&#xA;        NULL AS document_id,&#xA;        NULL AS transaction_source_type,&#xA;        1 AS sort_order &#xA;         &#xA;    UNION ALL &#xA;&#xA;    SELECT &#xA;        ct.transaction_date,&#xA;        ct.account_name,&#xA;        ct.debit,&#xA;        ct.credit,&#xA;        v_opening_balance &#xA;        &#x2B; SUM(ct.debit - ct.credit) &#xA;        OVER (ORDER BY ct.transaction_date, ct.document_number ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)&#xA;        AS balance,&#xA;        ct.document_number,          &#xA;        ct.document_id,&#xA;        ct.transaction_source_type,&#xA;        ct.sort_order &#xA;    FROM &#xA;        customer_transactions ct&#xA;    WHERE &#xA;        NOT (ct.debit = 0 AND ct.credit = 0)&#xA;    ORDER BY &#xA;        transaction_date,&#xA;        sort_order ASC; -- Then order by transaction date&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_customer_outstanding</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-30')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-30">
                                            CREATE OR REPLACE FUNCTION public.get_customer_outstanding()&#xA; RETURNS TABLE(customer_name text, account_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        c.name AS customer_name,&#xA;        coa.name AS account_name,&#xA;        je.amount,&#xA;        th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; AS due_date,  -- Assuming a 30-day payment term&#xA;        CASE &#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;        END AS aging_bucket&#xA;    FROM &#xA;        public.journal_entries je&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN &#xA;        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        public.customers c ON th.customer_id = c.id&#xA;    WHERE &#xA;        coa.account_type_id = (SELECT id FROM account_types WHERE name = &#x27;Accounts Receivable&#x27;)&#xA;        AND je.is_deleted = false&#xA;    ORDER BY &#xA;        c.name, th.transaction_date;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_customer_outstanding()&#xA; RETURNS TABLE(customer_name text, account_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        c.name AS customer_name,&#xA;        coa.name AS account_name,&#xA;        je.amount,&#xA;        th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; AS due_date,  -- Assuming a 30-day payment term&#xA;        CASE &#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;        END AS aging_bucket&#xA;    FROM &#xA;        public.journal_entries je&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN &#xA;        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        public.customers c ON th.customer_id = c.id&#xA;    WHERE &#xA;        coa.account_type_id = (SELECT id FROM account_types WHERE name = &#x27;Accounts Receivable&#x27;)&#xA;        AND je.is_deleted = false&#xA;    ORDER BY &#xA;        c.name, th.transaction_date;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_expense_account_types</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-31')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-31">
                                            CREATE OR REPLACE FUNCTION public.get_expense_account_types()&#xA; RETURNS TABLE(account_id uuid, account_name text, account_type_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        coa.id AS account_id,&#xA;        coa.name AS account_name,&#xA;        at.name AS account_type_name&#xA;    FROM&#xA;        chart_of_accounts coa&#xA;    INNER JOIN&#xA;        account_types at&#xA;    ON&#xA;        coa.account_type_id = at.id&#xA;    WHERE&#xA;        at.classification = &#x27;Expense&#x27;; -- Filter for expense account types&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_expense_account_types()&#xA; RETURNS TABLE(account_id uuid, account_name text, account_type_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        coa.id AS account_id,&#xA;        coa.name AS account_name,&#xA;        at.name AS account_type_name&#xA;    FROM&#xA;        chart_of_accounts coa&#xA;    INNER JOIN&#xA;        account_types at&#xA;    ON&#xA;        coa.account_type_id = at.id&#xA;    WHERE&#xA;        at.classification = &#x27;Expense&#x27;; -- Filter for expense account types&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_maintenance_collection_status</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-32')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-32">
                                            CREATE OR REPLACE FUNCTION public.get_maintenance_collection_status(p_company_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(year numeric, total_income numeric, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;&#x9;  RETURN QUERY&#xA;      SELECT           &#xA;          EXTRACT(YEAR FROM je.transaction_date) AS year,          &#xA;          SUM(CASE &#xA;              WHEN ac.id = 4 THEN je.amount -- 4 corresponds to &#x27;Revenue&#x27;&#xA;              ELSE 0 &#xA;          END) AS total_income,&#xA;          SUM(CASE &#xA;              WHEN ac.id = 5 THEN je.amount -- 5 corresponds to &#x27;Expenses&#x27;&#xA;              ELSE 0 &#xA;          END) AS total_expense&#xA;      FROM &#xA;          journal_entries je&#xA;      JOIN &#xA;          chart_of_accounts coa ON je.account_id = coa.id&#xA;      JOIN &#xA;          account_types act ON coa.account_type_id = act.id&#xA;      JOIN &#xA;          account_categories ac ON act.account_category_id = ac.id&#xA;      WHERE &#xA;          je.transaction_date BETWEEN p_start_date AND p_end_date&#xA;      &#x9;And je.company_id = p_company_id&#xA;      GROUP BY &#xA;          year &#xA;      ORDER BY &#xA;          year ;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_maintenance_collection_status(p_company_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(year numeric, total_income numeric, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;&#x9;  RETURN QUERY&#xA;      SELECT           &#xA;          EXTRACT(YEAR FROM je.transaction_date) AS year,          &#xA;          SUM(CASE &#xA;              WHEN ac.id = 4 THEN je.amount -- 4 corresponds to &#x27;Revenue&#x27;&#xA;              ELSE 0 &#xA;          END) AS total_income,&#xA;          SUM(CASE &#xA;              WHEN ac.id = 5 THEN je.amount -- 5 corresponds to &#x27;Expenses&#x27;&#xA;              ELSE 0 &#xA;          END) AS total_expense&#xA;      FROM &#xA;          journal_entries je&#xA;      JOIN &#xA;          chart_of_accounts coa ON je.account_id = coa.id&#xA;      JOIN &#xA;          account_types act ON coa.account_type_id = act.id&#xA;      JOIN &#xA;          account_categories ac ON act.account_category_id = ac.id&#xA;      WHERE &#xA;          je.transaction_date BETWEEN p_start_date AND p_end_date&#xA;      &#x9;And je.company_id = p_company_id&#xA;      GROUP BY &#xA;          year &#xA;      ORDER BY &#xA;          year ;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_expense_categorization</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-33')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-33">
                                            CREATE OR REPLACE FUNCTION public.get_expense_categorization(p_company_id uuid, p_period_type integer, p_finance_id integer)&#xA; RETURNS TABLE(period text, year numeric, account_id uuid, account_name text, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;BEGIN&#xA;    -- Step 1: Get financial year boundaries&#xA;    SELECT start_date, end_date INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_id;&#xA;&#xA;    -- Raise an exception if financial year is not found&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 2: Categorize expenses based on period type&#xA;    IF p_period_type = 1 THEN -- Monthly Categorization&#xA;    RETURN QUERY&#xA;    WITH months AS (&#xA;        SELECT &#xA;            TO_CHAR(m, &#x27;Mon&#x27;) AS period, &#xA;            EXTRACT(YEAR FROM m) AS year, &#xA;            EXTRACT(MONTH FROM m) AS month_num&#xA;        FROM generate_series(v_financial_year_start, v_financial_year_end, &#x27;1 month&#x27;::interval) AS m&#xA;    )&#xA;    SELECT &#xA;        months.period,&#xA;        months.year,&#xA;        coa.id AS account_id,  -- &#x1F539; Added missing account_id&#xA;        coa.name AS account_name,&#xA;        COALESCE(SUM(je.amount), 0) AS total_expense&#xA;    FROM months&#xA;    LEFT JOIN public.journal_entries je &#xA;        ON EXTRACT(MONTH FROM je.transaction_date) = months.month_num&#xA;        AND EXTRACT(YEAR FROM je.transaction_date) = months.year&#xA;    INNER JOIN public.transaction_headers th &#xA;        ON je.transaction_id = th.id &#xA;        AND th.company_id = p_company_id&#xA;    INNER JOIN public.chart_of_accounts coa &#xA;        ON je.account_id = coa.id&#xA;    WHERE &#xA;        coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;        AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;        AND je.entry_type = &#x27;D&#x27;&#xA;        AND je.is_deleted = FALSE&#xA;    GROUP BY months.year, months.month_num, months.period, coa.id, coa.name  -- &#x1F539; Added `coa.id` to GROUP BY&#xA;    ORDER BY months.year, months.month_num, coa.name;&#xA;&#xA;&#xA;    ELSIF p_period_type = 2 THEN -- Quarterly Categorization&#xA;        RETURN QUERY&#xA;        WITH quarters AS (&#xA;            SELECT &#x27;Q1&#x27; AS period, v_financial_year_start AS start_date, v_financial_year_start &#x2B; interval &#x27;2 month&#x27; AS end_date&#xA;            UNION ALL&#xA;            SELECT &#x27;Q2&#x27;, v_financial_year_start &#x2B; interval &#x27;3 month&#x27;, v_financial_year_start &#x2B; interval &#x27;5 month&#x27;&#xA;            UNION ALL&#xA;            SELECT &#x27;Q3&#x27;, v_financial_year_start &#x2B; interval &#x27;6 month&#x27;, v_financial_year_start &#x2B; interval &#x27;8 month&#x27;&#xA;            UNION ALL&#xA;            SELECT &#x27;Q4&#x27;, v_financial_year_start &#x2B; interval &#x27;9 month&#x27;, v_financial_year_end&#xA;        )&#xA;        SELECT &#xA;            quarters.period,&#xA;            EXTRACT(YEAR FROM quarters.start_date) AS year,&#xA;            coa.id AS account_id, -- Added account_id&#xA;            coa.name AS account_name,&#xA;            COALESCE(SUM(je.amount), 0) AS total_expense&#xA;        FROM quarters&#xA;        LEFT JOIN public.journal_entries je &#xA;            ON je.transaction_date BETWEEN quarters.start_date AND quarters.end_date&#xA;        INNER JOIN public.transaction_headers th &#xA;            ON je.transaction_id = th.id &#xA;            AND th.company_id = p_company_id&#xA;        INNER JOIN public.chart_of_accounts coa &#xA;            ON je.account_id = coa.id&#xA;        WHERE &#xA;            coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.entry_type = &#x27;D&#x27;&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY quarters.period, year, coa.id, coa.name&#xA;        ORDER BY year, quarters.period, coa.name;&#xA;&#xA;    ELSIF p_period_type = 3 THEN -- Half-Yearly Categorization&#xA;        RETURN QUERY&#xA;        WITH half_years AS (&#xA;            SELECT &#x27;H1&#x27; AS period, v_financial_year_start AS start_date, v_financial_year_start &#x2B; interval &#x27;5 month&#x27; AS end_date&#xA;            UNION ALL&#xA;            SELECT &#x27;H2&#x27;, v_financial_year_start &#x2B; interval &#x27;6 month&#x27;, v_financial_year_end&#xA;        )&#xA;        SELECT &#xA;            half_years.period,&#xA;            EXTRACT(YEAR FROM half_years.start_date) AS year,&#xA;            coa.id AS account_id, -- Added account_id&#xA;            coa.name AS account_name,&#xA;            COALESCE(SUM(je.amount), 0) AS total_expense&#xA;        FROM half_years&#xA;        LEFT JOIN public.journal_entries je &#xA;            ON je.transaction_date BETWEEN half_years.start_date AND half_years.end_date&#xA;        INNER JOIN public.transaction_headers th &#xA;            ON je.transaction_id = th.id &#xA;            AND th.company_id = p_company_id&#xA;        INNER JOIN public.chart_of_accounts coa &#xA;            ON je.account_id = coa.id&#xA;        WHERE &#xA;            coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.entry_type = &#x27;D&#x27;&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY half_years.period, year, coa.id, coa.name&#xA;        ORDER BY year, half_years.period, coa.name;&#xA;&#xA;    ELSIF p_period_type = 4 THEN -- Yearly Categorization&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            &#x27;Year&#x27; AS period, &#xA;            EXTRACT(YEAR FROM je.transaction_date) AS year,&#xA;            coa.id AS account_id, -- Added account_id&#xA;            coa.name AS account_name,&#xA;            COALESCE(SUM(je.amount), 0) AS total_expense&#xA;        FROM public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th &#xA;            ON je.transaction_id = th.id &#xA;            AND th.company_id = p_company_id&#xA;        INNER JOIN public.chart_of_accounts coa &#xA;            ON je.account_id = coa.id&#xA;        WHERE &#xA;            coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.entry_type = &#x27;D&#x27;&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY year, coa.id, coa.name&#xA;        ORDER BY year, coa.name;&#xA;&#xA;    END IF;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_expense_categorization(p_company_id uuid, p_period_type integer, p_finance_id integer)&#xA; RETURNS TABLE(period text, year numeric, account_id uuid, account_name text, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;BEGIN&#xA;    -- Step 1: Get financial year boundaries&#xA;    SELECT start_date, end_date INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_id;&#xA;&#xA;    -- Raise an exception if financial year is not found&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 2: Categorize expenses based on period type&#xA;    IF p_period_type = 1 THEN -- Monthly Categorization&#xA;    RETURN QUERY&#xA;    WITH months AS (&#xA;        SELECT &#xA;            TO_CHAR(m, &#x27;Mon&#x27;) AS period, &#xA;            EXTRACT(YEAR FROM m) AS year, &#xA;            EXTRACT(MONTH FROM m) AS month_num&#xA;        FROM generate_series(v_financial_year_start, v_financial_year_end, &#x27;1 month&#x27;::interval) AS m&#xA;    )&#xA;    SELECT &#xA;        months.period,&#xA;        months.year,&#xA;        coa.id AS account_id,  -- &#x1F539; Added missing account_id&#xA;        coa.name AS account_name,&#xA;        COALESCE(SUM(je.amount), 0) AS total_expense&#xA;    FROM months&#xA;    LEFT JOIN public.journal_entries je &#xA;        ON EXTRACT(MONTH FROM je.transaction_date) = months.month_num&#xA;        AND EXTRACT(YEAR FROM je.transaction_date) = months.year&#xA;    INNER JOIN public.transaction_headers th &#xA;        ON je.transaction_id = th.id &#xA;        AND th.company_id = p_company_id&#xA;    INNER JOIN public.chart_of_accounts coa &#xA;        ON je.account_id = coa.id&#xA;    WHERE &#xA;        coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;        AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;        AND je.entry_type = &#x27;D&#x27;&#xA;        AND je.is_deleted = FALSE&#xA;    GROUP BY months.year, months.month_num, months.period, coa.id, coa.name  -- &#x1F539; Added `coa.id` to GROUP BY&#xA;    ORDER BY months.year, months.month_num, coa.name;&#xA;&#xA;&#xA;    ELSIF p_period_type = 2 THEN -- Quarterly Categorization&#xA;        RETURN QUERY&#xA;        WITH quarters AS (&#xA;            SELECT &#x27;Q1&#x27; AS period, v_financial_year_start AS start_date, v_financial_year_start &#x2B; interval &#x27;2 month&#x27; AS end_date&#xA;            UNION ALL&#xA;            SELECT &#x27;Q2&#x27;, v_financial_year_start &#x2B; interval &#x27;3 month&#x27;, v_financial_year_start &#x2B; interval &#x27;5 month&#x27;&#xA;            UNION ALL&#xA;            SELECT &#x27;Q3&#x27;, v_financial_year_start &#x2B; interval &#x27;6 month&#x27;, v_financial_year_start &#x2B; interval &#x27;8 month&#x27;&#xA;            UNION ALL&#xA;            SELECT &#x27;Q4&#x27;, v_financial_year_start &#x2B; interval &#x27;9 month&#x27;, v_financial_year_end&#xA;        )&#xA;        SELECT &#xA;            quarters.period,&#xA;            EXTRACT(YEAR FROM quarters.start_date) AS year,&#xA;            coa.id AS account_id, -- Added account_id&#xA;            coa.name AS account_name,&#xA;            COALESCE(SUM(je.amount), 0) AS total_expense&#xA;        FROM quarters&#xA;        LEFT JOIN public.journal_entries je &#xA;            ON je.transaction_date BETWEEN quarters.start_date AND quarters.end_date&#xA;        INNER JOIN public.transaction_headers th &#xA;            ON je.transaction_id = th.id &#xA;            AND th.company_id = p_company_id&#xA;        INNER JOIN public.chart_of_accounts coa &#xA;            ON je.account_id = coa.id&#xA;        WHERE &#xA;            coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.entry_type = &#x27;D&#x27;&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY quarters.period, year, coa.id, coa.name&#xA;        ORDER BY year, quarters.period, coa.name;&#xA;&#xA;    ELSIF p_period_type = 3 THEN -- Half-Yearly Categorization&#xA;        RETURN QUERY&#xA;        WITH half_years AS (&#xA;            SELECT &#x27;H1&#x27; AS period, v_financial_year_start AS start_date, v_financial_year_start &#x2B; interval &#x27;5 month&#x27; AS end_date&#xA;            UNION ALL&#xA;            SELECT &#x27;H2&#x27;, v_financial_year_start &#x2B; interval &#x27;6 month&#x27;, v_financial_year_end&#xA;        )&#xA;        SELECT &#xA;            half_years.period,&#xA;            EXTRACT(YEAR FROM half_years.start_date) AS year,&#xA;            coa.id AS account_id, -- Added account_id&#xA;            coa.name AS account_name,&#xA;            COALESCE(SUM(je.amount), 0) AS total_expense&#xA;        FROM half_years&#xA;        LEFT JOIN public.journal_entries je &#xA;            ON je.transaction_date BETWEEN half_years.start_date AND half_years.end_date&#xA;        INNER JOIN public.transaction_headers th &#xA;            ON je.transaction_id = th.id &#xA;            AND th.company_id = p_company_id&#xA;        INNER JOIN public.chart_of_accounts coa &#xA;            ON je.account_id = coa.id&#xA;        WHERE &#xA;            coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.entry_type = &#x27;D&#x27;&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY half_years.period, year, coa.id, coa.name&#xA;        ORDER BY year, half_years.period, coa.name;&#xA;&#xA;    ELSIF p_period_type = 4 THEN -- Yearly Categorization&#xA;        RETURN QUERY&#xA;        SELECT &#xA;            &#x27;Year&#x27; AS period, &#xA;            EXTRACT(YEAR FROM je.transaction_date) AS year,&#xA;            coa.id AS account_id, -- Added account_id&#xA;            coa.name AS account_name,&#xA;            COALESCE(SUM(je.amount), 0) AS total_expense&#xA;        FROM public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th &#xA;            ON je.transaction_id = th.id &#xA;            AND th.company_id = p_company_id&#xA;        INNER JOIN public.chart_of_accounts coa &#xA;            ON je.account_id = coa.id&#xA;        WHERE &#xA;            coa.account_type_id IN (SELECT id FROM get_account_type_hierarchy(5))&#xA;            AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;            AND je.entry_type = &#x27;D&#x27;&#xA;            AND je.is_deleted = FALSE&#xA;        GROUP BY year, coa.id, coa.name&#xA;        ORDER BY year, coa.name;&#xA;&#xA;    END IF;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_expense_monthly_data</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-34')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-34">
                                            CREATE OR REPLACE FUNCTION public.get_expense_monthly_data(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_name text, year integer, apr numeric, may numeric, jun numeric, jul numeric, aug numeric, sep numeric, oct numeric, nov numeric, &quot;dec&quot; numeric, jan numeric, feb numeric, mar numeric, total numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT organization_id INTO v_organization_id &#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT start_date, end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT start_date, end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year&#xA;    WHERE id = (p_finance_year_id - 1);  -- Fetch previous year finance data&#xA;&#xA;    RETURN QUERY &#xA;    WITH expense_accounts AS (&#xA;        -- Fetch all expense accounts&#xA;        SELECT coa.id, coa.name&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types at ON coa.account_type_id = at.id&#xA;        WHERE at.id IN (SELECT id FROM get_account_type_hierarchy(5)) &#xA;          AND coa.organization_id = v_organization_id&#xA;    ),&#xA;    monthly_expenses AS (&#xA;        -- Get monthly totals for the selected and previous financial years&#xA;        SELECT &#xA;            je.account_id,&#xA;            CASE &#xA;                WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN p_finance_year_id&#xA;                WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN (p_finance_year_id - 1)&#xA;            END AS year,&#xA;            EXTRACT(MONTH FROM je.transaction_date) AS month,&#xA;            SUM(je.amount) AS amount&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  -- Filter for both years&#xA;        GROUP BY je.account_id, year, EXTRACT(MONTH FROM je.transaction_date)&#xA;    ),&#xA;    pivoted_expenses AS (&#xA;        -- Pivoting data to month-wise columns&#xA;        SELECT &#xA;            ea.name AS account_name,&#xA;            me.year,&#xA;            COALESCE(SUM(CASE WHEN me.month = 4 THEN me.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN me.month = 5 THEN me.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN me.month = 6 THEN me.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN me.month = 7 THEN me.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN me.month = 8 THEN me.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN me.month = 9 THEN me.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN me.month = 10 THEN me.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN me.month = 11 THEN me.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN me.month = 12 THEN me.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN me.month = 1 THEN me.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN me.month = 2 THEN me.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN me.month = 3 THEN me.amount ELSE 0 END), 0) AS mar,&#xA;            SUM(me.amount) AS total&#xA;        FROM expense_accounts ea&#xA;        JOIN monthly_expenses me ON ea.id = me.account_id&#xA;        WHERE me.year IN (p_finance_year_id, p_finance_year_id - 1)&#xA;        GROUP BY ea.name, me.year&#xA;    )&#xA;    -- Final table with the difference calculation&#xA;    SELECT &#xA;        pe.account_name,&#xA;        pe.year,&#xA;        pe.apr, pe.may, pe.jun, pe.jul, pe.aug, pe.sep, pe.oct, pe.nov, pe.dec, pe.jan, pe.feb, pe.mar,&#xA;        pe.total,&#xA;        COALESCE(pe.total - LAG(pe.total) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS difference&#xA;    FROM pivoted_expenses pe&#xA;    ORDER BY pe.account_name, pe.year;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_expense_monthly_data(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_name text, year integer, apr numeric, may numeric, jun numeric, jul numeric, aug numeric, sep numeric, oct numeric, nov numeric, &quot;dec&quot; numeric, jan numeric, feb numeric, mar numeric, total numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT organization_id INTO v_organization_id &#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT start_date, end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT start_date, end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year&#xA;    WHERE id = (p_finance_year_id - 1);  -- Fetch previous year finance data&#xA;&#xA;    RETURN QUERY &#xA;    WITH expense_accounts AS (&#xA;        -- Fetch all expense accounts&#xA;        SELECT coa.id, coa.name&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types at ON coa.account_type_id = at.id&#xA;        WHERE at.id IN (SELECT id FROM get_account_type_hierarchy(5)) &#xA;          AND coa.organization_id = v_organization_id&#xA;    ),&#xA;    monthly_expenses AS (&#xA;        -- Get monthly totals for the selected and previous financial years&#xA;        SELECT &#xA;            je.account_id,&#xA;            CASE &#xA;                WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN p_finance_year_id&#xA;                WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN (p_finance_year_id - 1)&#xA;            END AS year,&#xA;            EXTRACT(MONTH FROM je.transaction_date) AS month,&#xA;            SUM(je.amount) AS amount&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  -- Filter for both years&#xA;        GROUP BY je.account_id, year, EXTRACT(MONTH FROM je.transaction_date)&#xA;    ),&#xA;    pivoted_expenses AS (&#xA;        -- Pivoting data to month-wise columns&#xA;        SELECT &#xA;            ea.name AS account_name,&#xA;            me.year,&#xA;            COALESCE(SUM(CASE WHEN me.month = 4 THEN me.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN me.month = 5 THEN me.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN me.month = 6 THEN me.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN me.month = 7 THEN me.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN me.month = 8 THEN me.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN me.month = 9 THEN me.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN me.month = 10 THEN me.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN me.month = 11 THEN me.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN me.month = 12 THEN me.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN me.month = 1 THEN me.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN me.month = 2 THEN me.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN me.month = 3 THEN me.amount ELSE 0 END), 0) AS mar,&#xA;            SUM(me.amount) AS total&#xA;        FROM expense_accounts ea&#xA;        JOIN monthly_expenses me ON ea.id = me.account_id&#xA;        WHERE me.year IN (p_finance_year_id, p_finance_year_id - 1)&#xA;        GROUP BY ea.name, me.year&#xA;    )&#xA;    -- Final table with the difference calculation&#xA;    SELECT &#xA;        pe.account_name,&#xA;        pe.year,&#xA;        pe.apr, pe.may, pe.jun, pe.jul, pe.aug, pe.sep, pe.oct, pe.nov, pe.dec, pe.jan, pe.feb, pe.mar,&#xA;        pe.total,&#xA;        COALESCE(pe.total - LAG(pe.total) OVER (PARTITION BY pe.account_name ORDER BY pe.year), 0) AS difference&#xA;    FROM pivoted_expenses pe&#xA;    ORDER BY pe.account_name, pe.year;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_financial_year_dates</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-35')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-35">
                                            CREATE OR REPLACE FUNCTION public.get_financial_year_dates(p_fin_year_id integer)&#xA; RETURNS TABLE(start_date date, end_date date)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT fy.start_date::DATE, fy.end_date::DATE&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_fin_year_id&#xA;    LIMIT 1;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_financial_year_dates(p_fin_year_id integer)&#xA; RETURNS TABLE(start_date date, end_date date)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT fy.start_date::DATE, fy.end_date::DATE&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_fin_year_id&#xA;    LIMIT 1;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_general_ledger</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-36')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-36">
                                            CREATE OR REPLACE FUNCTION public.get_general_ledger(p_company_id uuid, p_organization_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, transaction_source_type integer, document_number text, document_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH general_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date, -- Cast to date&#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            je.account_id,&#xA;            th.transaction_source_type,   &#xA;            th.document_number,           &#xA;            th.document_id              &#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date  &#xA;            AND th.transaction_date &lt;= p_end_date  &#xA;    )&#xA;    SELECT &#xA;        gt.transaction_date,&#xA;        gt.account_name,&#xA;        gt.debit,&#xA;        gt.credit,&#xA;        -- Recalculate balance where debit and credit are settled&#xA;        SUM(gt.debit - gt.credit) OVER (PARTITION BY gt.account_id ORDER BY gt.transaction_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS balance,&#xA;        gt.transaction_source_type,   &#xA;        gt.document_number,          &#xA;        gt.document_id                &#xA;    FROM &#xA;        general_transactions gt&#xA;    WHERE&#xA;        -- Exclude rows where both debit and credit are 0&#xA;        NOT (gt.debit = 0 AND gt.credit = 0)&#xA;    ORDER BY &#xA;        gt.transaction_date;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_general_ledger(p_company_id uuid, p_organization_id uuid, p_start_date date, p_end_date date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, transaction_source_type integer, document_number text, document_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH general_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date, -- Cast to date&#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            je.account_id,&#xA;            th.transaction_source_type,   &#xA;            th.document_number,           &#xA;            th.document_id              &#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date  &#xA;            AND th.transaction_date &lt;= p_end_date  &#xA;    )&#xA;    SELECT &#xA;        gt.transaction_date,&#xA;        gt.account_name,&#xA;        gt.debit,&#xA;        gt.credit,&#xA;        -- Recalculate balance where debit and credit are settled&#xA;        SUM(gt.debit - gt.credit) OVER (PARTITION BY gt.account_id ORDER BY gt.transaction_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS balance,&#xA;        gt.transaction_source_type,   &#xA;        gt.document_number,          &#xA;        gt.document_id                &#xA;    FROM &#xA;        general_transactions gt&#xA;    WHERE&#xA;        -- Exclude rows where both debit and credit are 0&#xA;        NOT (gt.debit = 0 AND gt.credit = 0)&#xA;    ORDER BY &#xA;        gt.transaction_date;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_income_expense_monthly_breakdown</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-37')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-37">
                                            CREATE OR REPLACE FUNCTION public.get_income_expense_monthly_breakdown(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(id uuid, account_type text, account_name text, parent_account_id uuid, level integer, year integer, apr numeric, apr_diff numeric, may numeric, may_diff numeric, jun numeric, jun_diff numeric, jul numeric, jul_diff numeric, aug numeric, aug_diff numeric, sep numeric, sep_diff numeric, oct numeric, oct_diff numeric, nov numeric, nov_diff numeric, &quot;dec&quot; numeric, dec_diff numeric, jan numeric, jan_diff numeric, feb numeric, feb_diff numeric, mar numeric, mar_diff numeric, total numeric, difference numeric, order_sequence character varying)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT pfy.start_date, pfy.end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year pfy&#xA;    WHERE pfy.id = (p_finance_year_id - 1);&#xA;&#xA;    RETURN QUERY &#xA;    WITH RECURSIVE account_hierarchy AS (&#xA;        -- Get all income and expense accounts in a hierarchical order&#xA;        SELECT&#xA;            coa.id AS id,  &#xA;            act.name AS account_type,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::TEXT::CHARACTER VARYING AS order_sequence -- &#x2705; Cast explicitly&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types act ON coa.account_type_id = act.id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND act.id IN (4, 5)&#xA;          AND (coa.parent_account_id IS NULL OR coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;)&#xA;          AND coa.is_deleted = FALSE&#xA;          &#xA;        UNION ALL&#xA;        &#xA;        SELECT&#xA;            coa.id AS id,  &#xA;            act.name AS account_type,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            parent.level &#x2B; 1 AS level,&#xA;            (parent.order_sequence || &#x27;.&#x27; || coa.account_number::TEXT)::CHARACTER VARYING -- &#x2705; Cast explicitly&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_hierarchy parent ON parent.id = coa.parent_account_id&#xA;        JOIN account_types act ON coa.account_type_id = act.id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND coa.is_deleted = FALSE&#xA;    ),&#xA;    years AS (&#xA;        -- Ensure two years are always present&#xA;        SELECT p_finance_year_id AS year&#xA;        UNION ALL&#xA;        SELECT p_finance_year_id - 1&#xA;    ),&#xA;    all_accounts AS (&#xA;        -- Ensure all accounts have both years&#xA;        SELECT ah.id, ah.account_name, ah.account_type, ah.parent_account_id, ah.level, ah.order_sequence, y.year&#xA;        FROM account_hierarchy ah&#xA;        CROSS JOIN years y&#xA;    ),&#xA;    monthly_totals AS (&#xA;        -- Get monthly totals for the selected and previous financial years&#xA;        SELECT &#xA;            je.account_id AS id,  &#xA;            CASE &#xA;                WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN p_finance_year_id&#xA;                WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN (p_finance_year_id - 1)&#xA;            END AS year,&#xA;            EXTRACT(MONTH FROM je.transaction_date) AS month,&#xA;            SUM(je.amount) AS amount&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  &#xA;        GROUP BY je.account_id, year, EXTRACT(MONTH FROM je.transaction_date)&#xA;    ),&#xA;    pivoted_data AS (&#xA;        -- Pivoting data to month-wise columns&#xA;        SELECT &#xA;            aa.id,  &#xA;            aa.account_type,&#xA;            aa.account_name,&#xA;            aa.parent_account_id,&#xA;            aa.level,&#xA;            aa.year,&#xA;            aa.order_sequence,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 4 THEN mt.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 5 THEN mt.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 6 THEN mt.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 7 THEN mt.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 8 THEN mt.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 9 THEN mt.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 10 THEN mt.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 11 THEN mt.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 12 THEN mt.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 1 THEN mt.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 2 THEN mt.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 3 THEN mt.amount ELSE 0 END), 0) AS mar,&#xA;            COALESCE(SUM(mt.amount), 0) AS total&#xA;        FROM all_accounts aa&#xA;        LEFT JOIN monthly_totals mt ON aa.id = mt.id AND aa.year = mt.year&#xA;        GROUP BY aa.id, aa.account_type, aa.account_name, aa.parent_account_id, aa.level, aa.order_sequence, aa.year&#xA;    )&#xA;    -- Final table with the difference calculation&#xA;   SELECT &#xA;    pd.id,  &#xA;    pd.account_type,&#xA;&#x9;LPAD(&#x27;&#x27;, pd.level * 4, &#x27; &#x27;) || pd.account_name,&#xA;    pd.parent_account_id,&#xA;    pd.level,&#xA;    pd.year,&#xA;    pd.apr, COALESCE(pd.apr - LAG(pd.apr) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS apr_diff,&#xA;    pd.may, COALESCE(pd.may - LAG(pd.may) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS may_diff,&#xA;    pd.jun, COALESCE(pd.jun - LAG(pd.jun) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS jun_diff,&#xA;    pd.jul, COALESCE(pd.jul - LAG(pd.jul) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS jul_diff,&#xA;    pd.aug, COALESCE(pd.aug - LAG(pd.aug) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS aug_diff,&#xA;    pd.sep, COALESCE(pd.sep - LAG(pd.sep) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS sep_diff,&#xA;    pd.oct, COALESCE(pd.oct - LAG(pd.oct) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS oct_diff,&#xA;    pd.nov, COALESCE(pd.nov - LAG(pd.nov) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS nov_diff,&#xA;    pd.dec, COALESCE(pd.dec - LAG(pd.dec) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS dec_diff,&#xA;    pd.jan, COALESCE(pd.jan - LAG(pd.jan) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS jan_diff,&#xA;    pd.feb, COALESCE(pd.feb - LAG(pd.feb) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS feb_diff,&#xA;    pd.mar, COALESCE(pd.mar - LAG(pd.mar) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS mar_diff,&#xA;    pd.total,&#xA;    COALESCE(pd.total - LAG(pd.total) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS difference,&#xA;    pd.order_sequence::CHARACTER VARYING -- &#x2705; Ensures type consistency&#xA;FROM pivoted_data pd&#xA;ORDER BY pd.order_sequence;&#xA;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_income_expense_monthly_breakdown(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(id uuid, account_type text, account_name text, parent_account_id uuid, level integer, year integer, apr numeric, apr_diff numeric, may numeric, may_diff numeric, jun numeric, jun_diff numeric, jul numeric, jul_diff numeric, aug numeric, aug_diff numeric, sep numeric, sep_diff numeric, oct numeric, oct_diff numeric, nov numeric, nov_diff numeric, &quot;dec&quot; numeric, dec_diff numeric, jan numeric, jan_diff numeric, feb numeric, feb_diff numeric, mar numeric, mar_diff numeric, total numeric, difference numeric, order_sequence character varying)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT pfy.start_date, pfy.end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year pfy&#xA;    WHERE pfy.id = (p_finance_year_id - 1);&#xA;&#xA;    RETURN QUERY &#xA;    WITH RECURSIVE account_hierarchy AS (&#xA;        -- Get all income and expense accounts in a hierarchical order&#xA;        SELECT&#xA;            coa.id AS id,  &#xA;            act.name AS account_type,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            coa.account_number::TEXT::CHARACTER VARYING AS order_sequence -- &#x2705; Cast explicitly&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types act ON coa.account_type_id = act.id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND act.id IN (4, 5)&#xA;          AND (coa.parent_account_id IS NULL OR coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;)&#xA;          AND coa.is_deleted = FALSE&#xA;          &#xA;        UNION ALL&#xA;        &#xA;        SELECT&#xA;            coa.id AS id,  &#xA;            act.name AS account_type,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            parent.level &#x2B; 1 AS level,&#xA;            (parent.order_sequence || &#x27;.&#x27; || coa.account_number::TEXT)::CHARACTER VARYING -- &#x2705; Cast explicitly&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_hierarchy parent ON parent.id = coa.parent_account_id&#xA;        JOIN account_types act ON coa.account_type_id = act.id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND coa.is_deleted = FALSE&#xA;    ),&#xA;    years AS (&#xA;        -- Ensure two years are always present&#xA;        SELECT p_finance_year_id AS year&#xA;        UNION ALL&#xA;        SELECT p_finance_year_id - 1&#xA;    ),&#xA;    all_accounts AS (&#xA;        -- Ensure all accounts have both years&#xA;        SELECT ah.id, ah.account_name, ah.account_type, ah.parent_account_id, ah.level, ah.order_sequence, y.year&#xA;        FROM account_hierarchy ah&#xA;        CROSS JOIN years y&#xA;    ),&#xA;    monthly_totals AS (&#xA;        -- Get monthly totals for the selected and previous financial years&#xA;        SELECT &#xA;            je.account_id AS id,  &#xA;            CASE &#xA;                WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN p_finance_year_id&#xA;                WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN (p_finance_year_id - 1)&#xA;            END AS year,&#xA;            EXTRACT(MONTH FROM je.transaction_date) AS month,&#xA;            SUM(je.amount) AS amount&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  &#xA;        GROUP BY je.account_id, year, EXTRACT(MONTH FROM je.transaction_date)&#xA;    ),&#xA;    pivoted_data AS (&#xA;        -- Pivoting data to month-wise columns&#xA;        SELECT &#xA;            aa.id,  &#xA;            aa.account_type,&#xA;            aa.account_name,&#xA;            aa.parent_account_id,&#xA;            aa.level,&#xA;            aa.year,&#xA;            aa.order_sequence,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 4 THEN mt.amount ELSE 0 END), 0) AS apr,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 5 THEN mt.amount ELSE 0 END), 0) AS may,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 6 THEN mt.amount ELSE 0 END), 0) AS jun,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 7 THEN mt.amount ELSE 0 END), 0) AS jul,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 8 THEN mt.amount ELSE 0 END), 0) AS aug,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 9 THEN mt.amount ELSE 0 END), 0) AS sep,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 10 THEN mt.amount ELSE 0 END), 0) AS oct,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 11 THEN mt.amount ELSE 0 END), 0) AS nov,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 12 THEN mt.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 1 THEN mt.amount ELSE 0 END), 0) AS jan,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 2 THEN mt.amount ELSE 0 END), 0) AS feb,&#xA;            COALESCE(SUM(CASE WHEN mt.month = 3 THEN mt.amount ELSE 0 END), 0) AS mar,&#xA;            COALESCE(SUM(mt.amount), 0) AS total&#xA;        FROM all_accounts aa&#xA;        LEFT JOIN monthly_totals mt ON aa.id = mt.id AND aa.year = mt.year&#xA;        GROUP BY aa.id, aa.account_type, aa.account_name, aa.parent_account_id, aa.level, aa.order_sequence, aa.year&#xA;    )&#xA;    -- Final table with the difference calculation&#xA;   SELECT &#xA;    pd.id,  &#xA;    pd.account_type,&#xA;&#x9;LPAD(&#x27;&#x27;, pd.level * 4, &#x27; &#x27;) || pd.account_name,&#xA;    pd.parent_account_id,&#xA;    pd.level,&#xA;    pd.year,&#xA;    pd.apr, COALESCE(pd.apr - LAG(pd.apr) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS apr_diff,&#xA;    pd.may, COALESCE(pd.may - LAG(pd.may) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS may_diff,&#xA;    pd.jun, COALESCE(pd.jun - LAG(pd.jun) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS jun_diff,&#xA;    pd.jul, COALESCE(pd.jul - LAG(pd.jul) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS jul_diff,&#xA;    pd.aug, COALESCE(pd.aug - LAG(pd.aug) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS aug_diff,&#xA;    pd.sep, COALESCE(pd.sep - LAG(pd.sep) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS sep_diff,&#xA;    pd.oct, COALESCE(pd.oct - LAG(pd.oct) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS oct_diff,&#xA;    pd.nov, COALESCE(pd.nov - LAG(pd.nov) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS nov_diff,&#xA;    pd.dec, COALESCE(pd.dec - LAG(pd.dec) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS dec_diff,&#xA;    pd.jan, COALESCE(pd.jan - LAG(pd.jan) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS jan_diff,&#xA;    pd.feb, COALESCE(pd.feb - LAG(pd.feb) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS feb_diff,&#xA;    pd.mar, COALESCE(pd.mar - LAG(pd.mar) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS mar_diff,&#xA;    pd.total,&#xA;    COALESCE(pd.total - LAG(pd.total) OVER (PARTITION BY pd.id ORDER BY pd.year), 0) AS difference,&#xA;    pd.order_sequence::CHARACTER VARYING -- &#x2705; Ensures type consistency&#xA;FROM pivoted_data pd&#xA;ORDER BY pd.order_sequence;&#xA;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_income_expense_monthly_hierarchy</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-38')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-38">
                                            CREATE OR REPLACE FUNCTION public.get_income_expense_monthly_hierarchy(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS jsonb&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;    result JSONB;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT pfy.start_date, pfy.end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year pfy&#xA;    WHERE pfy.id = (p_finance_year_id - 1);&#xA;&#xA;    -- Recursive CTE to build parent-child hierarchy&#xA;    WITH RECURSIVE account_hierarchy AS (&#xA;        -- Base case: Fetch top-level accounts&#xA;        SELECT&#xA;            coa.id,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            at.name AS account_type&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types at ON coa.account_type_id = at.id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND at.name IN (&#x27;Revenue&#x27;, &#x27;Expenses&#x27;)&#xA;          AND (coa.parent_account_id IS NULL OR coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;)&#xA;          AND coa.is_deleted = FALSE&#xA;          &#xA;        UNION ALL&#xA;        &#xA;        -- Recursive case: Fetch children accounts&#xA;        SELECT&#xA;            coa.id,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            parent.level &#x2B; 1 AS level,&#xA;            parent.account_type&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_hierarchy parent ON parent.id = coa.parent_account_id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND coa.is_deleted = FALSE&#xA;    ),&#xA;    monthly_totals AS (&#xA;        -- Get monthly totals&#xA;        SELECT &#xA;            je.account_id AS id,&#xA;            SUM(je.amount) AS total&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  &#xA;        GROUP BY je.account_id&#xA;    ),&#xA;    pivoted_data AS (&#xA;        -- Join accounts with totals&#xA;        SELECT &#xA;            ah.id,&#xA;            ah.account_type,&#xA;            ah.account_name,&#xA;            ah.parent_account_id,&#xA;            ah.level,&#xA;            COALESCE(mt.total, 0) AS total&#xA;        FROM account_hierarchy ah&#xA;        LEFT JOIN monthly_totals mt ON ah.id = mt.id&#xA;    ),&#xA;    full_hierarchy AS (&#xA;        -- Ensure all accounts are present in JSON format&#xA;        SELECT &#xA;            p.id,&#xA;            p.account_name,&#xA;            p.account_type,&#xA;            p.level,&#xA;            p.total,&#xA;            jsonb_agg(&#xA;                jsonb_build_object(&#xA;                    &#x27;id&#x27;, c.id,&#xA;                    &#x27;account_name&#x27;, c.account_name,&#xA;                    &#x27;account_type&#x27;, c.account_type,&#xA;                    &#x27;level&#x27;, c.level,&#xA;                    &#x27;total&#x27;, c.total,&#xA;                    &#x27;children&#x27;, &#x27;[]&#x27;::jsonb  -- Placeholder for child accounts&#xA;                )&#xA;            ) FILTER (WHERE c.id IS NOT NULL) AS children&#xA;        FROM pivoted_data p&#xA;        LEFT JOIN pivoted_data c ON p.id = c.parent_account_id&#xA;        GROUP BY p.id, p.account_name, p.account_type, p.level, p.total&#xA;    )&#xA;    -- Aggregate only the **top-level accounts** into JSON&#xA;    SELECT jsonb_agg(full_hierarchy.*) INTO result FROM full_hierarchy WHERE full_hierarchy.level = 0;&#xA;&#xA;    RETURN result;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_income_expense_monthly_hierarchy(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS jsonb&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_prev_start_date DATE;&#xA;    v_prev_end_date DATE;&#xA;    result JSONB;&#xA;BEGIN&#xA;    -- Get the organization_id for the given company_id&#xA;    SELECT c.organization_id INTO v_organization_id &#xA;    FROM public.companies c&#xA;    WHERE c.id = p_company_id;&#xA;&#xA;    -- Get the start and end dates for the selected financial year&#xA;    SELECT fy.start_date, fy.end_date INTO v_start_date, v_end_date &#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Get the start and end dates for the previous financial year&#xA;    SELECT pfy.start_date, pfy.end_date INTO v_prev_start_date, v_prev_end_date &#xA;    FROM public.finance_year pfy&#xA;    WHERE pfy.id = (p_finance_year_id - 1);&#xA;&#xA;    -- Recursive CTE to build parent-child hierarchy&#xA;    WITH RECURSIVE account_hierarchy AS (&#xA;        -- Base case: Fetch top-level accounts&#xA;        SELECT&#xA;            coa.id,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            0 AS level,&#xA;            at.name AS account_type&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_types at ON coa.account_type_id = at.id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND at.name IN (&#x27;Revenue&#x27;, &#x27;Expenses&#x27;)&#xA;          AND (coa.parent_account_id IS NULL OR coa.parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;)&#xA;          AND coa.is_deleted = FALSE&#xA;          &#xA;        UNION ALL&#xA;        &#xA;        -- Recursive case: Fetch children accounts&#xA;        SELECT&#xA;            coa.id,&#xA;            coa.name AS account_name,&#xA;            coa.parent_account_id,&#xA;            parent.level &#x2B; 1 AS level,&#xA;            parent.account_type&#xA;        FROM chart_of_accounts coa&#xA;        JOIN account_hierarchy parent ON parent.id = coa.parent_account_id&#xA;        WHERE coa.organization_id = v_organization_id&#xA;          AND coa.is_deleted = FALSE&#xA;    ),&#xA;    monthly_totals AS (&#xA;        -- Get monthly totals&#xA;        SELECT &#xA;            je.account_id AS id,&#xA;            SUM(je.amount) AS total&#xA;        FROM journal_entries je&#xA;        JOIN transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;        AND je.transaction_date BETWEEN v_prev_start_date AND v_end_date  &#xA;        GROUP BY je.account_id&#xA;    ),&#xA;    pivoted_data AS (&#xA;        -- Join accounts with totals&#xA;        SELECT &#xA;            ah.id,&#xA;            ah.account_type,&#xA;            ah.account_name,&#xA;            ah.parent_account_id,&#xA;            ah.level,&#xA;            COALESCE(mt.total, 0) AS total&#xA;        FROM account_hierarchy ah&#xA;        LEFT JOIN monthly_totals mt ON ah.id = mt.id&#xA;    ),&#xA;    full_hierarchy AS (&#xA;        -- Ensure all accounts are present in JSON format&#xA;        SELECT &#xA;            p.id,&#xA;            p.account_name,&#xA;            p.account_type,&#xA;            p.level,&#xA;            p.total,&#xA;            jsonb_agg(&#xA;                jsonb_build_object(&#xA;                    &#x27;id&#x27;, c.id,&#xA;                    &#x27;account_name&#x27;, c.account_name,&#xA;                    &#x27;account_type&#x27;, c.account_type,&#xA;                    &#x27;level&#x27;, c.level,&#xA;                    &#x27;total&#x27;, c.total,&#xA;                    &#x27;children&#x27;, &#x27;[]&#x27;::jsonb  -- Placeholder for child accounts&#xA;                )&#xA;            ) FILTER (WHERE c.id IS NOT NULL) AS children&#xA;        FROM pivoted_data p&#xA;        LEFT JOIN pivoted_data c ON p.id = c.parent_account_id&#xA;        GROUP BY p.id, p.account_name, p.account_type, p.level, p.total&#xA;    )&#xA;    -- Aggregate only the **top-level accounts** into JSON&#xA;    SELECT jsonb_agg(full_hierarchy.*) INTO result FROM full_hierarchy WHERE full_hierarchy.level = 0;&#xA;&#xA;    RETURN result;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_journal_voucher_by_header_id</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-39')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-39">
                                            CREATE OR REPLACE FUNCTION public.get_journal_voucher_by_header_id(p_header_id uuid)&#xA; RETURNS TABLE(id uuid, date timestamp without time zone, amount numeric, note text, account_id uuid, account_name text, is_debit boolean, details jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        jvh.id,&#xA;        jvh.date,&#xA;        jvh.amount,&#xA;        jvh.note,&#xA;        jvh.account_id,&#xA;        coa_header.name AS account_name,&#xA;        jvh.is_debit,&#xA;        jsonb_agg(&#xA;            jsonb_build_object(&#xA;                &#x27;id&#x27;, jvd.id,&#xA;                &#x27;credit_account_id&#x27;, jvd.credit_account_id,&#xA;                &#x27;credit_account_name&#x27;, coa_credit.name,&#xA;                &#x27;debit_account_id&#x27;, jvd.debit_account_id,&#xA;                &#x27;debit_account_name&#x27;, coa_debit.name, &#xA;                &#x27;amount&#x27;, jvd.amount,&#xA;                &#x27;tds_tcs&#x27;, jvd.tds_tcs,&#xA;                &#x27;narration&#x27;, jvd.narration&#xA;            )&#xA;        ) AS details&#xA;    FROM&#xA;        public.journal_voucher_headers jvh&#xA;    LEFT JOIN&#xA;        public.journal_voucher_details jvd ON jvh.id = jvd.journal_header_id&#xA;    LEFT JOIN&#xA;        public.chart_of_accounts coa_header ON jvh.account_id = coa_header.id&#xA;    LEFT JOIN&#xA;        public.chart_of_accounts coa_credit ON jvd.credit_account_id = coa_credit.id&#xA;    LEFT JOIN&#xA;        public.chart_of_accounts coa_debit ON jvd.debit_account_id = coa_debit.id&#xA;    WHERE&#xA;        jvh.id = p_header_id&#xA;        AND jvh.is_deleted = FALSE&#xA;        AND (jvd.is_deleted = FALSE OR jvd.is_deleted IS NULL)&#xA;    GROUP BY&#xA;        jvh.id, coa_header.name;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_journal_voucher_by_header_id(p_header_id uuid)&#xA; RETURNS TABLE(id uuid, date timestamp without time zone, amount numeric, note text, account_id uuid, account_name text, is_debit boolean, details jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        jvh.id,&#xA;        jvh.date,&#xA;        jvh.amount,&#xA;        jvh.note,&#xA;        jvh.account_id,&#xA;        coa_header.name AS account_name,&#xA;        jvh.is_debit,&#xA;        jsonb_agg(&#xA;            jsonb_build_object(&#xA;                &#x27;id&#x27;, jvd.id,&#xA;                &#x27;credit_account_id&#x27;, jvd.credit_account_id,&#xA;                &#x27;credit_account_name&#x27;, coa_credit.name,&#xA;                &#x27;debit_account_id&#x27;, jvd.debit_account_id,&#xA;                &#x27;debit_account_name&#x27;, coa_debit.name, &#xA;                &#x27;amount&#x27;, jvd.amount,&#xA;                &#x27;tds_tcs&#x27;, jvd.tds_tcs,&#xA;                &#x27;narration&#x27;, jvd.narration&#xA;            )&#xA;        ) AS details&#xA;    FROM&#xA;        public.journal_voucher_headers jvh&#xA;    LEFT JOIN&#xA;        public.journal_voucher_details jvd ON jvh.id = jvd.journal_header_id&#xA;    LEFT JOIN&#xA;        public.chart_of_accounts coa_header ON jvh.account_id = coa_header.id&#xA;    LEFT JOIN&#xA;        public.chart_of_accounts coa_credit ON jvd.credit_account_id = coa_credit.id&#xA;    LEFT JOIN&#xA;        public.chart_of_accounts coa_debit ON jvd.debit_account_id = coa_debit.id&#xA;    WHERE&#xA;        jvh.id = p_header_id&#xA;        AND jvh.is_deleted = FALSE&#xA;        AND (jvd.is_deleted = FALSE OR jvd.is_deleted IS NULL)&#xA;    GROUP BY&#xA;        jvh.id, coa_header.name;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_new_voucher_number</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-40')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-40">
                                            CREATE OR REPLACE FUNCTION public.get_new_voucher_number(p_company_id uuid, p_date date)&#xA; RETURNS character varying&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;&#x9;v_finance_year_id integer;&#xA;&#x9;v_voucher_prefix text;&#xA;&#x9;v_last_voucher_id integer;&#xA;&#x9;v_new_voucher_number character varying;&#xA;BEGIN&#xA;&#x9;-- Get the financial year ID based on the provided date&#xA;&#x9;SELECT id INTO v_finance_year_id&#xA;&#x9;FROM finance_year&#xA;&#x9;WHERE start_date &lt;= p_date AND end_date &gt;= p_date;&#xA;&#xA;&#x9;-- Try updating existing record&#xA;&#x9;WITH updated AS (&#xA;&#x9;&#x9;UPDATE public.journal_voucher_header_id&#xA;&#x9;&#x9;SET last_voucher_id = COALESCE(last_voucher_id, 0) &#x2B; 1&#xA;&#x9;&#x9;WHERE company_id = p_company_id AND fin_year = v_finance_year_id&#xA;&#x9;&#x9;RETURNING last_voucher_id, voucher_prefix&#xA;&#x9;),&#xA;&#x9;inserted AS (&#xA;&#x9;&#x9;INSERT INTO public.journal_voucher_header_id (&#xA;&#x9;&#x9;&#x9;company_id, fin_year, voucher_prefix, last_voucher_id&#xA;&#x9;&#x9;)&#xA;&#x9;&#x9;SELECT p_company_id, v_finance_year_id, &#x27;JV&#x27;, 1&#xA;&#x9;&#x9;WHERE NOT EXISTS (SELECT 1 FROM updated)&#xA;&#x9;&#x9;RETURNING last_voucher_id, voucher_prefix&#xA;&#x9;)&#xA;&#x9;SELECT &#xA;&#x9;&#x9;COALESCE((SELECT last_voucher_id FROM updated LIMIT 1), (SELECT last_voucher_id FROM inserted LIMIT 1)),&#xA;&#x9;&#x9;COALESCE((SELECT voucher_prefix FROM updated LIMIT 1), (SELECT voucher_prefix FROM inserted LIMIT 1))&#xA;&#x9;INTO v_last_voucher_id, v_voucher_prefix;&#xA;&#xA;&#x9;-- Generate the voucher number&#xA;&#x9;v_new_voucher_number := v_voucher_prefix || LPAD(v_last_voucher_id::text, 5, &#x27;0&#x27;);&#xA;&#xA;&#x9;RETURN v_new_voucher_number;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_new_voucher_number(p_company_id uuid, p_date date)&#xA; RETURNS character varying&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;&#x9;v_finance_year_id integer;&#xA;&#x9;v_voucher_prefix text;&#xA;&#x9;v_last_voucher_id integer;&#xA;&#x9;v_new_voucher_number character varying;&#xA;BEGIN&#xA;&#x9;-- Get the financial year ID based on the provided date&#xA;&#x9;SELECT id INTO v_finance_year_id&#xA;&#x9;FROM finance_year&#xA;&#x9;WHERE start_date &lt;= p_date AND end_date &gt;= p_date;&#xA;&#xA;&#x9;-- Try updating existing record&#xA;&#x9;WITH updated AS (&#xA;&#x9;&#x9;UPDATE public.journal_voucher_header_id&#xA;&#x9;&#x9;SET last_voucher_id = COALESCE(last_voucher_id, 0) &#x2B; 1&#xA;&#x9;&#x9;WHERE company_id = p_company_id AND fin_year = v_finance_year_id&#xA;&#x9;&#x9;RETURNING last_voucher_id, voucher_prefix&#xA;&#x9;),&#xA;&#x9;inserted AS (&#xA;&#x9;&#x9;INSERT INTO public.journal_voucher_header_id (&#xA;&#x9;&#x9;&#x9;company_id, fin_year, voucher_prefix, last_voucher_id&#xA;&#x9;&#x9;)&#xA;&#x9;&#x9;SELECT p_company_id, v_finance_year_id, &#x27;JV&#x27;, 1&#xA;&#x9;&#x9;WHERE NOT EXISTS (SELECT 1 FROM updated)&#xA;&#x9;&#x9;RETURNING last_voucher_id, voucher_prefix&#xA;&#x9;)&#xA;&#x9;SELECT &#xA;&#x9;&#x9;COALESCE((SELECT last_voucher_id FROM updated LIMIT 1), (SELECT last_voucher_id FROM inserted LIMIT 1)),&#xA;&#x9;&#x9;COALESCE((SELECT voucher_prefix FROM updated LIMIT 1), (SELECT voucher_prefix FROM inserted LIMIT 1))&#xA;&#x9;INTO v_last_voucher_id, v_voucher_prefix;&#xA;&#xA;&#x9;-- Generate the voucher number&#xA;&#x9;v_new_voucher_number := v_voucher_prefix || LPAD(v_last_voucher_id::text, 5, &#x27;0&#x27;);&#xA;&#xA;&#x9;RETURN v_new_voucher_number;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_opening_balances</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-41')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-41">
                                            CREATE OR REPLACE FUNCTION public.get_opening_balances(p_organization_id uuid, p_fin_year_id integer)&#xA; RETURNS TABLE(account_id uuid, balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;   RETURN QUERY&#xA;   SELECT &#xA;        ob.account_id,&#xA; &#x9;&#x9;SUM(&#xA;        CASE &#xA;            WHEN ob.entry_type = &#x27;D&#x27; THEN ob.balance &#xA;            ELSE -ob.balance&#xA;        END&#xA;        ) AS balance&#xA;    FROM public.opening_balances ob &#xA;    WHERE ob.organization_id = p_organization_id&#xA;      AND ob.finyear_id = p_fin_year_id&#xA;      AND ob.is_deleted = false&#xA;&#x9;group by ob.account_id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_opening_balances(p_organization_id uuid, p_fin_year_id integer)&#xA; RETURNS TABLE(account_id uuid, balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;   RETURN QUERY&#xA;   SELECT &#xA;        ob.account_id,&#xA; &#x9;&#x9;SUM(&#xA;        CASE &#xA;            WHEN ob.entry_type = &#x27;D&#x27; THEN ob.balance &#xA;            ELSE -ob.balance&#xA;        END&#xA;        ) AS balance&#xA;    FROM public.opening_balances ob &#xA;    WHERE ob.organization_id = p_organization_id&#xA;      AND ob.finyear_id = p_fin_year_id&#xA;      AND ob.is_deleted = false&#xA;&#x9;group by ob.account_id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_profit_loss_statement</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-42')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-42">
                                            CREATE OR REPLACE FUNCTION public.get_profit_loss_statement(p_company_id uuid, p_fin_year_id integer, p_is_get_for_organization boolean)&#xA; RETURNS TABLE(account_type text, account_name text, amount numeric, category text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date date;&#xA;    v_end_date date;&#xA;    v_company_ids UUID[];&#xA;&#x9;v_organization_id UUID;&#xA;    income_account_ids integer[];&#xA;    expense_account_ids integer[];&#xA;BEGIN&#xA;    -- Fetch account hierarchy for income and expense accounts&#xA;    income_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(4));&#xA;    expense_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(5));&#xA;&#xA;&#x9;select organization_id into v_organization_id &#xA;&#x9;from public.companies where id = p_company_id;&#xA;&#xA;    -- Get start and end date for financial year&#xA;    SELECT start_date::DATE, end_date::DATE&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year&#xA;    WHERE id = p_fin_year_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Populate company IDs based on the organization flag&#xA;    IF p_is_get_for_organization THEN&#xA;        SELECT ARRAY(&#xA;            SELECT id FROM companies &#xA;            WHERE organization_id = (SELECT organization_id FROM companies WHERE id = p_company_id)&#xA;        )&#xA;        INTO v_company_ids;&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    -- Return Income (Credit balances)&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;&#x9;&#x9;&#x9;SUM(&#xA;&#x9;&#x9;&#x9;&#x9;CASE&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE -ob.balance &#xA;&#x9;&#x9;&#x9;&#x9;END&#xA;&#x9;&#x9;&#x9;),0&#xA;&#x9;&#x9;) &#x2B;&#xA;       COALESCE(&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE -je.amount END), 0&#xA;        ) AS amount,&#xA;        &#x27;Income&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;&#x9;LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;&#x9;&#x9;AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_fin_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(income_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;    -- Return Expenses (Debit balances)&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;&#xA;        COALESCE(&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE -je.amount END), 0&#xA;        ) AS amount,&#xA;        &#x27;Expenses&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(expense_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_profit_loss_statement(p_company_id uuid, p_fin_year_id integer, p_is_get_for_organization boolean)&#xA; RETURNS TABLE(account_type text, account_name text, amount numeric, category text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date date;&#xA;    v_end_date date;&#xA;    v_company_ids UUID[];&#xA;&#x9;v_organization_id UUID;&#xA;    income_account_ids integer[];&#xA;    expense_account_ids integer[];&#xA;BEGIN&#xA;    -- Fetch account hierarchy for income and expense accounts&#xA;    income_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(4));&#xA;    expense_account_ids := ARRAY(SELECT id FROM get_account_type_hierarchy(5));&#xA;&#xA;&#x9;select organization_id into v_organization_id &#xA;&#x9;from public.companies where id = p_company_id;&#xA;&#xA;    -- Get start and end date for financial year&#xA;    SELECT start_date::DATE, end_date::DATE&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year&#xA;    WHERE id = p_fin_year_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Populate company IDs based on the organization flag&#xA;    IF p_is_get_for_organization THEN&#xA;        SELECT ARRAY(&#xA;            SELECT id FROM companies &#xA;            WHERE organization_id = (SELECT organization_id FROM companies WHERE id = p_company_id)&#xA;        )&#xA;        INTO v_company_ids;&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    -- Return Income (Credit balances)&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;COALESCE(&#xA;&#x9;&#x9;&#x9;SUM(&#xA;&#x9;&#x9;&#x9;&#x9;CASE&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE -ob.balance &#xA;&#x9;&#x9;&#x9;&#x9;END&#xA;&#x9;&#x9;&#x9;),0&#xA;&#x9;&#x9;) &#x2B;&#xA;       COALESCE(&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE -je.amount END), 0&#xA;        ) AS amount,&#xA;        &#x27;Income&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;&#x9;LEFT JOIN public.opening_balances ob ON ob.account_id = coa.id&#xA;&#x9;&#x9;AND ob.organization_id = v_organization_id&#xA;        AND ob.finyear_id = p_fin_year_id&#xA;        AND ob.is_deleted = FALSE&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(income_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;&#xA;    -- Return Expenses (Debit balances)&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        coa.name AS account_name,&#xA;&#x9;&#x9;&#xA;        COALESCE(&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE -je.amount END), 0&#xA;        ) AS amount,&#xA;        &#x27;Expenses&#x27; AS category&#xA;    FROM public.chart_of_accounts coa&#xA;    INNER JOIN public.journal_entries je ON je.account_id = coa.id&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    WHERE th.company_id = ANY(v_company_ids)&#xA;        AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        AND NOT th.is_deleted&#xA;        AND NOT je.is_deleted&#xA;        AND coa.account_type_id = ANY(expense_account_ids)&#xA;    GROUP BY at.name, coa.name, coa.account_number, at.id&#xA;    ORDER BY coa.account_number, at.id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_sundry_creditors_ledger</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-43')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-43">
                                            CREATE OR REPLACE FUNCTION public.get_sundry_creditors_ledger(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(sl_no integer, ledger text, general_ledger text, opening_balance numeric, debit numeric, credit numeric, closing_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;BEGIN&#xA;    -- Get financial year start and end date if not provided&#xA;    SELECT fy.start_date, fy.end_date &#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_fin_year_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Override with provided values if they are not NULL&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;    RETURN QUERY&#xA;    SELECT ROW_NUMBER() OVER()::INTEGER AS sl_no,&#xA;        v.name::TEXT AS ledger,&#xA;        &#x27;Sundry Creditors&#x27;::TEXT AS general_ledger,&#xA;        0::NUMERIC AS opening_balance, &#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount -- Credit increases liability balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS credit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount -- Debit decreases liability balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS debit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) -&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS closing_balance&#xA;    FROM public.journal_entries je &#xA;    JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN public.vendors v ON th.vendor_id = v.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;    GROUP BY v.name&#xA;    ORDER BY v.name;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_sundry_creditors_ledger(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(sl_no integer, ledger text, general_ledger text, opening_balance numeric, debit numeric, credit numeric, closing_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;BEGIN&#xA;    -- Get financial year start and end date if not provided&#xA;    SELECT fy.start_date, fy.end_date &#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_fin_year_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Override with provided values if they are not NULL&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;    RETURN QUERY&#xA;    SELECT ROW_NUMBER() OVER()::INTEGER AS sl_no,&#xA;        v.name::TEXT AS ledger,&#xA;        &#x27;Sundry Creditors&#x27;::TEXT AS general_ledger,&#xA;        0::NUMERIC AS opening_balance, &#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount -- Credit increases liability balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS credit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount -- Debit decreases liability balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS debit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) -&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS closing_balance&#xA;    FROM public.journal_entries je &#xA;    JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN public.vendors v ON th.vendor_id = v.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;    GROUP BY v.name&#xA;    ORDER BY v.name;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_sundry_debtors_ledger</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-44')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-44">
                                            CREATE OR REPLACE FUNCTION public.get_sundry_debtors_ledger(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(sl_no integer, ledger text, general_ledger text, opening_balance numeric, debit numeric, credit numeric, closing_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;BEGIN&#xA;    -- Get financial year start and end date if not provided&#xA;    SELECT fy.start_date, fy.end_date &#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_fin_year_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Override with provided values if they are not NULL&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;    RETURN QUERY&#xA;    SELECT ROW_NUMBER() OVER()::INTEGER AS sl_no,&#xA;        cu.name::TEXT AS ledger,&#xA;        &#x27;Sundry Debtors&#x27;::TEXT AS general_ledger,&#xA;        0::NUMERIC AS opening_balance, &#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount -- Debit increases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS debit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount -- Credit decreases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS credit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount -- Credit decreases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) -&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount -- Debit increases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS closing_balance&#xA;    FROM public.journal_entries je &#xA;    JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN public.customers cu ON th.customer_id = cu.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;    GROUP BY cu.name&#xA;    ORDER BY cu.name;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_sundry_debtors_ledger(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(sl_no integer, ledger text, general_ledger text, opening_balance numeric, debit numeric, credit numeric, closing_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;BEGIN&#xA;    -- Get financial year start and end date if not provided&#xA;    SELECT fy.start_date, fy.end_date &#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_fin_year_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Override with provided values if they are not NULL&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;    RETURN QUERY&#xA;    SELECT ROW_NUMBER() OVER()::INTEGER AS sl_no,&#xA;        cu.name::TEXT AS ledger,&#xA;        &#x27;Sundry Debtors&#x27;::TEXT AS general_ledger,&#xA;        0::NUMERIC AS opening_balance, &#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount -- Debit increases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS debit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount -- Credit decreases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS credit,&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount -- Credit decreases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) -&#xA;        COALESCE(&#xA;            SUM(CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount -- Debit increases asset balance&#xA;                ELSE 0 &#xA;            END), 0&#xA;        ) AS closing_balance&#xA;    FROM public.journal_entries je &#xA;    JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN public.customers cu ON th.customer_id = cu.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;    GROUP BY cu.name&#xA;    ORDER BY cu.name;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_three_years_expenses</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-45')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-45">
                                            CREATE OR REPLACE FUNCTION public.get_three_years_expenses(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(id uuid, financial_year_range text, account_name text, y1_apr numeric, y1_may numeric, y1_jun numeric, y1_jul numeric, y1_aug numeric, y1_sep numeric, y1_oct numeric, y1_nov numeric, y1_dec numeric, y1_jan numeric, y1_feb numeric, y1_mar numeric, y2_apr numeric, y2_may numeric, y2_jun numeric, y2_jul numeric, y2_aug numeric, y2_sep numeric, y2_oct numeric, y2_nov numeric, y2_dec numeric, y2_jan numeric, y2_feb numeric, y2_mar numeric, y3_apr numeric, y3_may numeric, y3_jun numeric, y3_jul numeric, y3_aug numeric, y3_sep numeric, y3_oct numeric, y3_nov numeric, y3_dec numeric, y3_jan numeric, y3_feb numeric, y3_mar numeric)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;&#xA;DECLARE&#xA;    current_year_start DATE;&#xA;    current_year_end DATE;&#xA;    previous_year1_start DATE;&#xA;    previous_year1_end DATE;&#xA;    previous_year2_start DATE;&#xA;    previous_year2_end DATE;&#xA;    CONST_EXPENSE_TYPE_ID INTEGER := 5;&#xA;BEGIN&#xA;    -- Fetch the start and end dates for the current financial year&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO current_year_start, current_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Validate financial year existence&#xA;    IF current_year_start IS NULL OR current_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Fetch the previous financial year&#x27;s start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO previous_year1_start, previous_year1_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.end_date &lt; current_year_start&#xA;    ORDER BY fy.end_date DESC&#xA;    LIMIT 1;&#xA;&#xA;    -- Fetch the year before the previous financial year&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO previous_year2_start, previous_year2_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.end_date &lt; previous_year1_start&#xA;    ORDER BY fy.end_date DESC&#xA;    LIMIT 1;&#xA;&#xA;    -- Generate financial year range dynamically&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE AccountHierarchy AS (&#xA;        -- Base case: Select root accounts (account_type_id = 5 indicates expense accounts)&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.parent_account_id&#xA;        FROM public.chart_of_accounts coa&#xA;        WHERE coa.account_type_id = CONST_EXPENSE_TYPE_ID&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Select all child accounts recursively under the root accounts&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.parent_account_id&#xA;        FROM public.chart_of_accounts coa&#xA;        INNER JOIN AccountHierarchy ah ON coa.parent_account_id = ah.account_id&#xA;    ),&#xA;    MonthlyExpenses AS (&#xA;        SELECT &#xA;            ah.name AS account_name,&#xA;            TO_CHAR(je.transaction_date, &#x27;MM&#x27;) AS transaction_month,&#xA;            CASE&#xA;                WHEN je.transaction_date BETWEEN previous_year2_start AND previous_year1_start - INTERVAL &#x27;1 day&#x27; THEN &#x27;y1&#x27;&#xA;                WHEN je.transaction_date BETWEEN previous_year1_start AND current_year_start - INTERVAL &#x27;1 day&#x27; THEN &#x27;y2&#x27;&#xA;                WHEN je.transaction_date BETWEEN current_year_start AND current_year_end THEN &#x27;y3&#x27;&#xA;            END AS year_group,&#xA;            SUM(je.amount) AS monthly_amount&#xA;        FROM AccountHierarchy ah&#xA;        LEFT JOIN public.journal_entries je ON je.account_id = ah.account_id&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;          AND je.transaction_date BETWEEN previous_year2_start AND current_year_end&#xA;          AND je.is_deleted = FALSE&#xA;        GROUP BY ah.name, year_group, TO_CHAR(je.transaction_date, &#x27;MM&#x27;)&#xA;    ),&#xA;    AggregatedExpenses AS (&#xA;        SELECT &#xA;            me.account_name,&#xA;            -- Populate y1 values&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;04&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_apr,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;05&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_may,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;06&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_jun,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;07&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_jul,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;08&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_aug,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;09&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_sep,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;10&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_oct,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;11&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_nov,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;12&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_dec,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;01&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_jan,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;02&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_feb,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;03&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_mar,&#xA;            -- Similarly populate y2 and y3 values&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;04&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_apr,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;05&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_may,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;06&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_jun,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;07&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_jul,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;08&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_aug,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;09&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_sep,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;10&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_oct,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;11&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_nov,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;12&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_dec,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;01&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_jan,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;02&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_feb,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;03&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_mar,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;04&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_apr,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;05&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_may,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;06&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_jun,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;07&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_jul,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;08&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_aug,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;09&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_sep,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;10&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_oct,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;11&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_nov,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;12&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_dec,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;01&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_jan,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;02&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_feb,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;03&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_mar&#xA;        FROM MonthlyExpenses me&#xA;        GROUP BY me.account_name&#xA;    )&#xA;    SELECT &#xA;        gen_random_uuid() AS id,&#xA;        CONCAT(EXTRACT(YEAR FROM previous_year2_start), &#x27;-&#x27;, EXTRACT(YEAR FROM current_year_end)) AS financial_year_range,&#xA;        ae.account_name,&#xA;        ae.y1_apr, ae.y1_may, ae.y1_jun, ae.y1_jul, ae.y1_aug, ae.y1_sep, ae.y1_oct, ae.y1_nov, ae.y1_dec, ae.y1_jan, ae.y1_feb, ae.y1_mar,&#xA;        ae.y2_apr, ae.y2_may, ae.y2_jun, ae.y2_jul, ae.y2_aug, ae.y2_sep, ae.y2_oct, ae.y2_nov, ae.y2_dec, ae.y2_jan, ae.y2_feb, ae.y2_mar,&#xA;        ae.y3_apr, ae.y3_may, ae.y3_jun, ae.y3_jul, ae.y3_aug, ae.y3_sep, ae.y3_oct, ae.y3_nov, ae.y3_dec, ae.y3_jan, ae.y3_feb, ae.y3_mar&#xA;    FROM AggregatedExpenses ae&#xA;    ORDER BY&#xA;        COALESCE(ae.y1_apr, 0) &#x2B; COALESCE(ae.y1_may, 0) &#x2B; COALESCE(ae.y1_jun, 0) &#x2B; COALESCE(ae.y1_jul, 0) &#x2B;&#xA;        COALESCE(ae.y1_aug, 0) &#x2B; COALESCE(ae.y1_sep, 0) &#x2B; COALESCE(ae.y1_oct, 0) &#x2B; COALESCE(ae.y1_nov, 0) &#x2B;&#xA;        COALESCE(ae.y1_dec, 0) &#x2B; COALESCE(ae.y1_jan, 0) &#x2B; COALESCE(ae.y1_feb, 0) &#x2B; COALESCE(ae.y1_mar, 0) &#x2B;&#xA;        COALESCE(ae.y2_apr, 0) &#x2B; COALESCE(ae.y2_may, 0) &#x2B; COALESCE(ae.y2_jun, 0) &#x2B; COALESCE(ae.y2_jul, 0) &#x2B;&#xA;        COALESCE(ae.y2_aug, 0) &#x2B; COALESCE(ae.y2_sep, 0) &#x2B; COALESCE(ae.y2_oct, 0) &#x2B; COALESCE(ae.y2_nov, 0) &#x2B;&#xA;        COALESCE(ae.y2_dec, 0) &#x2B; COALESCE(ae.y2_jan, 0) &#x2B; COALESCE(ae.y2_feb, 0) &#x2B; COALESCE(ae.y2_mar, 0) &#x2B;&#xA;        COALESCE(ae.y3_apr, 0) &#x2B; COALESCE(ae.y3_may, 0) &#x2B; COALESCE(ae.y3_jun, 0) &#x2B; COALESCE(ae.y3_jul, 0) &#x2B;&#xA;        COALESCE(ae.y3_aug, 0) &#x2B; COALESCE(ae.y3_sep, 0) &#x2B; COALESCE(ae.y3_oct, 0) &#x2B; COALESCE(ae.y3_nov, 0) &#x2B;&#xA;        COALESCE(ae.y3_dec, 0) &#x2B; COALESCE(ae.y3_jan, 0) &#x2B; COALESCE(ae.y3_feb, 0) &#x2B; COALESCE(ae.y3_mar, 0) DESC&#xA;    LIMIT 12;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_three_years_expenses(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(id uuid, financial_year_range text, account_name text, y1_apr numeric, y1_may numeric, y1_jun numeric, y1_jul numeric, y1_aug numeric, y1_sep numeric, y1_oct numeric, y1_nov numeric, y1_dec numeric, y1_jan numeric, y1_feb numeric, y1_mar numeric, y2_apr numeric, y2_may numeric, y2_jun numeric, y2_jul numeric, y2_aug numeric, y2_sep numeric, y2_oct numeric, y2_nov numeric, y2_dec numeric, y2_jan numeric, y2_feb numeric, y2_mar numeric, y3_apr numeric, y3_may numeric, y3_jun numeric, y3_jul numeric, y3_aug numeric, y3_sep numeric, y3_oct numeric, y3_nov numeric, y3_dec numeric, y3_jan numeric, y3_feb numeric, y3_mar numeric)&#xA; LANGUAGE plpgsql&#xA; STABLE PARALLEL SAFE&#xA;AS $function$&#xA;&#xA;DECLARE&#xA;    current_year_start DATE;&#xA;    current_year_end DATE;&#xA;    previous_year1_start DATE;&#xA;    previous_year1_end DATE;&#xA;    previous_year2_start DATE;&#xA;    previous_year2_end DATE;&#xA;    CONST_EXPENSE_TYPE_ID INTEGER := 5;&#xA;BEGIN&#xA;    -- Fetch the start and end dates for the current financial year&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO current_year_start, current_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_year_id;&#xA;&#xA;    -- Validate financial year existence&#xA;    IF current_year_start IS NULL OR current_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Fetch the previous financial year&#x27;s start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO previous_year1_start, previous_year1_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.end_date &lt; current_year_start&#xA;    ORDER BY fy.end_date DESC&#xA;    LIMIT 1;&#xA;&#xA;    -- Fetch the year before the previous financial year&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO previous_year2_start, previous_year2_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.end_date &lt; previous_year1_start&#xA;    ORDER BY fy.end_date DESC&#xA;    LIMIT 1;&#xA;&#xA;    -- Generate financial year range dynamically&#xA;    RETURN QUERY&#xA;    WITH RECURSIVE AccountHierarchy AS (&#xA;        -- Base case: Select root accounts (account_type_id = 5 indicates expense accounts)&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.parent_account_id&#xA;        FROM public.chart_of_accounts coa&#xA;        WHERE coa.account_type_id = CONST_EXPENSE_TYPE_ID&#xA;&#xA;        UNION ALL&#xA;&#xA;        -- Select all child accounts recursively under the root accounts&#xA;        SELECT &#xA;            coa.id AS account_id,&#xA;            coa.name,&#xA;            coa.parent_account_id&#xA;        FROM public.chart_of_accounts coa&#xA;        INNER JOIN AccountHierarchy ah ON coa.parent_account_id = ah.account_id&#xA;    ),&#xA;    MonthlyExpenses AS (&#xA;        SELECT &#xA;            ah.name AS account_name,&#xA;            TO_CHAR(je.transaction_date, &#x27;MM&#x27;) AS transaction_month,&#xA;            CASE&#xA;                WHEN je.transaction_date BETWEEN previous_year2_start AND previous_year1_start - INTERVAL &#x27;1 day&#x27; THEN &#x27;y1&#x27;&#xA;                WHEN je.transaction_date BETWEEN previous_year1_start AND current_year_start - INTERVAL &#x27;1 day&#x27; THEN &#x27;y2&#x27;&#xA;                WHEN je.transaction_date BETWEEN current_year_start AND current_year_end THEN &#x27;y3&#x27;&#xA;            END AS year_group,&#xA;            SUM(je.amount) AS monthly_amount&#xA;        FROM AccountHierarchy ah&#xA;        LEFT JOIN public.journal_entries je ON je.account_id = ah.account_id&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;          AND je.transaction_date BETWEEN previous_year2_start AND current_year_end&#xA;          AND je.is_deleted = FALSE&#xA;        GROUP BY ah.name, year_group, TO_CHAR(je.transaction_date, &#x27;MM&#x27;)&#xA;    ),&#xA;    AggregatedExpenses AS (&#xA;        SELECT &#xA;            me.account_name,&#xA;            -- Populate y1 values&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;04&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_apr,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;05&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_may,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;06&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_jun,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;07&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_jul,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;08&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_aug,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;09&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_sep,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;10&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_oct,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;11&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_nov,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;12&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_dec,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;01&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_jan,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;02&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_feb,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y1&#x27; AND me.transaction_month = &#x27;03&#x27; THEN me.monthly_amount ELSE 0 END) AS y1_mar,&#xA;            -- Similarly populate y2 and y3 values&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;04&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_apr,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;05&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_may,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;06&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_jun,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;07&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_jul,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;08&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_aug,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;09&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_sep,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;10&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_oct,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;11&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_nov,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;12&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_dec,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;01&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_jan,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;02&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_feb,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y2&#x27; AND me.transaction_month = &#x27;03&#x27; THEN me.monthly_amount ELSE 0 END) AS y2_mar,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;04&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_apr,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;05&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_may,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;06&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_jun,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;07&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_jul,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;08&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_aug,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;09&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_sep,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;10&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_oct,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;11&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_nov,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;12&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_dec,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;01&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_jan,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;02&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_feb,&#xA;            SUM(CASE WHEN me.year_group = &#x27;y3&#x27; AND me.transaction_month = &#x27;03&#x27; THEN me.monthly_amount ELSE 0 END) AS y3_mar&#xA;        FROM MonthlyExpenses me&#xA;        GROUP BY me.account_name&#xA;    )&#xA;    SELECT &#xA;        gen_random_uuid() AS id,&#xA;        CONCAT(EXTRACT(YEAR FROM previous_year2_start), &#x27;-&#x27;, EXTRACT(YEAR FROM current_year_end)) AS financial_year_range,&#xA;        ae.account_name,&#xA;        ae.y1_apr, ae.y1_may, ae.y1_jun, ae.y1_jul, ae.y1_aug, ae.y1_sep, ae.y1_oct, ae.y1_nov, ae.y1_dec, ae.y1_jan, ae.y1_feb, ae.y1_mar,&#xA;        ae.y2_apr, ae.y2_may, ae.y2_jun, ae.y2_jul, ae.y2_aug, ae.y2_sep, ae.y2_oct, ae.y2_nov, ae.y2_dec, ae.y2_jan, ae.y2_feb, ae.y2_mar,&#xA;        ae.y3_apr, ae.y3_may, ae.y3_jun, ae.y3_jul, ae.y3_aug, ae.y3_sep, ae.y3_oct, ae.y3_nov, ae.y3_dec, ae.y3_jan, ae.y3_feb, ae.y3_mar&#xA;    FROM AggregatedExpenses ae&#xA;    ORDER BY&#xA;        COALESCE(ae.y1_apr, 0) &#x2B; COALESCE(ae.y1_may, 0) &#x2B; COALESCE(ae.y1_jun, 0) &#x2B; COALESCE(ae.y1_jul, 0) &#x2B;&#xA;        COALESCE(ae.y1_aug, 0) &#x2B; COALESCE(ae.y1_sep, 0) &#x2B; COALESCE(ae.y1_oct, 0) &#x2B; COALESCE(ae.y1_nov, 0) &#x2B;&#xA;        COALESCE(ae.y1_dec, 0) &#x2B; COALESCE(ae.y1_jan, 0) &#x2B; COALESCE(ae.y1_feb, 0) &#x2B; COALESCE(ae.y1_mar, 0) &#x2B;&#xA;        COALESCE(ae.y2_apr, 0) &#x2B; COALESCE(ae.y2_may, 0) &#x2B; COALESCE(ae.y2_jun, 0) &#x2B; COALESCE(ae.y2_jul, 0) &#x2B;&#xA;        COALESCE(ae.y2_aug, 0) &#x2B; COALESCE(ae.y2_sep, 0) &#x2B; COALESCE(ae.y2_oct, 0) &#x2B; COALESCE(ae.y2_nov, 0) &#x2B;&#xA;        COALESCE(ae.y2_dec, 0) &#x2B; COALESCE(ae.y2_jan, 0) &#x2B; COALESCE(ae.y2_feb, 0) &#x2B; COALESCE(ae.y2_mar, 0) &#x2B;&#xA;        COALESCE(ae.y3_apr, 0) &#x2B; COALESCE(ae.y3_may, 0) &#x2B; COALESCE(ae.y3_jun, 0) &#x2B; COALESCE(ae.y3_jul, 0) &#x2B;&#xA;        COALESCE(ae.y3_aug, 0) &#x2B; COALESCE(ae.y3_sep, 0) &#x2B; COALESCE(ae.y3_oct, 0) &#x2B; COALESCE(ae.y3_nov, 0) &#x2B;&#xA;        COALESCE(ae.y3_dec, 0) &#x2B; COALESCE(ae.y3_jan, 0) &#x2B; COALESCE(ae.y3_feb, 0) &#x2B; COALESCE(ae.y3_mar, 0) DESC&#xA;    LIMIT 12;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_trial_balance_net</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-46')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-46">
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_net(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_type text, account_category text, account_number text, account_name text, balance numeric, balance_type text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH financial_year_range AS (&#xA;        SELECT&#xA;            fy.start_date::DATE AS start_date,&#xA;            fy.end_date::DATE AS end_date&#xA;        FROM&#xA;            public.finance_year fy&#xA;        WHERE&#xA;            fy.id = p_finance_year_id&#xA;        LIMIT 1&#xA;    ),&#xA;    account_balances AS (&#xA;        SELECT&#xA;            je.account_id,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS total_debits,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS total_credits&#xA;        FROM&#xA;            public.journal_entries je&#xA;        JOIN&#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        CROSS JOIN&#xA;            financial_year_range fy&#xA;        WHERE&#xA;            th.company_id = p_company_id&#xA;            AND je.is_deleted = FALSE&#xA;            AND th.transaction_date BETWEEN fy.start_date AND fy.end_date&#xA;        GROUP BY&#xA;            je.account_id&#xA;    )&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        ac.name AS account_category,&#xA;        coa.account_number,&#xA;        coa.name AS account_name,&#xA;        (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) AS balance,&#xA;        CASE&#xA;            WHEN (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) &gt; 0 THEN &#x27;Debit&#x27;&#xA;            WHEN (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) &lt; 0 THEN &#x27;Credit&#x27;&#xA;            ELSE &#x27;&#x27;&#xA;        END AS balance_type&#xA;    FROM&#xA;        public.chart_of_accounts coa&#xA;    INNER JOIN&#xA;        public.account_types at ON coa.account_type_id = at.id&#xA;    LEFT JOIN&#xA;        public.account_categories ac ON at.account_category_id = ac.id&#xA;    LEFT JOIN&#xA;        account_balances ab ON coa.id = ab.account_id&#xA;    WHERE&#xA;        coa.organization_id = p_company_id&#xA;        AND coa.is_deleted = FALSE&#xA;        AND (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) &lt;&gt; 0 -- Only show accounts with a non-zero balance&#xA;    ORDER BY&#xA;        coa.account_number;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_net(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_type text, account_category text, account_number text, account_name text, balance numeric, balance_type text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    WITH financial_year_range AS (&#xA;        SELECT&#xA;            fy.start_date::DATE AS start_date,&#xA;            fy.end_date::DATE AS end_date&#xA;        FROM&#xA;            public.finance_year fy&#xA;        WHERE&#xA;            fy.id = p_finance_year_id&#xA;        LIMIT 1&#xA;    ),&#xA;    account_balances AS (&#xA;        SELECT&#xA;            je.account_id,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS total_debits,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS total_credits&#xA;        FROM&#xA;            public.journal_entries je&#xA;        JOIN&#xA;            public.transaction_headers th ON je.transaction_id = th.id&#xA;        CROSS JOIN&#xA;            financial_year_range fy&#xA;        WHERE&#xA;            th.company_id = p_company_id&#xA;            AND je.is_deleted = FALSE&#xA;            AND th.transaction_date BETWEEN fy.start_date AND fy.end_date&#xA;        GROUP BY&#xA;            je.account_id&#xA;    )&#xA;    SELECT&#xA;        at.name AS account_type,&#xA;        ac.name AS account_category,&#xA;        coa.account_number,&#xA;        coa.name AS account_name,&#xA;        (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) AS balance,&#xA;        CASE&#xA;            WHEN (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) &gt; 0 THEN &#x27;Debit&#x27;&#xA;            WHEN (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) &lt; 0 THEN &#x27;Credit&#x27;&#xA;            ELSE &#x27;&#x27;&#xA;        END AS balance_type&#xA;    FROM&#xA;        public.chart_of_accounts coa&#xA;    INNER JOIN&#xA;        public.account_types at ON coa.account_type_id = at.id&#xA;    LEFT JOIN&#xA;        public.account_categories ac ON at.account_category_id = ac.id&#xA;    LEFT JOIN&#xA;        account_balances ab ON coa.id = ab.account_id&#xA;    WHERE&#xA;        coa.organization_id = p_company_id&#xA;        AND coa.is_deleted = FALSE&#xA;        AND (COALESCE(ab.total_debits, 0) - COALESCE(ab.total_credits, 0)) &lt;&gt; 0 -- Only show accounts with a non-zero balance&#xA;    ORDER BY&#xA;        coa.account_number;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_top_expense_categories</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-47')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-47">
                                            CREATE OR REPLACE FUNCTION public.get_top_expense_categories(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_id uuid, account_name text, account_number text, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;BEGIN&#xA;    -- Fetch financial year start and end dates&#xA;    SELECT start_date, end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_year_id;&#xA;&#xA;    -- Raise an exception if financial year is not found&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Calculate and return top 10 Expense accounts using `get_account_type_hierarchy(5)`&#xA;    RETURN QUERY&#xA;    SELECT &#xA;&#x9;&#x9;coa.id As account_id,&#xA;        coa.name AS account_name,&#xA;        coa.account_number AS account_number,&#xA;        ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    WHERE at.id IN (SELECT id FROM get_account_type_hierarchy(5)) -- Dynamically fetch all expense types&#xA;      AND th.company_id = p_company_id&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE&#xA;    GROUP BY coa.id, coa.name, coa.account_number&#xA;    ORDER BY total_expense DESC&#xA;    LIMIT 10;&#xA;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_top_expense_categories(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(account_id uuid, account_name text, account_number text, total_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;BEGIN&#xA;    -- Fetch financial year start and end dates&#xA;    SELECT start_date, end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_year_id;&#xA;&#xA;    -- Raise an exception if financial year is not found&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Calculate and return top 10 Expense accounts using `get_account_type_hierarchy(5)`&#xA;    RETURN QUERY&#xA;    SELECT &#xA;&#x9;&#x9;coa.id As account_id,&#xA;        coa.name AS account_name,&#xA;        coa.account_number AS account_number,&#xA;        ROUND(COALESCE(SUM(je.amount), 0), 2) AS total_expense&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    INNER JOIN public.account_types at ON coa.account_type_id = at.id&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    WHERE at.id IN (SELECT id FROM get_account_type_hierarchy(5)) -- Dynamically fetch all expense types&#xA;      AND th.company_id = p_company_id&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE&#xA;    GROUP BY coa.id, coa.name, coa.account_number&#xA;    ORDER BY total_expense DESC&#xA;    LIMIT 10;&#xA;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_total_expense</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-48')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-48">
                                            CREATE OR REPLACE FUNCTION public.get_total_expense(p_company_id uuid, p_finance_id integer)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_expense NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Validate if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total expense&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_expense&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE&#xA;      AND EXISTS (&#xA;          SELECT 1&#xA;          FROM public.account_types at&#xA;          WHERE at.id = coa.account_type_id&#xA;            AND at.account_category_id = 5 -- Expense category&#xA;      );&#xA;&#xA;    -- Step 6: Return the total expense&#xA;    RETURN v_total_expense;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_total_expense(p_company_id uuid, p_finance_id integer)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_expense NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Validate if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total expense&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_expense&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE&#xA;      AND EXISTS (&#xA;          SELECT 1&#xA;          FROM public.account_types at&#xA;          WHERE at.id = coa.account_type_id&#xA;            AND at.account_category_id = 5 -- Expense category&#xA;      );&#xA;&#xA;    -- Step 6: Return the total expense&#xA;    RETURN v_total_expense;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_total_income</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-49')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-49">
                                            CREATE OR REPLACE FUNCTION public.get_total_income(p_company_id uuid, p_finance_id integer)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_income NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Validate if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total income&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_income&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE&#xA;      AND EXISTS (&#xA;          SELECT 1&#xA;          FROM public.account_types at&#xA;          WHERE at.id = coa.account_type_id&#xA;            AND at.account_category_id = 4 -- Income/Revenue category&#xA;      );&#xA;&#xA;    -- Step 6: Return the total income&#xA;    RETURN v_total_income;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_total_income(p_company_id uuid, p_finance_id integer)&#xA; RETURNS numeric&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_total_income NUMERIC := 0;&#xA;    v_organization_id UUID;&#xA;BEGIN&#xA;    -- Step 1: Get the organization ID for the given company&#xA;    SELECT organization_id &#xA;    INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    -- Step 2: Validate if the organization ID exists&#xA;    IF v_organization_id IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Organization ID not found for company ID %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Step 3: Get the financial year start and end dates&#xA;    SELECT fy.start_date, fy.end_date&#xA;    INTO v_financial_year_start, v_financial_year_end&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_finance_id;&#xA;&#xA;    -- Step 4: Validate if the financial year exists&#xA;    IF v_financial_year_start IS NULL OR v_financial_year_end IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year with ID % not found&#x27;, p_finance_id;&#xA;    END IF;&#xA;&#xA;    -- Step 5: Calculate the total income&#xA;    SELECT COALESCE(SUM(je.amount), 0) INTO v_total_income&#xA;    FROM public.journal_entries je&#xA;    INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;    INNER JOIN public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    WHERE th.company_id = p_company_id&#xA;      AND coa.organization_id = v_organization_id -- Match organization ID&#xA;      AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;      AND je.is_deleted = FALSE&#xA;      AND EXISTS (&#xA;          SELECT 1&#xA;          FROM public.account_types at&#xA;          WHERE at.id = coa.account_type_id&#xA;            AND at.account_category_id = 4 -- Income/Revenue category&#xA;      );&#xA;&#xA;    -- Step 6: Return the total income&#xA;    RETURN v_total_income;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_trial_balance_by_date_range</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-50')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-50">
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_by_date_range(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_is_get_for_organization boolean DEFAULT false)&#xA; RETURNS TABLE(account_type text, account_number text, account_name text, opening_balance numeric, debit numeric, credit numeric, closing_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_organization_id UUID;&#xA;    v_company_ids UUID[];&#xA;BEGIN&#xA;    -- Fetch the organization ID from the company ID&#xA;    SELECT organization_id INTO v_organization_id&#xA;    FROM public.companies &#xA;    WHERE id = p_company_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Get financial year start and end dates&#xA;    SELECT start_date, end_date&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.get_financial_year_dates(p_fin_year_id);&#xA;&#xA;    -- Override with provided values if not NULL&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;    -- Determine whether to fetch for all companies in the organization&#xA;    IF p_is_get_for_organization THEN&#xA;        SELECT ARRAY_AGG(id)&#xA;        INTO v_company_ids&#xA;        FROM public.companies&#xA;        WHERE organization_id = v_organization_id;&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    RETURN QUERY&#xA;    WITH coa_hierarchy AS (&#xA;        SELECT * FROM public.get_chart_of_accounts_hierarchy(v_organization_id)&#xA;    ),&#xA;    opening_balances AS (&#xA;        SELECT * FROM public.get_opening_balances(v_organization_id, p_fin_year_id)&#xA;    ),&#xA;    journal_entries_filtered AS (&#xA;        SELECT je.account_id,&#xA;        SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS debit,&#xA;        SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS credit&#xA;        FROM public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = ANY(v_company_ids)&#xA;          AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        GROUP BY je.account_id&#xA;    )&#xA;    SELECT &#xA;        ch.account_type,&#xA;        ch.account_number,&#xA;        ch.account_name,&#xA;        COALESCE(ob.balance, 0) AS opening_balance, &#xA;        COALESCE(jf.debit, 0) AS debit,&#xA;        COALESCE(jf.credit, 0) AS credit,&#xA;        (COALESCE(ob.balance, 0) &#x2B; COALESCE(jf.debit, 0) - COALESCE(jf.credit, 0)) AS closing_balance&#xA;    FROM coa_hierarchy ch&#xA;    LEFT JOIN opening_balances ob ON ch.id = ob.account_id&#xA;    LEFT JOIN journal_entries_filtered jf ON ch.id = jf.account_id&#xA;    ORDER BY ch.account_number;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_trial_balance_by_date_range(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_is_get_for_organization boolean DEFAULT false)&#xA; RETURNS TABLE(account_type text, account_number text, account_name text, opening_balance numeric, debit numeric, credit numeric, closing_balance numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;    v_organization_id UUID;&#xA;    v_company_ids UUID[];&#xA;BEGIN&#xA;    -- Fetch the organization ID from the company ID&#xA;    SELECT organization_id INTO v_organization_id&#xA;    FROM public.companies &#xA;    WHERE id = p_company_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Get financial year start and end dates&#xA;    SELECT start_date, end_date&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.get_financial_year_dates(p_fin_year_id);&#xA;&#xA;    -- Override with provided values if not NULL&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;    -- Determine whether to fetch for all companies in the organization&#xA;    IF p_is_get_for_organization THEN&#xA;        SELECT ARRAY_AGG(id)&#xA;        INTO v_company_ids&#xA;        FROM public.companies&#xA;        WHERE organization_id = v_organization_id;&#xA;    ELSE&#xA;        v_company_ids := ARRAY[p_company_id];&#xA;    END IF;&#xA;&#xA;    RETURN QUERY&#xA;    WITH coa_hierarchy AS (&#xA;        SELECT * FROM public.get_chart_of_accounts_hierarchy(v_organization_id)&#xA;    ),&#xA;    opening_balances AS (&#xA;        SELECT * FROM public.get_opening_balances(v_organization_id, p_fin_year_id)&#xA;    ),&#xA;    journal_entries_filtered AS (&#xA;        SELECT je.account_id,&#xA;        SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) AS debit,&#xA;        SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) AS credit&#xA;        FROM public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = ANY(v_company_ids)&#xA;          AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xA;        GROUP BY je.account_id&#xA;    )&#xA;    SELECT &#xA;        ch.account_type,&#xA;        ch.account_number,&#xA;        ch.account_name,&#xA;        COALESCE(ob.balance, 0) AS opening_balance, &#xA;        COALESCE(jf.debit, 0) AS debit,&#xA;        COALESCE(jf.credit, 0) AS credit,&#xA;        (COALESCE(ob.balance, 0) &#x2B; COALESCE(jf.debit, 0) - COALESCE(jf.credit, 0)) AS closing_balance&#xA;    FROM coa_hierarchy ch&#xA;    LEFT JOIN opening_balances ob ON ch.id = ob.account_id&#xA;    LEFT JOIN journal_entries_filtered jf ON ch.id = jf.account_id&#xA;    ORDER BY ch.account_number;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_user_by_email</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-51')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-51">
                                            CREATE OR REPLACE FUNCTION public.get_user_by_email(p_email text)&#xA; RETURNS TABLE(id uuid, user_id uuid, third_party_id text, first_name character varying, last_name character varying, email character varying, phone_number character varying, company_id uuid, company_name text, company_description text, company_gstin text, company_is_apartment boolean, company_org_id uuid, organization_id uuid, organization_name text, organization_gstin text, organization_pan text, organization_tan text, organization_short_name text, organization_type_id integer, roles text[], role_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;&#x9;&#x9;u.id as user_id,&#xA;        u.id as user_id,&#xA;        u.third_party_id,&#xA;        u.first_name,&#xA;        u.last_name,&#xA;        u.email,&#xA;        u.phone_number,&#xA;        resolved_company.id,&#xA;        resolved_company.name,&#xA;        resolved_company.description,&#xA;        resolved_company.gstin,&#xA;        resolved_company.is_apartment,&#xA;        resolved_company.organization_id,&#xA;        o.id,&#xA;        o.name,&#xA;        o.gstin,&#xA;        o.pan,&#xA;        o.tan,&#xA;        o.short_name,&#xA;        o.organization_type_id,&#xA;        ARRAY(&#xA;    SELECT DISTINCT r2.name&#xA;    FROM user_roles ur2&#xA;    JOIN roles r2 ON r2.id = ur2.role_id&#xA;    WHERE ur2.user_id = u.id AND r2.name IS NOT NULL&#xA;),&#xA;&#xA;        MIN(r.name)                         -- Primary role&#xA;    FROM users u&#xA;    LEFT JOIN organization_users ou ON ou.user_id = u.id&#xA;&#xA;    -- Resolve company using COALESCE fallback&#xA;    LEFT JOIN LATERAL (&#xA;        SELECT *&#xA;        FROM companies c&#xA;        WHERE c.id = COALESCE(&#xA;            NULLIF(u.company_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            (&#xA;                SELECT MIN(c2.id::text)::uuid&#xA;                FROM companies c2&#xA;                JOIN organization_users ou2 ON c2.organization_id = ou2.organization_id&#xA;                WHERE ou2.user_id = u.id&#xA;            )&#xA;        )&#xA;        LIMIT 1&#xA;    ) AS resolved_company ON TRUE&#xA;&#xA;    LEFT JOIN organizations o ON resolved_company.organization_id = o.id&#xA;    LEFT JOIN user_roles ur ON ur.user_id = u.id&#xA;    LEFT JOIN roles r ON r.id = ur.role_id&#xA;    WHERE u.email = p_email&#xA;    AND u.is_deleted = false &#xA;    GROUP BY&#xA;        u.id, u.third_party_id, u.first_name, u.last_name, u.email, u.phone_number,&#xA;        resolved_company.id, resolved_company.name, resolved_company.description, resolved_company.gstin,&#xA;        resolved_company.is_apartment, resolved_company.organization_id,&#xA;        o.id, o.name, o.gstin, o.pan, o.tan, o.short_name, o.organization_type_id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_user_by_email(p_email text)&#xA; RETURNS TABLE(id uuid, user_id uuid, third_party_id text, first_name character varying, last_name character varying, email character varying, phone_number character varying, company_id uuid, company_name text, company_description text, company_gstin text, company_is_apartment boolean, company_org_id uuid, organization_id uuid, organization_name text, organization_gstin text, organization_pan text, organization_tan text, organization_short_name text, organization_type_id integer, roles text[], role_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;&#x9;&#x9;u.id as user_id,&#xA;        u.id as user_id,&#xA;        u.third_party_id,&#xA;        u.first_name,&#xA;        u.last_name,&#xA;        u.email,&#xA;        u.phone_number,&#xA;        resolved_company.id,&#xA;        resolved_company.name,&#xA;        resolved_company.description,&#xA;        resolved_company.gstin,&#xA;        resolved_company.is_apartment,&#xA;        resolved_company.organization_id,&#xA;        o.id,&#xA;        o.name,&#xA;        o.gstin,&#xA;        o.pan,&#xA;        o.tan,&#xA;        o.short_name,&#xA;        o.organization_type_id,&#xA;        ARRAY(&#xA;    SELECT DISTINCT r2.name&#xA;    FROM user_roles ur2&#xA;    JOIN roles r2 ON r2.id = ur2.role_id&#xA;    WHERE ur2.user_id = u.id AND r2.name IS NOT NULL&#xA;),&#xA;&#xA;        MIN(r.name)                         -- Primary role&#xA;    FROM users u&#xA;    LEFT JOIN organization_users ou ON ou.user_id = u.id&#xA;&#xA;    -- Resolve company using COALESCE fallback&#xA;    LEFT JOIN LATERAL (&#xA;        SELECT *&#xA;        FROM companies c&#xA;        WHERE c.id = COALESCE(&#xA;            NULLIF(u.company_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            (&#xA;                SELECT MIN(c2.id::text)::uuid&#xA;                FROM companies c2&#xA;                JOIN organization_users ou2 ON c2.organization_id = ou2.organization_id&#xA;                WHERE ou2.user_id = u.id&#xA;            )&#xA;        )&#xA;        LIMIT 1&#xA;    ) AS resolved_company ON TRUE&#xA;&#xA;    LEFT JOIN organizations o ON resolved_company.organization_id = o.id&#xA;    LEFT JOIN user_roles ur ON ur.user_id = u.id&#xA;    LEFT JOIN roles r ON r.id = ur.role_id&#xA;    WHERE u.email = p_email&#xA;    AND u.is_deleted = false &#xA;    GROUP BY&#xA;        u.id, u.third_party_id, u.first_name, u.last_name, u.email, u.phone_number,&#xA;        resolved_company.id, resolved_company.name, resolved_company.description, resolved_company.gstin,&#xA;        resolved_company.is_apartment, resolved_company.organization_id,&#xA;        o.id, o.name, o.gstin, o.pan, o.tan, o.short_name, o.organization_type_id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_user_by_email_or_phone</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-52')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-52">
                                            CREATE OR REPLACE FUNCTION public.get_user_by_email_or_phone(p_email text, p_phone text)&#xA; RETURNS TABLE(id uuid, email text, phone_number text)&#xA; LANGUAGE sql&#xA;AS $function$&#xA;    SELECT &#xA;        u.id AS id,&#xA;        u.email AS email,&#xA;        u.phone_number AS phone_number&#xA;    FROM public.users u&#xA;    WHERE u.is_deleted = false&#xA;&#x9;&#x9;AND(&#xA;&#x9;&#x9;&#x9;  (&#xA;&#x9;&#x9;&#x9;&#x9;  COALESCE(NULLIF(p_email, &#x27;&#x27;), NULL) IS NOT NULL&#xA;&#x9;&#x9;&#x9;&#x9;  AND u.email ILIKE COALESCE(NULLIF(p_email, &#x27;&#x27;), NULL)&#xA;&#x9;&#x9;&#x9;  )&#xA;&#x9;&#x9;&#x9;  OR (&#xA;&#x9;&#x9;&#x9;&#x9;  COALESCE(NULLIF(p_phone, &#x27;&#x27;), NULL) IS NOT NULL&#xA;&#x9;&#x9;&#x9;&#x9;  AND u.phone_number = COALESCE(NULLIF(p_phone, &#x27;&#x27;), NULL)&#xA;&#x9;&#x9;&#x9;  )&#xA;&#x9;&#x9;   )&#xA;    LIMIT 1;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_user_by_email_or_phone(p_email text, p_phone text)&#xA; RETURNS TABLE(id uuid, email text, phone_number text)&#xA; LANGUAGE sql&#xA;AS $function$&#xA;    SELECT &#xA;        u.id AS id,&#xA;        u.email AS email,&#xA;        u.phone_number AS phone_number&#xA;    FROM public.users u&#xA;    WHERE u.is_deleted = false&#xA;&#x9;&#x9;AND(&#xA;&#x9;&#x9;&#x9;  (&#xA;&#x9;&#x9;&#x9;&#x9;  COALESCE(NULLIF(p_email, &#x27;&#x27;), NULL) IS NOT NULL&#xA;&#x9;&#x9;&#x9;&#x9;  AND u.email ILIKE COALESCE(NULLIF(p_email, &#x27;&#x27;), NULL)&#xA;&#x9;&#x9;&#x9;  )&#xA;&#x9;&#x9;&#x9;  OR (&#xA;&#x9;&#x9;&#x9;&#x9;  COALESCE(NULLIF(p_phone, &#x27;&#x27;), NULL) IS NOT NULL&#xA;&#x9;&#x9;&#x9;&#x9;  AND u.phone_number = COALESCE(NULLIF(p_phone, &#x27;&#x27;), NULL)&#xA;&#x9;&#x9;&#x9;  )&#xA;&#x9;&#x9;   )&#xA;    LIMIT 1;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_user_by_username</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-53')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-53">
                                            CREATE OR REPLACE FUNCTION public.get_user_by_username(p_username text)&#xA; RETURNS TABLE(id uuid, user_id uuid, third_party_id text, first_name character varying, last_name character varying, user_name character varying, email character varying, phone_number character varying, company_id uuid, company_name character varying, company_description character varying, company_gstin text, company_is_apartment boolean, company_org_id uuid, organization_id uuid, organization_name character varying, organization_gstin text, organization_pan text, organization_tan text, organization_short_name text, organization_type_id integer, roles text[], role_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        u.id as user_id,  -- Ensure this is referring to the &#x27;users&#x27; table alias &#x27;u&#x27;&#xA;        u.id as user_id,&#xA;        u.third_party_id,&#xA;        u.first_name::character varying,  -- Cast first_name to character varying&#xA;        u.last_name::character varying,  -- Cast last_name to character varying&#xA;        u.user_name::character varying,  -- Cast user_name to character varying&#xA;        u.email::character varying,  -- Include email as character varying&#xA;        u.phone_number::character varying,  -- Cast phone_number to character varying&#xA;        resolved_company.id,&#xA;        resolved_company.name::character varying,  -- Cast company name to character varying&#xA;        resolved_company.description::character varying,  -- Cast company description to character varying&#xA;        resolved_company.gstin,&#xA;        resolved_company.is_apartment,&#xA;        resolved_company.organization_id,&#xA;        o.id,&#xA;        o.name::character varying,  -- Cast organization name to character varying&#xA;        o.gstin,&#xA;        o.pan,&#xA;        o.tan,&#xA;        o.short_name,&#xA;        o.organization_type_id,&#xA;        ARRAY(&#xA;            SELECT DISTINCT r2.name&#xA;            FROM user_roles ur2&#xA;            JOIN roles r2 ON r2.id = ur2.role_id&#xA;            WHERE ur2.user_id = u.id AND r2.name IS NOT NULL&#xA;        ),&#xA;        -- Use COALESCE to handle NULL role_name and return a default value if NULL&#xA;        COALESCE(MIN(r.name), &#x27;No Role Assigned&#x27;) AS role_name&#xA;    FROM users u  -- Ensure &#x27;u&#x27; is the correct alias for the &#x27;users&#x27; table&#xA;    LEFT JOIN organization_users ou ON ou.user_id = u.id&#xA;&#xA;    -- Resolve company using COALESCE fallback&#xA;    LEFT JOIN LATERAL (&#xA;        SELECT *&#xA;        FROM companies c&#xA;        WHERE c.id = COALESCE(&#xA;            NULLIF(u.company_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            (&#xA;                SELECT MIN(c2.id::text)::uuid&#xA;                FROM companies c2&#xA;                JOIN organization_users ou2 ON c2.organization_id = ou2.organization_id&#xA;                WHERE ou2.user_id = u.id&#xA;            )&#xA;        )&#xA;        LIMIT 1&#xA;    ) AS resolved_company ON TRUE&#xA;&#xA;    LEFT JOIN organizations o ON resolved_company.organization_id = o.id&#xA;    LEFT JOIN user_roles ur ON ur.user_id = u.id&#xA;    LEFT JOIN roles r ON r.id = ur.role_id&#xA;    WHERE u.user_name = p_username  -- Filter by user_name instead of email&#xA;    AND u.is_deleted = false &#xA;    GROUP BY&#xA;        u.id, u.third_party_id, u.first_name, u.last_name, u.user_name, u.email, u.phone_number,&#xA;        resolved_company.id, resolved_company.name, resolved_company.description, resolved_company.gstin,&#xA;        resolved_company.is_apartment, resolved_company.organization_id,&#xA;        o.id, o.name, o.gstin, o.pan, o.tan, o.short_name, o.organization_type_id;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_user_by_username(p_username text)&#xA; RETURNS TABLE(id uuid, user_id uuid, third_party_id text, first_name character varying, last_name character varying, user_name character varying, email character varying, phone_number character varying, company_id uuid, company_name character varying, company_description character varying, company_gstin text, company_is_apartment boolean, company_org_id uuid, organization_id uuid, organization_name character varying, organization_gstin text, organization_pan text, organization_tan text, organization_short_name text, organization_type_id integer, roles text[], role_name text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT&#xA;        u.id as user_id,  -- Ensure this is referring to the &#x27;users&#x27; table alias &#x27;u&#x27;&#xA;        u.id as user_id,&#xA;        u.third_party_id,&#xA;        u.first_name::character varying,  -- Cast first_name to character varying&#xA;        u.last_name::character varying,  -- Cast last_name to character varying&#xA;        u.user_name::character varying,  -- Cast user_name to character varying&#xA;        u.email::character varying,  -- Include email as character varying&#xA;        u.phone_number::character varying,  -- Cast phone_number to character varying&#xA;        resolved_company.id,&#xA;        resolved_company.name::character varying,  -- Cast company name to character varying&#xA;        resolved_company.description::character varying,  -- Cast company description to character varying&#xA;        resolved_company.gstin,&#xA;        resolved_company.is_apartment,&#xA;        resolved_company.organization_id,&#xA;        o.id,&#xA;        o.name::character varying,  -- Cast organization name to character varying&#xA;        o.gstin,&#xA;        o.pan,&#xA;        o.tan,&#xA;        o.short_name,&#xA;        o.organization_type_id,&#xA;        ARRAY(&#xA;            SELECT DISTINCT r2.name&#xA;            FROM user_roles ur2&#xA;            JOIN roles r2 ON r2.id = ur2.role_id&#xA;            WHERE ur2.user_id = u.id AND r2.name IS NOT NULL&#xA;        ),&#xA;        -- Use COALESCE to handle NULL role_name and return a default value if NULL&#xA;        COALESCE(MIN(r.name), &#x27;No Role Assigned&#x27;) AS role_name&#xA;    FROM users u  -- Ensure &#x27;u&#x27; is the correct alias for the &#x27;users&#x27; table&#xA;    LEFT JOIN organization_users ou ON ou.user_id = u.id&#xA;&#xA;    -- Resolve company using COALESCE fallback&#xA;    LEFT JOIN LATERAL (&#xA;        SELECT *&#xA;        FROM companies c&#xA;        WHERE c.id = COALESCE(&#xA;            NULLIF(u.company_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            (&#xA;                SELECT MIN(c2.id::text)::uuid&#xA;                FROM companies c2&#xA;                JOIN organization_users ou2 ON c2.organization_id = ou2.organization_id&#xA;                WHERE ou2.user_id = u.id&#xA;            )&#xA;        )&#xA;        LIMIT 1&#xA;    ) AS resolved_company ON TRUE&#xA;&#xA;    LEFT JOIN organizations o ON resolved_company.organization_id = o.id&#xA;    LEFT JOIN user_roles ur ON ur.user_id = u.id&#xA;    LEFT JOIN roles r ON r.id = ur.role_id&#xA;    WHERE u.user_name = p_username  -- Filter by user_name instead of email&#xA;    AND u.is_deleted = false &#xA;    GROUP BY&#xA;        u.id, u.third_party_id, u.first_name, u.last_name, u.user_name, u.email, u.phone_number,&#xA;        resolved_company.id, resolved_company.name, resolved_company.description, resolved_company.gstin,&#xA;        resolved_company.is_apartment, resolved_company.organization_id,&#xA;        o.id, o.name, o.gstin, o.pan, o.tan, o.short_name, o.organization_type_id;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_user_deletion_request_by_email</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-54')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-54">
                                            CREATE OR REPLACE FUNCTION public.get_user_deletion_request_by_email(email_input text)&#xA; RETURNS TABLE(user_id uuid, first_name text, last_name text, email text, deletion_request_id integer, status_id integer, status_name text, created_on_utc timestamp without time zone)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT u.id AS user_id,&#xA;           u.first_name::TEXT AS first_name,   -- Explicit cast to TEXT&#xA;           u.last_name::TEXT AS last_name,     -- Explicit cast to TEXT&#xA;           u.email::TEXT AS email,             -- Explicit cast to TEXT&#xA;           ur.id AS deletion_request_id,&#xA;           ur.status_id,&#xA;           s.name::TEXT AS status_name,        -- Explicit cast to TEXT&#xA;           ur.created_on_utc&#xA;    FROM public.users u&#xA;    JOIN public.user_deletion_requests ur ON u.id = ur.user_id&#xA;    JOIN public.user_deletion_request_statuses s ON ur.status_id = s.id&#xA;    WHERE u.email = email_input&#xA;      AND u.is_deleted = FALSE&#xA;    LIMIT 1;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_user_deletion_request_by_email(email_input text)&#xA; RETURNS TABLE(user_id uuid, first_name text, last_name text, email text, deletion_request_id integer, status_id integer, status_name text, created_on_utc timestamp without time zone)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT u.id AS user_id,&#xA;           u.first_name::TEXT AS first_name,   -- Explicit cast to TEXT&#xA;           u.last_name::TEXT AS last_name,     -- Explicit cast to TEXT&#xA;           u.email::TEXT AS email,             -- Explicit cast to TEXT&#xA;           ur.id AS deletion_request_id,&#xA;           ur.status_id,&#xA;           s.name::TEXT AS status_name,        -- Explicit cast to TEXT&#xA;           ur.created_on_utc&#xA;    FROM public.users u&#xA;    JOIN public.user_deletion_requests ur ON u.id = ur.user_id&#xA;    JOIN public.user_deletion_request_statuses s ON ur.status_id = s.id&#xA;    WHERE u.email = email_input&#xA;      AND u.is_deleted = FALSE&#xA;    LIMIT 1;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_vendor_dues</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-55')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-55">
                                            CREATE OR REPLACE FUNCTION public.get_vendor_dues(p_company_id uuid)&#xA; RETURNS TABLE(vendor_name text, coa_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;                BEGIN&#xA;                    RETURN QUERY&#xA;                    SELECT &#xA;                        v.name::text AS vendor_name,&#xA;                        coa.name AS coa_name,&#xA;                        je.amount,&#xA;                        (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;)::date AS due_date,  -- Assuming a 30-day payment term&#xA;                        CASE &#xA;                            WHEN (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;) &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;                            WHEN (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;) BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;                            WHEN (th.transaction_date &#x2B; INTERVAL &#x27;60 days&#x27;) BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;                            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;                        END AS aging_bucket&#xA;                    FROM &#xA;                        public.journal_entries je&#xA;                    JOIN &#xA;                        public.transaction_headers th ON je.transaction_id = th.id&#xA;                    JOIN &#xA;                        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;                    JOIN &#xA;                        public.vendors v ON th.vendor_id = v.id&#xA;                    WHERE &#xA;                        coa.account_type_id = (SELECT id FROM public.account_types WHERE name = &#x27;Accounts Payable&#x27;)&#xA;                        AND je.is_deleted = false&#xA;                        AND (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;) &lt;= CURRENT_DATE&#xA;                        AND th.company_id = p_company_id&#xA;                    ORDER BY &#xA;                        v.name, (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;)::date;&#xA;                END;&#xA;                $function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_vendor_dues(p_company_id uuid)&#xA; RETURNS TABLE(vendor_name text, coa_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;                BEGIN&#xA;                    RETURN QUERY&#xA;                    SELECT &#xA;                        v.name::text AS vendor_name,&#xA;                        coa.name AS coa_name,&#xA;                        je.amount,&#xA;                        (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;)::date AS due_date,  -- Assuming a 30-day payment term&#xA;                        CASE &#xA;                            WHEN (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;) &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;                            WHEN (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;) BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;                            WHEN (th.transaction_date &#x2B; INTERVAL &#x27;60 days&#x27;) BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;                            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;                        END AS aging_bucket&#xA;                    FROM &#xA;                        public.journal_entries je&#xA;                    JOIN &#xA;                        public.transaction_headers th ON je.transaction_id = th.id&#xA;                    JOIN &#xA;                        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;                    JOIN &#xA;                        public.vendors v ON th.vendor_id = v.id&#xA;                    WHERE &#xA;                        coa.account_type_id = (SELECT id FROM public.account_types WHERE name = &#x27;Accounts Payable&#x27;)&#xA;                        AND je.is_deleted = false&#xA;                        AND (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;) &lt;= CURRENT_DATE&#xA;                        AND th.company_id = p_company_id&#xA;                    ORDER BY &#xA;                        v.name, (th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27;)::date;&#xA;                END;&#xA;                $function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_vendor_ledger</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-56')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-56">
                                            CREATE OR REPLACE FUNCTION public.get_vendor_ledger(p_vendor_id uuid, p_company_id uuid, p_organization_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, transaction_source_type integer, document_number text, document_id uuid, sort_order integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_opening_balance NUMERIC;&#xA;&#x9;v_start_date DATE;&#xA;    v_end_date DATE;&#xA;BEGIN&#xA;&#x9;SELECT start_date, end_date&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.get_financial_year_dates(p_fin_year_id);&#xA;&#xA;&#x9;v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;&#x9;SELECT COALESCE(&#xA;&#x9;&#x9;        SUM(&#xA;&#x9;&#x9;            CASE &#xA;&#x9;&#x9;                WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance  -- Debit increases balance&#xA;&#x9;&#x9;                ELSE -ob.balance                         -- Credit reduces balance&#xA;&#x9;&#x9;            END&#xA;&#x9;&#x9;        ), 0)&#xA;    INTO v_opening_balance&#xA;    FROM public.opening_balances ob&#xA;    WHERE ob.organization_id = p_organization_id &#xA;&#x9;  AND ob.finyear_id = p_fin_year_id&#xA;      AND ob.vendor_id = p_vendor_id&#xA;      AND ob.is_deleted = FALSE;&#xA;&#xA;    RETURN QUERY&#xA;    WITH vendor_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date,  &#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            th.vendor_id,&#xA;            th.transaction_source_type,   &#xA;            th.document_number,           &#xA;            th.document_id,&#xA;&#x9;&#x9;&#x9;2 AS sort_order              &#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.vendor_id = p_vendor_id&#xA;            AND th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date   &#xA;            AND th.transaction_date &lt;= p_end_date     &#xA;    )&#xA;&#x9;SELECT &#xA;        v_start_date AS transaction_date, &#xA;        &#x27;Opening Balance&#x27; AS account_name,&#xA;        0 AS debit,&#xA;        0 AS credit,&#xA;        v_opening_balance AS balance,&#xA;        NULL AS document_number,&#xA;        NULL AS document_id,&#xA;        NULL AS transaction_source_type,&#xA;        1 AS sort_order &#xA;         &#xA;    UNION ALL &#xA;&#xA;    SELECT &#xA;        vt.transaction_date,&#xA;        vt.account_name,&#xA;        vt.debit,&#xA;        vt.credit,&#xA;&#x9;&#x9;v_opening_balance &#x2B; &#xA;        SUM(vt.debit - vt.credit) OVER (PARTITION BY vt.vendor_id ORDER BY vt.transaction_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS balance,&#xA;        vt.transaction_source_type,   &#xA;        vt.document_number,           &#xA;        vt.document_id,&#xA;&#x9;&#x9;vt.sort_order               &#xA;    FROM &#xA;        vendor_transactions vt&#xA;    ORDER BY &#xA;        vt.transaction_date,&#xA;&#x9;&#x9;vt.sort_order ASC;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_vendor_ledger(p_vendor_id uuid, p_company_id uuid, p_organization_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(transaction_date date, account_name text, debit numeric, credit numeric, balance numeric, transaction_source_type integer, document_number text, document_id uuid, sort_order integer)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_opening_balance NUMERIC;&#xA;&#x9;v_start_date DATE;&#xA;    v_end_date DATE;&#xA;BEGIN&#xA;&#x9;SELECT start_date, end_date&#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.get_financial_year_dates(p_fin_year_id);&#xA;&#xA;&#x9;v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;&#x9;SELECT COALESCE(&#xA;&#x9;&#x9;        SUM(&#xA;&#x9;&#x9;            CASE &#xA;&#x9;&#x9;                WHEN ob.entry_type = &#x27;C&#x27; THEN ob.balance  -- Debit increases balance&#xA;&#x9;&#x9;                ELSE -ob.balance                         -- Credit reduces balance&#xA;&#x9;&#x9;            END&#xA;&#x9;&#x9;        ), 0)&#xA;    INTO v_opening_balance&#xA;    FROM public.opening_balances ob&#xA;    WHERE ob.organization_id = p_organization_id &#xA;&#x9;  AND ob.finyear_id = p_fin_year_id&#xA;      AND ob.vendor_id = p_vendor_id&#xA;      AND ob.is_deleted = FALSE;&#xA;&#xA;    RETURN QUERY&#xA;    WITH vendor_transactions AS (&#xA;        SELECT &#xA;            th.transaction_date::date AS transaction_date,  &#xA;            coa.name AS account_name,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;D&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS debit,&#xA;            CASE &#xA;                WHEN je.entry_type = &#x27;C&#x27; THEN je.amount &#xA;                ELSE 0 &#xA;            END AS credit,&#xA;            th.company_id,&#xA;            th.vendor_id,&#xA;            th.transaction_source_type,   &#xA;            th.document_number,           &#xA;            th.document_id,&#xA;&#x9;&#x9;&#x9;2 AS sort_order              &#xA;        FROM &#xA;            public.transaction_headers th&#xA;        INNER JOIN &#xA;            public.journal_entries je ON th.id = je.transaction_id  &#xA;        INNER JOIN &#xA;            public.chart_of_accounts coa ON je.account_id = coa.id&#xA;        WHERE &#xA;            th.vendor_id = p_vendor_id&#xA;            AND th.company_id = p_company_id&#xA;            AND coa.organization_id = p_organization_id&#xA;            AND th.is_deleted = false &#xA;            AND je.is_deleted = false&#xA;            AND th.transaction_date &gt;= p_start_date   &#xA;            AND th.transaction_date &lt;= p_end_date     &#xA;    )&#xA;&#x9;SELECT &#xA;        v_start_date AS transaction_date, &#xA;        &#x27;Opening Balance&#x27; AS account_name,&#xA;        0 AS debit,&#xA;        0 AS credit,&#xA;        v_opening_balance AS balance,&#xA;        NULL AS document_number,&#xA;        NULL AS document_id,&#xA;        NULL AS transaction_source_type,&#xA;        1 AS sort_order &#xA;         &#xA;    UNION ALL &#xA;&#xA;    SELECT &#xA;        vt.transaction_date,&#xA;        vt.account_name,&#xA;        vt.debit,&#xA;        vt.credit,&#xA;&#x9;&#x9;v_opening_balance &#x2B; &#xA;        SUM(vt.debit - vt.credit) OVER (PARTITION BY vt.vendor_id ORDER BY vt.transaction_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS balance,&#xA;        vt.transaction_source_type,   &#xA;        vt.document_number,           &#xA;        vt.document_id,&#xA;&#x9;&#x9;vt.sort_order               &#xA;    FROM &#xA;        vendor_transactions vt&#xA;    ORDER BY &#xA;        vt.transaction_date,&#xA;&#x9;&#x9;vt.sort_order ASC;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_vendor_outstanding</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-57')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-57">
                                            CREATE OR REPLACE FUNCTION public.get_vendor_outstanding()&#xA; RETURNS TABLE(vendor_name text, account_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        v.name AS vendor_name,&#xA;        coa.name AS account_name,&#xA;        je.amount,&#xA;        th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; AS due_date,  -- Assuming a 30-day payment term&#xA;        CASE &#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;        END AS aging_bucket&#xA;    FROM &#xA;        public.journal_entries je&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN &#xA;        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        public.vendors v ON th.vendor_id = v.id&#xA;    WHERE &#xA;        coa.account_type_id = (SELECT id FROM account_types WHERE name = &#x27;Accounts Payable&#x27;)&#xA;        AND je.is_deleted = false&#xA;    ORDER BY &#xA;        v.name, th.transaction_date;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_vendor_outstanding()&#xA; RETURNS TABLE(vendor_name text, account_name text, amount numeric, due_date date, aging_bucket text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        v.name AS vendor_name,&#xA;        coa.name AS account_name,&#xA;        je.amount,&#xA;        th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; AS due_date,  -- Assuming a 30-day payment term&#xA;        CASE &#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; &lt;= CURRENT_DATE THEN &#x27;Current&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;30 days&#x27; AND CURRENT_DATE THEN &#x27;1-30 Days Past Due&#x27;&#xA;            WHEN th.transaction_date &#x2B; INTERVAL &#x27;30 days&#x27; BETWEEN CURRENT_DATE - INTERVAL &#x27;60 days&#x27; AND CURRENT_DATE - INTERVAL &#x27;31 days&#x27; THEN &#x27;31-60 Days Past Due&#x27;&#xA;            ELSE &#x27;Over 60 Days Past Due&#x27;&#xA;        END AS aging_bucket&#xA;    FROM &#xA;        public.journal_entries je&#xA;    JOIN &#xA;        public.transaction_headers th ON je.transaction_id = th.id&#xA;    JOIN &#xA;        public.chart_of_accounts coa ON je.account_id = coa.id&#xA;    JOIN &#xA;        public.vendors v ON th.vendor_id = v.id&#xA;    WHERE &#xA;        coa.account_type_id = (SELECT id FROM account_types WHERE name = &#x27;Accounts Payable&#x27;)&#xA;        AND je.is_deleted = false&#xA;    ORDER BY &#xA;        v.name, th.transaction_date;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>insert_multiple_transactions_and_journal_entries</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-58')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-58">
                                            CREATE OR REPLACE FUNCTION public.insert_multiple_transactions_and_journal_entries(p_transactions_data jsonb)&#xA; RETURNS TABLE(transaction_id bigint, document_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_transaction_id BIGINT;&#xA;    v_transaction_record JSONB;&#xA;    v_journal_entry JSONB;&#xA;BEGIN&#xA;    -- Loop through each transaction in the input array&#xA;    FOR v_transaction_record IN SELECT * FROM jsonb_array_elements(p_transactions_data) &#xA;    LOOP&#xA;        -- Insert into transaction_headers&#xA;        INSERT INTO public.transaction_headers (&#xA;            company_id,&#xA;            customer_id,&#xA;            vendor_id,&#xA;            employee_id,&#xA;            transaction_date,&#xA;            transaction_source_type,&#xA;            status_id,&#xA;            document_id,&#xA;            document_number,&#xA;            description,&#xA;            created_by,&#xA;            created_on_utc&#xA;        )&#xA;        VALUES(&#xA;            (v_transaction_record-&gt;&gt;&#x27;company_id&#x27;)::uuid,&#xA;            NULLIF((v_transaction_record-&gt;&gt;&#x27;customer_id&#x27;)::uuid, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF((v_transaction_record-&gt;&gt;&#x27;vendor_id&#x27;)::uuid, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF((v_transaction_record-&gt;&gt;&#x27;employee_id&#x27;)::uuid, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            (v_transaction_record-&gt;&gt;&#x27;transaction_date&#x27;)::date,&#xA;            (v_transaction_record-&gt;&gt;&#x27;transaction_source_type&#x27;)::integer,&#xA;            (v_transaction_record-&gt;&gt;&#x27;status_id&#x27;)::integer,&#xA;            (v_transaction_record-&gt;&gt;&#x27;document_id&#x27;)::uuid,&#xA;            v_transaction_record-&gt;&gt;&#x27;document_number&#x27;,&#xA;            v_transaction_record-&gt;&gt;&#x27;description&#x27;,&#xA;            (v_transaction_record-&gt;&gt;&#x27;user_id&#x27;)::uuid,&#xA;            CURRENT_TIMESTAMP&#xA;        )&#xA;        RETURNING id INTO v_transaction_id;&#xA;&#xA;       &#xA;&#xA;        -- Loop through each journal entry associated with the transaction&#xA;        FOR v_journal_entry IN SELECT * FROM jsonb_array_elements(v_transaction_record-&gt;&#x27;journal_entries&#x27;)&#xA;        LOOP &#xA;            INSERT INTO public.journal_entries (&#xA;                transaction_id,&#xA;                account_id,&#xA;                transaction_date,&#xA;                amount,&#xA;                entry_type,&#xA;                description_template_id,&#xA;                dynamic_data,&#xA;                entry_source_id&#xA;            )&#xA;            VALUES(&#xA;                v_transaction_id,&#xA;                (v_journal_entry-&gt;&gt;&#x27;account_id&#x27;)::uuid,&#xA;                (v_journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::date,&#xA;                (v_journal_entry-&gt;&gt;&#x27;amount&#x27;)::numeric,&#xA;                (v_journal_entry-&gt;&gt;&#x27;entry_type&#x27;)::char,&#xA;                (v_journal_entry-&gt;&gt;&#x27;description_template_id&#x27;)::integer,&#xA;                (v_journal_entry-&gt;&gt;&#x27;dynamic_data&#x27;)::jsonb,&#xA;                (v_journal_entry-&gt;&gt;&#x27;entry_source_id&#x27;)::integer&#xA;            );&#xA;        END LOOP;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9; -- Return transaction ID and document ID for this transaction&#xA;        RETURN QUERY SELECT v_transaction_id, (v_transaction_record-&gt;&gt;&#x27;document_id&#x27;)::uuid;&#xA;    END LOOP;&#xA;EXCEPTION&#xA;    -- Catch any error and raise an exception&#xA;    WHEN OTHERS THEN&#xA;        RAISE EXCEPTION &#x27;Error occurred: %&#x27;, SQLERRM;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.insert_multiple_transactions_and_journal_entries(p_transactions_data jsonb)&#xA; RETURNS TABLE(transaction_id bigint, document_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_transaction_id BIGINT;&#xA;    v_transaction_record JSONB;&#xA;    v_journal_entry JSONB;&#xA;BEGIN&#xA;    -- Loop through each transaction in the input array&#xA;    FOR v_transaction_record IN SELECT * FROM jsonb_array_elements(p_transactions_data) &#xA;    LOOP&#xA;        -- Insert into transaction_headers&#xA;        INSERT INTO public.transaction_headers (&#xA;            company_id,&#xA;            customer_id,&#xA;            vendor_id,&#xA;            employee_id,&#xA;            transaction_date,&#xA;            transaction_source_type,&#xA;            status_id,&#xA;            document_id,&#xA;            document_number,&#xA;            description,&#xA;            created_by,&#xA;            created_on_utc&#xA;        )&#xA;        VALUES(&#xA;            (v_transaction_record-&gt;&gt;&#x27;company_id&#x27;)::uuid,&#xA;            NULLIF((v_transaction_record-&gt;&gt;&#x27;customer_id&#x27;)::uuid, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF((v_transaction_record-&gt;&gt;&#x27;vendor_id&#x27;)::uuid, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF((v_transaction_record-&gt;&gt;&#x27;employee_id&#x27;)::uuid, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            (v_transaction_record-&gt;&gt;&#x27;transaction_date&#x27;)::date,&#xA;            (v_transaction_record-&gt;&gt;&#x27;transaction_source_type&#x27;)::integer,&#xA;            (v_transaction_record-&gt;&gt;&#x27;status_id&#x27;)::integer,&#xA;            (v_transaction_record-&gt;&gt;&#x27;document_id&#x27;)::uuid,&#xA;            v_transaction_record-&gt;&gt;&#x27;document_number&#x27;,&#xA;            v_transaction_record-&gt;&gt;&#x27;description&#x27;,&#xA;            (v_transaction_record-&gt;&gt;&#x27;user_id&#x27;)::uuid,&#xA;            CURRENT_TIMESTAMP&#xA;        )&#xA;        RETURNING id INTO v_transaction_id;&#xA;&#xA;       &#xA;&#xA;        -- Loop through each journal entry associated with the transaction&#xA;        FOR v_journal_entry IN SELECT * FROM jsonb_array_elements(v_transaction_record-&gt;&#x27;journal_entries&#x27;)&#xA;        LOOP &#xA;            INSERT INTO public.journal_entries (&#xA;                transaction_id,&#xA;                account_id,&#xA;                transaction_date,&#xA;                amount,&#xA;                entry_type,&#xA;                description_template_id,&#xA;                dynamic_data,&#xA;                entry_source_id&#xA;            )&#xA;            VALUES(&#xA;                v_transaction_id,&#xA;                (v_journal_entry-&gt;&gt;&#x27;account_id&#x27;)::uuid,&#xA;                (v_journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::date,&#xA;                (v_journal_entry-&gt;&gt;&#x27;amount&#x27;)::numeric,&#xA;                (v_journal_entry-&gt;&gt;&#x27;entry_type&#x27;)::char,&#xA;                (v_journal_entry-&gt;&gt;&#x27;description_template_id&#x27;)::integer,&#xA;                (v_journal_entry-&gt;&gt;&#x27;dynamic_data&#x27;)::jsonb,&#xA;                (v_journal_entry-&gt;&gt;&#x27;entry_source_id&#x27;)::integer&#xA;            );&#xA;        END LOOP;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9; -- Return transaction ID and document ID for this transaction&#xA;        RETURN QUERY SELECT v_transaction_id, (v_transaction_record-&gt;&gt;&#x27;document_id&#x27;)::uuid;&#xA;    END LOOP;&#xA;EXCEPTION&#xA;    -- Catch any error and raise an exception&#xA;    WHEN OTHERS THEN&#xA;        RAISE EXCEPTION &#x27;Error occurred: %&#x27;, SQLERRM;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>search_function_with_paramter</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-59')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-59">
                                            CREATE OR REPLACE FUNCTION public.search_function_with_paramter(keyword text)&#xA; RETURNS TABLE(function_name text, function_definition text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        proname AS function_name,&#xA;        prosrc AS function_definition&#xA;    FROM pg_proc&#xA;    WHERE prosrc ILIKE &#x27;%&#x27; || keyword || &#x27;%&#x27;;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.search_function_with_paramter(keyword text)&#xA; RETURNS TABLE(function_name text, function_definition text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;BEGIN&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        proname AS function_name,&#xA;        prosrc AS function_definition&#xA;    FROM pg_proc&#xA;    WHERE prosrc ILIKE &#x27;%&#x27; || keyword || &#x27;%&#x27;;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>test</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-60')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-60">
                                            CREATE OR REPLACE FUNCTION public.test(p_company_id uuid, p_financial_year integer, p_chart_of_account_id uuid)&#xA; RETURNS TABLE(account_id uuid, account_name text, parent_account_id uuid, account_type text, apr numeric, may numeric, jun numeric, jul numeric, aug numeric, sep numeric, oct numeric, nov numeric, &quot;dec&quot; numeric, jan numeric, feb numeric, mar numeric, total_current_year numeric, total_last_year numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date TIMESTAMP DEFAULT NULL;&#xA;    v_end_date TIMESTAMP DEFAULT NULL;&#xA;    v_prev_start_date TIMESTAMP DEFAULT NULL;&#xA;    v_prev_end_date TIMESTAMP DEFAULT NULL;&#xA;BEGIN&#xA;    -- Get start and end date for the given financial year&#xA;    SELECT start_date, end_date &#xA;    INTO v_start_date, v_end_date&#xA;    FROM finance_year&#xA;    WHERE EXTRACT(YEAR FROM start_date) = p_financial_year&#xA;    LIMIT 1;&#xA;&#xA;    -- If no result, raise an error&#xA;    IF v_start_date IS NULL OR v_end_date IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year % not found in finance_year table&#x27;, p_financial_year;&#xA;    END IF;&#xA;&#xA;    -- Get the previous financial year&#x27;s start and end date&#xA;    SELECT start_date, end_date &#xA;    INTO v_prev_start_date, v_prev_end_date&#xA;    FROM finance_year&#xA;    WHERE EXTRACT(YEAR FROM start_date) = (p_financial_year - 1)&#xA;    LIMIT 1;&#xA;&#xA;    -- If previous year is missing, use the current year as a fallback&#xA;    IF v_prev_start_date IS NULL OR v_prev_end_date IS NULL THEN&#xA;        v_prev_start_date := v_start_date;&#xA;        v_prev_end_date := v_end_date;&#xA;    END IF;&#xA;&#xA;    -- Debugging: Print financial year start and end dates&#xA;    RAISE NOTICE &#x27;Start Date: %, End Date: %, Prev Start: %, Prev End: %&#x27;, v_start_date, v_end_date, v_prev_start_date, v_prev_end_date;&#xA;&#xA;    -- Return the final query&#xA;    RETURN QUERY &#xA;    WITH direct_children AS (&#xA;        -- Step 1: Get Direct Child Accounts&#xA;        SELECT coa.id AS child_id, coa.name AS child_name, coa.parent_account_id AS direct_parent_id, coa.account_type_id&#xA;        FROM chart_of_accounts coa&#xA;        WHERE coa.parent_account_id = p_chart_of_account_id&#xA;    ),&#xA;    all_descendants AS (&#xA;        -- Step 2: Get All Descendants of Each Direct Child&#xA;        WITH RECURSIVE hierarchy AS (&#xA;            SELECT ca.id AS descendant_id, ca.parent_account_id AS ancestor_parent_id&#xA;            FROM chart_of_accounts ca&#xA;            WHERE ca.parent_account_id IN (SELECT child_id FROM direct_children)&#xA;&#xA;            UNION ALL&#xA;&#xA;            SELECT coa.id AS descendant_id, coa.parent_account_id AS ancestor_parent_id&#xA;            FROM chart_of_accounts coa&#xA;            INNER JOIN hierarchy h ON coa.parent_account_id = h.descendant_id&#xA;        )&#xA;        SELECT descendant_id, ancestor_parent_id FROM hierarchy&#xA;    )&#xA;    SELECT &#xA;        dc.child_id AS account_id,&#xA;        dc.child_name AS account_name,&#xA;        dc.direct_parent_id AS parent_account_id,&#xA;        at.name AS account_type,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 4 THEN je.amount ELSE 0 END), 0) AS apr,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 5 THEN je.amount ELSE 0 END), 0) AS may,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 6 THEN je.amount ELSE 0 END), 0) AS jun,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 7 THEN je.amount ELSE 0 END), 0) AS jul,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 8 THEN je.amount ELSE 0 END), 0) AS aug,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 9 THEN je.amount ELSE 0 END), 0) AS sep,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 10 THEN je.amount ELSE 0 END), 0) AS oct,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 11 THEN je.amount ELSE 0 END), 0) AS nov,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 12 THEN je.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 1 THEN je.amount ELSE 0 END), 0) AS jan,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 2 THEN je.amount ELSE 0 END), 0) AS feb,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 3 THEN je.amount ELSE 0 END), 0) AS mar,&#xA;&#xA;        -- Total current year transactions&#xA;        COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN je.amount ELSE 0 END), 0) AS total_current_year,&#xA;&#xA;        -- Total last year transactions&#xA;        COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN je.amount ELSE 0 END), 0) AS total_last_year,&#xA;&#xA;        -- Difference between the two years&#xA;        (COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN je.amount ELSE 0 END), 0) - &#xA;         COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN je.amount ELSE 0 END), 0)) &#xA;        AS difference&#xA;&#xA;    FROM direct_children dc&#xA;    LEFT JOIN all_descendants ad ON dc.child_id = ad.ancestor_parent_id OR dc.child_id = ad.descendant_id&#xA;    LEFT JOIN journal_entries je ON (je.account_id = ad.descendant_id OR je.account_id = dc.child_id)&#xA;    LEFT JOIN account_types at ON at.id = dc.account_type_id&#xA;    GROUP BY dc.child_id, dc.child_name, dc.direct_parent_id, at.name;&#xA;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.test(p_company_id uuid, p_financial_year integer, p_chart_of_account_id uuid)&#xA; RETURNS TABLE(account_id uuid, account_name text, parent_account_id uuid, account_type text, apr numeric, may numeric, jun numeric, jul numeric, aug numeric, sep numeric, oct numeric, nov numeric, &quot;dec&quot; numeric, jan numeric, feb numeric, mar numeric, total_current_year numeric, total_last_year numeric, difference numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date TIMESTAMP DEFAULT NULL;&#xA;    v_end_date TIMESTAMP DEFAULT NULL;&#xA;    v_prev_start_date TIMESTAMP DEFAULT NULL;&#xA;    v_prev_end_date TIMESTAMP DEFAULT NULL;&#xA;BEGIN&#xA;    -- Get start and end date for the given financial year&#xA;    SELECT start_date, end_date &#xA;    INTO v_start_date, v_end_date&#xA;    FROM finance_year&#xA;    WHERE EXTRACT(YEAR FROM start_date) = p_financial_year&#xA;    LIMIT 1;&#xA;&#xA;    -- If no result, raise an error&#xA;    IF v_start_date IS NULL OR v_end_date IS NULL THEN&#xA;        RAISE EXCEPTION &#x27;Financial year % not found in finance_year table&#x27;, p_financial_year;&#xA;    END IF;&#xA;&#xA;    -- Get the previous financial year&#x27;s start and end date&#xA;    SELECT start_date, end_date &#xA;    INTO v_prev_start_date, v_prev_end_date&#xA;    FROM finance_year&#xA;    WHERE EXTRACT(YEAR FROM start_date) = (p_financial_year - 1)&#xA;    LIMIT 1;&#xA;&#xA;    -- If previous year is missing, use the current year as a fallback&#xA;    IF v_prev_start_date IS NULL OR v_prev_end_date IS NULL THEN&#xA;        v_prev_start_date := v_start_date;&#xA;        v_prev_end_date := v_end_date;&#xA;    END IF;&#xA;&#xA;    -- Debugging: Print financial year start and end dates&#xA;    RAISE NOTICE &#x27;Start Date: %, End Date: %, Prev Start: %, Prev End: %&#x27;, v_start_date, v_end_date, v_prev_start_date, v_prev_end_date;&#xA;&#xA;    -- Return the final query&#xA;    RETURN QUERY &#xA;    WITH direct_children AS (&#xA;        -- Step 1: Get Direct Child Accounts&#xA;        SELECT coa.id AS child_id, coa.name AS child_name, coa.parent_account_id AS direct_parent_id, coa.account_type_id&#xA;        FROM chart_of_accounts coa&#xA;        WHERE coa.parent_account_id = p_chart_of_account_id&#xA;    ),&#xA;    all_descendants AS (&#xA;        -- Step 2: Get All Descendants of Each Direct Child&#xA;        WITH RECURSIVE hierarchy AS (&#xA;            SELECT ca.id AS descendant_id, ca.parent_account_id AS ancestor_parent_id&#xA;            FROM chart_of_accounts ca&#xA;            WHERE ca.parent_account_id IN (SELECT child_id FROM direct_children)&#xA;&#xA;            UNION ALL&#xA;&#xA;            SELECT coa.id AS descendant_id, coa.parent_account_id AS ancestor_parent_id&#xA;            FROM chart_of_accounts coa&#xA;            INNER JOIN hierarchy h ON coa.parent_account_id = h.descendant_id&#xA;        )&#xA;        SELECT descendant_id, ancestor_parent_id FROM hierarchy&#xA;    )&#xA;    SELECT &#xA;        dc.child_id AS account_id,&#xA;        dc.child_name AS account_name,&#xA;        dc.direct_parent_id AS parent_account_id,&#xA;        at.name AS account_type,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 4 THEN je.amount ELSE 0 END), 0) AS apr,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 5 THEN je.amount ELSE 0 END), 0) AS may,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 6 THEN je.amount ELSE 0 END), 0) AS jun,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 7 THEN je.amount ELSE 0 END), 0) AS jul,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 8 THEN je.amount ELSE 0 END), 0) AS aug,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 9 THEN je.amount ELSE 0 END), 0) AS sep,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 10 THEN je.amount ELSE 0 END), 0) AS oct,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 11 THEN je.amount ELSE 0 END), 0) AS nov,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 12 THEN je.amount ELSE 0 END), 0) AS &quot;dec&quot;,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 1 THEN je.amount ELSE 0 END), 0) AS jan,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 2 THEN je.amount ELSE 0 END), 0) AS feb,&#xA;        COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM je.transaction_date) = 3 THEN je.amount ELSE 0 END), 0) AS mar,&#xA;&#xA;        -- Total current year transactions&#xA;        COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN je.amount ELSE 0 END), 0) AS total_current_year,&#xA;&#xA;        -- Total last year transactions&#xA;        COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN je.amount ELSE 0 END), 0) AS total_last_year,&#xA;&#xA;        -- Difference between the two years&#xA;        (COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_start_date AND v_end_date THEN je.amount ELSE 0 END), 0) - &#xA;         COALESCE(SUM(CASE WHEN je.transaction_date BETWEEN v_prev_start_date AND v_prev_end_date THEN je.amount ELSE 0 END), 0)) &#xA;        AS difference&#xA;&#xA;    FROM direct_children dc&#xA;    LEFT JOIN all_descendants ad ON dc.child_id = ad.ancestor_parent_id OR dc.child_id = ad.descendant_id&#xA;    LEFT JOIN journal_entries je ON (je.account_id = ad.descendant_id OR je.account_id = dc.child_id)&#xA;    LEFT JOIN account_types at ON at.id = dc.account_type_id&#xA;    GROUP BY dc.child_id, dc.child_name, dc.direct_parent_id, at.name;&#xA;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>validate_organization_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-61')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-61">
                                            CREATE OR REPLACE FUNCTION public.validate_organization_accounts()&#xA; RETURNS trigger&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    invalid_account_id UUID;&#xA;BEGIN&#xA;    -- Check if any account ID does not belong to the specified organization&#xA;    SELECT id INTO invalid_account_id&#xA;    FROM chart_of_accounts&#xA;    WHERE id IN (&#xA;        NEW.accounts_receivable_account_id,&#xA;        NEW.accounts_payable_account_id,&#xA;        NEW.sales_revenue_account_id,&#xA;        NEW.cgst_receivable_account_id,&#xA;        NEW.sgst_receivable_account_id,&#xA;        NEW.igst_receivable_account_id,&#xA;        NEW.cgst_payable_account_id,&#xA;        NEW.sgst_payable_account_id,&#xA;        NEW.igst_payable_account_id,&#xA;        NEW.round_off_gain_account_id,&#xA;        NEW.round_off_loss_account_id,&#xA;        NEW.sales_tax_payable_account_id,&#xA;        NEW.purchase_tax_receivable_account_id,&#xA;        NEW.discounts_given_account_id,&#xA;        NEW.discounts_received_account_id,&#xA;        NEW.interest_income_account_id,&#xA;        NEW.interest_expense_account_id,&#xA;        NEW.depreciation_expense_account_id,&#xA;        NEW.bad_debt_expense_account_id,&#xA;        NEW.bank_charges_account_id,&#xA;        NEW.foreign_exchange_gain_loss_account_id,&#xA;        NEW.cost_of_goods_sold_account_id,&#xA;        NEW.inventory_account_id,&#xA;        NEW.salary_expense_account_id,&#xA;        NEW.salary_payable_account_id,&#xA;        NEW.tds_receivable_account_id,&#xA;        NEW.penalty_receivable_account_id,&#xA;        NEW.tds_payable_account_id&#xA;    ) AND organization_id != NEW.organization_id&#xA;    LIMIT 1;&#xA;&#xA;    -- If an invalid account ID is found, raise an exception&#xA;    IF invalid_account_id IS NOT NULL THEN&#xA;        RAISE EXCEPTION &#x27;Account ID % does not belong to the specified organization %&#x27;,&#xA;            invalid_account_id, NEW.organization_id;&#xA;    END IF;&#xA;&#xA;    RETURN NEW;&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.validate_organization_accounts()&#xA; RETURNS trigger&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    invalid_account_id UUID;&#xA;BEGIN&#xA;    -- Check if any account ID does not belong to the specified organization&#xA;    SELECT id INTO invalid_account_id&#xA;    FROM chart_of_accounts&#xA;    WHERE id IN (&#xA;        NEW.accounts_receivable_account_id,&#xA;        NEW.accounts_payable_account_id,&#xA;        NEW.sales_revenue_account_id,&#xA;        NEW.cgst_receivable_account_id,&#xA;        NEW.sgst_receivable_account_id,&#xA;        NEW.igst_receivable_account_id,&#xA;        NEW.cgst_payable_account_id,&#xA;        NEW.sgst_payable_account_id,&#xA;        NEW.igst_payable_account_id,&#xA;        NEW.round_off_gain_account_id,&#xA;        NEW.round_off_loss_account_id,&#xA;        NEW.sales_tax_payable_account_id,&#xA;        NEW.purchase_tax_receivable_account_id,&#xA;        NEW.discounts_given_account_id,&#xA;        NEW.discounts_received_account_id,&#xA;        NEW.interest_income_account_id,&#xA;        NEW.interest_expense_account_id,&#xA;        NEW.depreciation_expense_account_id,&#xA;        NEW.bad_debt_expense_account_id,&#xA;        NEW.bank_charges_account_id,&#xA;        NEW.foreign_exchange_gain_loss_account_id,&#xA;        NEW.cost_of_goods_sold_account_id,&#xA;        NEW.inventory_account_id,&#xA;        NEW.salary_expense_account_id,&#xA;        NEW.salary_payable_account_id,&#xA;        NEW.tds_receivable_account_id,&#xA;        NEW.penalty_receivable_account_id,&#xA;        NEW.tds_payable_account_id&#xA;    ) AND organization_id != NEW.organization_id&#xA;    LIMIT 1;&#xA;&#xA;    -- If an invalid account ID is found, raise an exception&#xA;    IF invalid_account_id IS NOT NULL THEN&#xA;        RAISE EXCEPTION &#x27;Account ID % does not belong to the specified organization %&#x27;,&#xA;            invalid_account_id, NEW.organization_id;&#xA;    END IF;&#xA;&#xA;    RETURN NEW;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>create_budget</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-62')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-62">
                                            CREATE OR REPLACE FUNCTION public.create_budget(p_company_id uuid, p_finance_year_id integer, p_name text, p_status_id integer, p_created_by uuid, p_budget_lines_json jsonb)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;DECLARE&#xD;&#xA;  v_budget_id uuid;&#xD;&#xA;  v_now timestamp := now();&#xD;&#xA;  line jsonb;&#xD;&#xA;  v_line_id uuid;&#xD;&#xA;BEGIN&#xD;&#xA;  RAISE NOTICE &#x27;---- create_budget() START ----&#x27;;&#xD;&#xA;  RAISE NOTICE &#x27;Company: %, FinanceYear: %, Name: %&#x27;, p_company_id, p_finance_year_id, p_name;&#xD;&#xA;  RAISE NOTICE &#x27;Input budget lines JSON: %&#x27;, p_budget_lines_json;&#xD;&#xA;&#xD;&#xA;  -- Step 1: Check if a budget already exists&#xD;&#xA;  SELECT id INTO v_budget_id&#xD;&#xA;  FROM budgets&#xD;&#xA;  WHERE company_id = p_company_id&#xD;&#xA;    AND finance_year_id = p_finance_year_id&#xD;&#xA;    AND is_deleted = false&#xD;&#xA;  LIMIT 1;&#xD;&#xA;&#xD;&#xA;  IF v_budget_id IS NOT NULL THEN&#xD;&#xA;    RAISE NOTICE &#x27;Existing budget found: %&#x27;, v_budget_id;&#xD;&#xA;    UPDATE budgets&#xD;&#xA;    SET name = p_name,&#xD;&#xA;        status_id = p_status_id,&#xD;&#xA;        modified_by = p_created_by,&#xD;&#xA;        modified_on_utc = v_now&#xD;&#xA;    WHERE id = v_budget_id;&#xD;&#xA;  ELSE&#xD;&#xA;    v_budget_id := gen_random_uuid();&#xD;&#xA;    RAISE NOTICE &#x27;Inserting new budget: %&#x27;, v_budget_id;&#xD;&#xA;    INSERT INTO budgets (&#xD;&#xA;      id, company_id, finance_year_id, name, status_id,&#xD;&#xA;      created_by, created_on_utc, is_deleted&#xD;&#xA;    )&#xD;&#xA;    VALUES (&#xD;&#xA;      v_budget_id, p_company_id, p_finance_year_id, p_name, p_status_id,&#xD;&#xA;      p_created_by, v_now, false&#xD;&#xA;    );&#xD;&#xA;  END IF;&#xD;&#xA;&#xD;&#xA;  -- Step 2: Loop through each line&#xD;&#xA;  FOR line IN SELECT * FROM jsonb_array_elements(p_budget_lines_json)&#xD;&#xA;  LOOP&#xD;&#xA;    RAISE NOTICE &#x27;Processing line: %&#x27;, line;&#xD;&#xA;&#xD;&#xA;    v_line_id := NULLIF(line-&gt;&gt;&#x27;id&#x27;, &#x27;&#x27;)::uuid;&#xD;&#xA;    IF v_line_id IS NULL OR v_line_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;::uuid THEN&#xD;&#xA;      v_line_id := gen_random_uuid();&#xD;&#xA;      RAISE NOTICE &#x27;Generated new line ID: %&#x27;, v_line_id;&#xD;&#xA;    ELSE&#xD;&#xA;      RAISE NOTICE &#x27;Using provided line ID: %&#x27;, v_line_id;&#xD;&#xA;    END IF;&#xD;&#xA;&#xD;&#xA;    IF EXISTS (&#xD;&#xA;      SELECT 1 FROM budget_lines&#xD;&#xA;      WHERE id = v_line_id AND budget_id = v_budget_id AND is_deleted = false&#xD;&#xA;    ) THEN&#xD;&#xA;      RAISE NOTICE &#x27;Updating existing budget line: %&#x27;, v_line_id;&#xD;&#xA;      UPDATE budget_lines&#xD;&#xA;      SET account_id = (line-&gt;&gt;&#x27;accountId&#x27;)::uuid,&#xD;&#xA;          period_start = (line-&gt;&gt;&#x27;periodStart&#x27;)::timestamp::date,&#xD;&#xA;          period_end = (line-&gt;&gt;&#x27;periodEnd&#x27;)::timestamp::date,&#xD;&#xA;          amount = (line-&gt;&gt;&#x27;amount&#x27;)::numeric,&#xD;&#xA;          modified_by = p_created_by,&#xD;&#xA;          modified_on_utc = v_now,&#xD;&#xA;          is_deleted = false&#xD;&#xA;      WHERE id = v_line_id AND budget_id = v_budget_id;&#xD;&#xA;    ELSE&#xD;&#xA;      RAISE NOTICE &#x27;Inserting new budget line: %&#x27;, v_line_id;&#xD;&#xA;      INSERT INTO budget_lines (&#xD;&#xA;        id, budget_id, account_id, period_start, period_end,&#xD;&#xA;        amount, created_by, created_on_utc, is_deleted&#xD;&#xA;      )&#xD;&#xA;      VALUES (&#xD;&#xA;        v_line_id,&#xD;&#xA;        v_budget_id,&#xD;&#xA;        (line-&gt;&gt;&#x27;accountId&#x27;)::uuid,&#xD;&#xA;        (line-&gt;&gt;&#x27;periodStart&#x27;)::timestamp::date,&#xD;&#xA;        (line-&gt;&gt;&#x27;periodEnd&#x27;)::timestamp::date,&#xD;&#xA;        (line-&gt;&gt;&#x27;amount&#x27;)::numeric,&#xD;&#xA;        p_created_by,&#xD;&#xA;        v_now,&#xD;&#xA;        false&#xD;&#xA;      );&#xD;&#xA;    END IF;&#xD;&#xA;  END LOOP;&#xD;&#xA;&#xD;&#xA;  RAISE NOTICE &#x27;---- create_budget() END ----&#x27;;&#xD;&#xA;  RETURN v_budget_id;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.create_budget(p_company_id uuid, p_finance_year_id integer, p_name text, p_status_id integer, p_created_by uuid, p_budget_lines_json jsonb)&#xA; RETURNS uuid&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;DECLARE&#xD;&#xA;  v_budget_id uuid;&#xD;&#xA;  v_now timestamp := now();&#xD;&#xA;  line jsonb;&#xD;&#xA;  v_line_id uuid;&#xD;&#xA;BEGIN&#xD;&#xA;  RAISE NOTICE &#x27;---- create_budget() START ----&#x27;;&#xD;&#xA;  RAISE NOTICE &#x27;Company: %, FinanceYear: %, Name: %&#x27;, p_company_id, p_finance_year_id, p_name;&#xD;&#xA;  RAISE NOTICE &#x27;Input budget lines JSON: %&#x27;, p_budget_lines_json;&#xD;&#xA;&#xD;&#xA;  -- Step 1: Check if a budget already exists&#xD;&#xA;  SELECT id INTO v_budget_id&#xD;&#xA;  FROM budgets&#xD;&#xA;  WHERE company_id = p_company_id&#xD;&#xA;    AND finance_year_id = p_finance_year_id&#xD;&#xA;    AND is_deleted = false&#xD;&#xA;  LIMIT 1;&#xD;&#xA;&#xD;&#xA;  IF v_budget_id IS NOT NULL THEN&#xD;&#xA;    RAISE NOTICE &#x27;Existing budget found: %&#x27;, v_budget_id;&#xD;&#xA;    UPDATE budgets&#xD;&#xA;    SET name = p_name,&#xD;&#xA;        status_id = p_status_id,&#xD;&#xA;        modified_by = p_created_by,&#xD;&#xA;        modified_on_utc = v_now&#xD;&#xA;    WHERE id = v_budget_id;&#xD;&#xA;  ELSE&#xD;&#xA;    v_budget_id := gen_random_uuid();&#xD;&#xA;    RAISE NOTICE &#x27;Inserting new budget: %&#x27;, v_budget_id;&#xD;&#xA;    INSERT INTO budgets (&#xD;&#xA;      id, company_id, finance_year_id, name, status_id,&#xD;&#xA;      created_by, created_on_utc, is_deleted&#xD;&#xA;    )&#xD;&#xA;    VALUES (&#xD;&#xA;      v_budget_id, p_company_id, p_finance_year_id, p_name, p_status_id,&#xD;&#xA;      p_created_by, v_now, false&#xD;&#xA;    );&#xD;&#xA;  END IF;&#xD;&#xA;&#xD;&#xA;  -- Step 2: Loop through each line&#xD;&#xA;  FOR line IN SELECT * FROM jsonb_array_elements(p_budget_lines_json)&#xD;&#xA;  LOOP&#xD;&#xA;    RAISE NOTICE &#x27;Processing line: %&#x27;, line;&#xD;&#xA;&#xD;&#xA;    v_line_id := NULLIF(line-&gt;&gt;&#x27;id&#x27;, &#x27;&#x27;)::uuid;&#xD;&#xA;    IF v_line_id IS NULL OR v_line_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;::uuid THEN&#xD;&#xA;      v_line_id := gen_random_uuid();&#xD;&#xA;      RAISE NOTICE &#x27;Generated new line ID: %&#x27;, v_line_id;&#xD;&#xA;    ELSE&#xD;&#xA;      RAISE NOTICE &#x27;Using provided line ID: %&#x27;, v_line_id;&#xD;&#xA;    END IF;&#xD;&#xA;&#xD;&#xA;    IF EXISTS (&#xD;&#xA;      SELECT 1 FROM budget_lines&#xD;&#xA;      WHERE id = v_line_id AND budget_id = v_budget_id AND is_deleted = false&#xD;&#xA;    ) THEN&#xD;&#xA;      RAISE NOTICE &#x27;Updating existing budget line: %&#x27;, v_line_id;&#xD;&#xA;      UPDATE budget_lines&#xD;&#xA;      SET account_id = (line-&gt;&gt;&#x27;accountId&#x27;)::uuid,&#xD;&#xA;          period_start = (line-&gt;&gt;&#x27;periodStart&#x27;)::timestamp::date,&#xD;&#xA;          period_end = (line-&gt;&gt;&#x27;periodEnd&#x27;)::timestamp::date,&#xD;&#xA;          amount = (line-&gt;&gt;&#x27;amount&#x27;)::numeric,&#xD;&#xA;          modified_by = p_created_by,&#xD;&#xA;          modified_on_utc = v_now,&#xD;&#xA;          is_deleted = false&#xD;&#xA;      WHERE id = v_line_id AND budget_id = v_budget_id;&#xD;&#xA;    ELSE&#xD;&#xA;      RAISE NOTICE &#x27;Inserting new budget line: %&#x27;, v_line_id;&#xD;&#xA;      INSERT INTO budget_lines (&#xD;&#xA;        id, budget_id, account_id, period_start, period_end,&#xD;&#xA;        amount, created_by, created_on_utc, is_deleted&#xD;&#xA;      )&#xD;&#xA;      VALUES (&#xD;&#xA;        v_line_id,&#xD;&#xA;        v_budget_id,&#xD;&#xA;        (line-&gt;&gt;&#x27;accountId&#x27;)::uuid,&#xD;&#xA;        (line-&gt;&gt;&#x27;periodStart&#x27;)::timestamp::date,&#xD;&#xA;        (line-&gt;&gt;&#x27;periodEnd&#x27;)::timestamp::date,&#xD;&#xA;        (line-&gt;&gt;&#x27;amount&#x27;)::numeric,&#xD;&#xA;        p_created_by,&#xD;&#xA;        v_now,&#xD;&#xA;        false&#xD;&#xA;      );&#xD;&#xA;    END IF;&#xD;&#xA;  END LOOP;&#xD;&#xA;&#xD;&#xA;  RAISE NOTICE &#x27;---- create_budget() END ----&#x27;;&#xD;&#xA;  RETURN v_budget_id;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_budget_planning_data</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-63')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-63">
                                            CREATE OR REPLACE FUNCTION public.get_budget_planning_data(p_company_id uuid, p_current_finance_year_id integer)&#xA; RETURNS TABLE(row_id bigint, budget_id uuid, budget_status_id integer, budget_status_name text, account_id uuid, acc_number text, account_name text, acc_type text, acc_level integer, last_year_actual numeric, current_budget_amount numeric, line_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;BEGIN&#xD;&#xA;  RETURN QUERY&#xD;&#xA;  SELECT&#xD;&#xA;    sub.rownum AS row_id,&#xD;&#xA;    sub.draft_budget_id AS budget_id,&#xD;&#xA;    sub.draft_status_id AS budget_status_id,&#xD;&#xA;    sub.draft_status_name AS budget_status_name,&#xD;&#xA;    sub.account_id,&#xD;&#xA;    sub.acc_number,&#xD;&#xA;    sub.account_name,&#xD;&#xA;    sub.acc_type,&#xD;&#xA;    sub.acc_level,&#xD;&#xA;    sub.last_year_actual,&#xD;&#xA;    sub.current_budget_amount,&#xD;&#xA;    sub.line_id&#xD;&#xA;  FROM (&#xD;&#xA;    WITH curr_year AS (&#xD;&#xA;      SELECT * FROM public.finance_year WHERE id = p_current_finance_year_id&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    prev_year AS (&#xD;&#xA;      SELECT fy.*&#xD;&#xA;      FROM public.finance_year fy&#xD;&#xA;      JOIN public.company_finance_year cfy ON cfy.finance_year_id = fy.id&#xD;&#xA;      WHERE cfy.company_id = p_company_id&#xD;&#xA;        AND fy.start_date &lt; (SELECT start_date FROM curr_year)&#xD;&#xA;      ORDER BY fy.start_date DESC&#xD;&#xA;      LIMIT 1&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    coa_hierarchy AS (&#xD;&#xA;      SELECT &#xD;&#xA;        id AS coa_id,&#xD;&#xA;        account_number::text,&#xD;&#xA;        name,&#xD;&#xA;        account_type,&#xD;&#xA;        level&#xD;&#xA;      FROM public.get_all_coa((SELECT organization_id FROM companies WHERE id = p_company_id))&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    draft_budget AS (&#xD;&#xA;      SELECT &#xD;&#xA;        b.id AS draft_budget_id,&#xD;&#xA;        b.status_id AS draft_status_id,&#xD;&#xA;        s.name AS draft_status_name&#xD;&#xA;      FROM public.budgets b&#xD;&#xA;      JOIN public.budget_statuses s ON b.status_id = s.id&#xD;&#xA;      WHERE b.company_id = p_company_id&#xD;&#xA;        AND b.finance_year_id = p_current_finance_year_id&#xD;&#xA;        AND b.is_deleted = false&#xD;&#xA;        AND b.status_id = 1  -- Draft&#xD;&#xA;      LIMIT 1&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    last_year_actuals AS (&#xD;&#xA;      SELECT&#xD;&#xA;        je.account_id,&#xD;&#xA;        SUM(je.amount) AS actual_amount&#xD;&#xA;      FROM public.journal_entries je&#xD;&#xA;      JOIN public.transaction_headers th ON je.transaction_id = th.id&#xD;&#xA;      JOIN prev_year fy ON je.transaction_date BETWEEN fy.start_date AND fy.end_date&#xD;&#xA;      WHERE th.company_id = p_company_id&#xD;&#xA;        AND je.is_deleted = false&#xD;&#xA;      GROUP BY je.account_id&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    current_budget_lines AS (&#xD;&#xA;      SELECT&#xD;&#xA;        bl.account_id,&#xD;&#xA;        SUM(bl.amount) AS budget_amount,&#xD;&#xA;        (ARRAY_AGG(bl.id))[1] AS line_id  -- &#x2705; Fixed aggregation for UUID&#xD;&#xA;      FROM public.budget_lines bl&#xD;&#xA;      JOIN public.budgets b ON bl.budget_id = b.id&#xD;&#xA;      WHERE b.company_id = p_company_id&#xD;&#xA;        AND b.finance_year_id = p_current_finance_year_id&#xD;&#xA;        AND b.is_deleted = false&#xD;&#xA;        AND bl.is_deleted = false&#xD;&#xA;      GROUP BY bl.account_id&#xD;&#xA;    )&#xD;&#xA;&#xD;&#xA;    SELECT&#xD;&#xA;      ROW_NUMBER() OVER (ORDER BY coa.account_number) AS rownum,&#xD;&#xA;      db.draft_budget_id,&#xD;&#xA;      db.draft_status_id,&#xD;&#xA;      db.draft_status_name,&#xD;&#xA;      coa.coa_id AS account_id,&#xD;&#xA;      coa.account_number AS acc_number,&#xD;&#xA;      coa.name AS account_name,&#xD;&#xA;      coa.account_type AS acc_type,&#xD;&#xA;      coa.level AS acc_level,&#xD;&#xA;      COALESCE(lya.actual_amount, 0) AS last_year_actual,&#xD;&#xA;      COALESCE(cbl.budget_amount, 0) AS current_budget_amount,&#xD;&#xA;      cbl.line_id&#xD;&#xA;    FROM coa_hierarchy coa&#xD;&#xA;    CROSS JOIN draft_budget db&#xD;&#xA;    LEFT JOIN last_year_actuals lya ON lya.account_id = coa.coa_id&#xD;&#xA;    LEFT JOIN current_budget_lines cbl ON cbl.account_id = coa.coa_id&#xD;&#xA;  ) sub&#xD;&#xA;  ORDER BY sub.acc_number;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_budget_planning_data(p_company_id uuid, p_current_finance_year_id integer)&#xA; RETURNS TABLE(row_id bigint, budget_id uuid, budget_status_id integer, budget_status_name text, account_id uuid, acc_number text, account_name text, acc_type text, acc_level integer, last_year_actual numeric, current_budget_amount numeric, line_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;BEGIN&#xD;&#xA;  RETURN QUERY&#xD;&#xA;  SELECT&#xD;&#xA;    sub.rownum AS row_id,&#xD;&#xA;    sub.draft_budget_id AS budget_id,&#xD;&#xA;    sub.draft_status_id AS budget_status_id,&#xD;&#xA;    sub.draft_status_name AS budget_status_name,&#xD;&#xA;    sub.account_id,&#xD;&#xA;    sub.acc_number,&#xD;&#xA;    sub.account_name,&#xD;&#xA;    sub.acc_type,&#xD;&#xA;    sub.acc_level,&#xD;&#xA;    sub.last_year_actual,&#xD;&#xA;    sub.current_budget_amount,&#xD;&#xA;    sub.line_id&#xD;&#xA;  FROM (&#xD;&#xA;    WITH curr_year AS (&#xD;&#xA;      SELECT * FROM public.finance_year WHERE id = p_current_finance_year_id&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    prev_year AS (&#xD;&#xA;      SELECT fy.*&#xD;&#xA;      FROM public.finance_year fy&#xD;&#xA;      JOIN public.company_finance_year cfy ON cfy.finance_year_id = fy.id&#xD;&#xA;      WHERE cfy.company_id = p_company_id&#xD;&#xA;        AND fy.start_date &lt; (SELECT start_date FROM curr_year)&#xD;&#xA;      ORDER BY fy.start_date DESC&#xD;&#xA;      LIMIT 1&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    coa_hierarchy AS (&#xD;&#xA;      SELECT &#xD;&#xA;        id AS coa_id,&#xD;&#xA;        account_number::text,&#xD;&#xA;        name,&#xD;&#xA;        account_type,&#xD;&#xA;        level&#xD;&#xA;      FROM public.get_all_coa((SELECT organization_id FROM companies WHERE id = p_company_id))&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    draft_budget AS (&#xD;&#xA;      SELECT &#xD;&#xA;        b.id AS draft_budget_id,&#xD;&#xA;        b.status_id AS draft_status_id,&#xD;&#xA;        s.name AS draft_status_name&#xD;&#xA;      FROM public.budgets b&#xD;&#xA;      JOIN public.budget_statuses s ON b.status_id = s.id&#xD;&#xA;      WHERE b.company_id = p_company_id&#xD;&#xA;        AND b.finance_year_id = p_current_finance_year_id&#xD;&#xA;        AND b.is_deleted = false&#xD;&#xA;        AND b.status_id = 1  -- Draft&#xD;&#xA;      LIMIT 1&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    last_year_actuals AS (&#xD;&#xA;      SELECT&#xD;&#xA;        je.account_id,&#xD;&#xA;        SUM(je.amount) AS actual_amount&#xD;&#xA;      FROM public.journal_entries je&#xD;&#xA;      JOIN public.transaction_headers th ON je.transaction_id = th.id&#xD;&#xA;      JOIN prev_year fy ON je.transaction_date BETWEEN fy.start_date AND fy.end_date&#xD;&#xA;      WHERE th.company_id = p_company_id&#xD;&#xA;        AND je.is_deleted = false&#xD;&#xA;      GROUP BY je.account_id&#xD;&#xA;    ),&#xD;&#xA;&#xD;&#xA;    current_budget_lines AS (&#xD;&#xA;      SELECT&#xD;&#xA;        bl.account_id,&#xD;&#xA;        SUM(bl.amount) AS budget_amount,&#xD;&#xA;        (ARRAY_AGG(bl.id))[1] AS line_id  -- &#x2705; Fixed aggregation for UUID&#xD;&#xA;      FROM public.budget_lines bl&#xD;&#xA;      JOIN public.budgets b ON bl.budget_id = b.id&#xD;&#xA;      WHERE b.company_id = p_company_id&#xD;&#xA;        AND b.finance_year_id = p_current_finance_year_id&#xD;&#xA;        AND b.is_deleted = false&#xD;&#xA;        AND bl.is_deleted = false&#xD;&#xA;      GROUP BY bl.account_id&#xD;&#xA;    )&#xD;&#xA;&#xD;&#xA;    SELECT&#xD;&#xA;      ROW_NUMBER() OVER (ORDER BY coa.account_number) AS rownum,&#xD;&#xA;      db.draft_budget_id,&#xD;&#xA;      db.draft_status_id,&#xD;&#xA;      db.draft_status_name,&#xD;&#xA;      coa.coa_id AS account_id,&#xD;&#xA;      coa.account_number AS acc_number,&#xD;&#xA;      coa.name AS account_name,&#xD;&#xA;      coa.account_type AS acc_type,&#xD;&#xA;      coa.level AS acc_level,&#xD;&#xA;      COALESCE(lya.actual_amount, 0) AS last_year_actual,&#xD;&#xA;      COALESCE(cbl.budget_amount, 0) AS current_budget_amount,&#xD;&#xA;      cbl.line_id&#xD;&#xA;    FROM coa_hierarchy coa&#xD;&#xA;    CROSS JOIN draft_budget db&#xD;&#xA;    LEFT JOIN last_year_actuals lya ON lya.account_id = coa.coa_id&#xD;&#xA;    LEFT JOIN current_budget_lines cbl ON cbl.account_id = coa.coa_id&#xD;&#xA;  ) sub&#xD;&#xA;  ORDER BY sub.acc_number;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_income_expense_overview</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-64')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-64">
                                            CREATE OR REPLACE FUNCTION public.get_income_expense_overview(p_company_id uuid, p_period_type integer, p_finance_id integer)&#xA; RETURNS TABLE(period text, year numeric, total_income numeric, total_expense numeric, actual_income numeric, actual_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;DECLARE&#xD;&#xA;    v_financial_year_start date;&#xD;&#xA;    v_financial_year_end date;&#xD;&#xA;    v_finance_year_start numeric;&#xD;&#xA;    v_finance_year_end numeric;&#xD;&#xA;&#xD;&#xA;    CONST_MONTHLY CONSTANT INTEGER := 1;&#xD;&#xA;    CONST_QUARTERLY CONSTANT INTEGER := 2;&#xD;&#xA;    CONST_HALF_YEARLY CONSTANT INTEGER := 3;&#xD;&#xA;    CONST_YEARLY CONSTANT INTEGER := 4;&#xD;&#xA;BEGIN&#xD;&#xA;    SELECT start_date, end_date,&#xD;&#xA;           EXTRACT(YEAR FROM start_date),&#xD;&#xA;           EXTRACT(YEAR FROM end_date)&#xD;&#xA;    INTO v_financial_year_start, v_financial_year_end,&#xD;&#xA;         v_finance_year_start, v_finance_year_end&#xD;&#xA;    FROM public.finance_year&#xD;&#xA;    WHERE id = p_finance_id;&#xD;&#xA;&#xD;&#xA;    IF p_period_type = CONST_MONTHLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH months AS (&#xD;&#xA;            SELECT&#xD;&#xA;                generate_series::date AS month_start,&#xD;&#xA;                (generate_series &#x2B; interval &#x27;1 month&#x27;)::date AS month_end&#xD;&#xA;            FROM generate_series(&#xD;&#xA;                v_financial_year_start,&#xD;&#xA;                v_financial_year_end,&#xD;&#xA;                interval &#x27;1 month&#x27;&#xD;&#xA;            )&#xD;&#xA;        ),&#xD;&#xA;        filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            to_char(m.month_start, &#x27;Mon YYYY&#x27;) AS period,&#xD;&#xA;            EXTRACT(YEAR FROM m.month_start) AS year,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0) AS total_income,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0) AS total_expense,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0) AS actual_income,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0) AS actual_expense&#xD;&#xA;        FROM months m&#xD;&#xA;        LEFT JOIN filtered_je je ON je.transaction_date &gt;= m.month_start AND je.transaction_date &lt; m.month_end&#xD;&#xA;        GROUP BY m.month_start&#xD;&#xA;        ORDER BY m.month_start;&#xD;&#xA;&#xD;&#xA;    ELSIF p_period_type = CONST_QUARTERLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH quarters AS (&#xD;&#xA;            SELECT &#x27;Q1&#x27; AS period, 4 AS start_month, 6 AS end_month, v_finance_year_start AS year&#xD;&#xA;            UNION ALL SELECT &#x27;Q2&#x27;, 7, 9, v_finance_year_start&#xD;&#xA;            UNION ALL SELECT &#x27;Q3&#x27;, 10, 12, v_finance_year_start&#xD;&#xA;            UNION ALL SELECT &#x27;Q4&#x27;, 1, 3, v_finance_year_end&#xD;&#xA;        ),&#xD;&#xA;        filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            CONCAT(q.period, &#x27; &#x27;, q.year),&#xD;&#xA;            q.year,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0)&#xD;&#xA;        FROM quarters q&#xD;&#xA;        JOIN filtered_je je ON EXTRACT(MONTH FROM je.transaction_date) BETWEEN q.start_month AND q.end_month&#xD;&#xA;                             AND EXTRACT(YEAR FROM je.transaction_date) = q.year&#xD;&#xA;        GROUP BY q.period, q.year&#xD;&#xA;        ORDER BY q.year, q.period;&#xD;&#xA;&#xD;&#xA;    ELSIF p_period_type = CONST_HALF_YEARLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH half_years AS (&#xD;&#xA;            SELECT &#x27;H1&#x27; AS period, 4 AS start_month, 9 AS end_month, v_finance_year_start AS year&#xD;&#xA;            UNION ALL SELECT &#x27;H2&#x27;, 10, 12, v_finance_year_start&#xD;&#xA;            UNION ALL SELECT &#x27;H2&#x27;, 1, 3, v_finance_year_end&#xD;&#xA;        ),&#xD;&#xA;        filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            CONCAT(h.period, &#x27; &#x27;, h.year),&#xD;&#xA;            h.year,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0)&#xD;&#xA;        FROM half_years h&#xD;&#xA;        JOIN filtered_je je ON EXTRACT(MONTH FROM je.transaction_date) BETWEEN h.start_month AND h.end_month&#xD;&#xA;                             AND EXTRACT(YEAR FROM je.transaction_date) = h.year&#xD;&#xA;        GROUP BY h.period, h.year&#xD;&#xA;        ORDER BY h.year, h.period;&#xD;&#xA;&#xD;&#xA;    ELSIF p_period_type = CONST_YEARLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            CONCAT(&#x27;Year &#x27;, EXTRACT(YEAR FROM je.transaction_date)),&#xD;&#xA;            EXTRACT(YEAR FROM je.transaction_date),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0)&#xD;&#xA;        FROM filtered_je je&#xD;&#xA;        GROUP BY EXTRACT(YEAR FROM je.transaction_date)&#xD;&#xA;        ORDER BY EXTRACT(YEAR FROM je.transaction_date);&#xD;&#xA;&#xD;&#xA;    ELSE&#xD;&#xA;        RAISE EXCEPTION &#x27;Unsupported period type %&#x27;, p_period_type;&#xD;&#xA;    END IF;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_income_expense_overview(p_company_id uuid, p_period_type integer, p_finance_id integer)&#xA; RETURNS TABLE(period text, year numeric, total_income numeric, total_expense numeric, actual_income numeric, actual_expense numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;DECLARE&#xD;&#xA;    v_financial_year_start date;&#xD;&#xA;    v_financial_year_end date;&#xD;&#xA;    v_finance_year_start numeric;&#xD;&#xA;    v_finance_year_end numeric;&#xD;&#xA;&#xD;&#xA;    CONST_MONTHLY CONSTANT INTEGER := 1;&#xD;&#xA;    CONST_QUARTERLY CONSTANT INTEGER := 2;&#xD;&#xA;    CONST_HALF_YEARLY CONSTANT INTEGER := 3;&#xD;&#xA;    CONST_YEARLY CONSTANT INTEGER := 4;&#xD;&#xA;BEGIN&#xD;&#xA;    SELECT start_date, end_date,&#xD;&#xA;           EXTRACT(YEAR FROM start_date),&#xD;&#xA;           EXTRACT(YEAR FROM end_date)&#xD;&#xA;    INTO v_financial_year_start, v_financial_year_end,&#xD;&#xA;         v_finance_year_start, v_finance_year_end&#xD;&#xA;    FROM public.finance_year&#xD;&#xA;    WHERE id = p_finance_id;&#xD;&#xA;&#xD;&#xA;    IF p_period_type = CONST_MONTHLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH months AS (&#xD;&#xA;            SELECT&#xD;&#xA;                generate_series::date AS month_start,&#xD;&#xA;                (generate_series &#x2B; interval &#x27;1 month&#x27;)::date AS month_end&#xD;&#xA;            FROM generate_series(&#xD;&#xA;                v_financial_year_start,&#xD;&#xA;                v_financial_year_end,&#xD;&#xA;                interval &#x27;1 month&#x27;&#xD;&#xA;            )&#xD;&#xA;        ),&#xD;&#xA;        filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            to_char(m.month_start, &#x27;Mon YYYY&#x27;) AS period,&#xD;&#xA;            EXTRACT(YEAR FROM m.month_start) AS year,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0) AS total_income,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0) AS total_expense,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0) AS actual_income,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0) AS actual_expense&#xD;&#xA;        FROM months m&#xD;&#xA;        LEFT JOIN filtered_je je ON je.transaction_date &gt;= m.month_start AND je.transaction_date &lt; m.month_end&#xD;&#xA;        GROUP BY m.month_start&#xD;&#xA;        ORDER BY m.month_start;&#xD;&#xA;&#xD;&#xA;    ELSIF p_period_type = CONST_QUARTERLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH quarters AS (&#xD;&#xA;            SELECT &#x27;Q1&#x27; AS period, 4 AS start_month, 6 AS end_month, v_finance_year_start AS year&#xD;&#xA;            UNION ALL SELECT &#x27;Q2&#x27;, 7, 9, v_finance_year_start&#xD;&#xA;            UNION ALL SELECT &#x27;Q3&#x27;, 10, 12, v_finance_year_start&#xD;&#xA;            UNION ALL SELECT &#x27;Q4&#x27;, 1, 3, v_finance_year_end&#xD;&#xA;        ),&#xD;&#xA;        filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            CONCAT(q.period, &#x27; &#x27;, q.year),&#xD;&#xA;            q.year,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0)&#xD;&#xA;        FROM quarters q&#xD;&#xA;        JOIN filtered_je je ON EXTRACT(MONTH FROM je.transaction_date) BETWEEN q.start_month AND q.end_month&#xD;&#xA;                             AND EXTRACT(YEAR FROM je.transaction_date) = q.year&#xD;&#xA;        GROUP BY q.period, q.year&#xD;&#xA;        ORDER BY q.year, q.period;&#xD;&#xA;&#xD;&#xA;    ELSIF p_period_type = CONST_HALF_YEARLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH half_years AS (&#xD;&#xA;            SELECT &#x27;H1&#x27; AS period, 4 AS start_month, 9 AS end_month, v_finance_year_start AS year&#xD;&#xA;            UNION ALL SELECT &#x27;H2&#x27;, 10, 12, v_finance_year_start&#xD;&#xA;            UNION ALL SELECT &#x27;H2&#x27;, 1, 3, v_finance_year_end&#xD;&#xA;        ),&#xD;&#xA;        filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            CONCAT(h.period, &#x27; &#x27;, h.year),&#xD;&#xA;            h.year,&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0)&#xD;&#xA;        FROM half_years h&#xD;&#xA;        JOIN filtered_je je ON EXTRACT(MONTH FROM je.transaction_date) BETWEEN h.start_month AND h.end_month&#xD;&#xA;                             AND EXTRACT(YEAR FROM je.transaction_date) = h.year&#xD;&#xA;        GROUP BY h.period, h.year&#xD;&#xA;        ORDER BY h.year, h.period;&#xD;&#xA;&#xD;&#xA;    ELSIF p_period_type = CONST_YEARLY THEN&#xD;&#xA;        RETURN QUERY&#xD;&#xA;        WITH filtered_je AS (&#xD;&#xA;            SELECT&#xD;&#xA;                je.*,&#xD;&#xA;                coa.account_type_id&#xD;&#xA;            FROM journal_entries je&#xD;&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xD;&#xA;            JOIN chart_of_accounts coa ON je.account_id = coa.id&#xD;&#xA;            WHERE tr.company_id = p_company_id&#xD;&#xA;              AND je.is_deleted = FALSE&#xD;&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xD;&#xA;        )&#xD;&#xA;        SELECT&#xD;&#xA;            CONCAT(&#x27;Year &#x27;, EXTRACT(YEAR FROM je.transaction_date)),&#xD;&#xA;            EXTRACT(YEAR FROM je.transaction_date),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (4,14,15,19,20) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (5,16,17,18,21,22) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;D&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0),&#xD;&#xA;            COALESCE(SUM(CASE WHEN je.entry_type = &#x27;C&#x27; AND je.account_type_id IN (8,9) THEN je.amount ELSE 0 END), 0)&#xD;&#xA;        FROM filtered_je je&#xD;&#xA;        GROUP BY EXTRACT(YEAR FROM je.transaction_date)&#xD;&#xA;        ORDER BY EXTRACT(YEAR FROM je.transaction_date);&#xD;&#xA;&#xD;&#xA;    ELSE&#xD;&#xA;        RAISE EXCEPTION &#x27;Unsupported period type %&#x27;, p_period_type;&#xD;&#xA;    END IF;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_permissions</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-65')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-65">
                                            CREATE OR REPLACE FUNCTION public.get_permissions()&#xA; RETURNS TABLE(id uuid, name text, parent_permission_id uuid, tree_name text, description text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;BEGIN&#xD;&#xA;    RETURN QUERY&#xD;&#xA;    WITH RECURSIVE permissions_cte AS (&#xD;&#xA;        SELECT &#xD;&#xA;            p.id,&#xD;&#xA;            p.name,&#xD;&#xA;            p.parent_permission_id,&#xD;&#xA;            0 AS level,&#xD;&#xA;            p.name::text AS tree_name,&#xD;&#xA;            p.name::text AS sort_key,&#xD;&#xA;            p.description&#xD;&#xA;        FROM &#xD;&#xA;            public.permissions p&#xD;&#xA;        WHERE &#xD;&#xA;            p.parent_permission_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;&#xD;&#xA;&#xD;&#xA;        UNION ALL&#xD;&#xA;&#xD;&#xA;        SELECT &#xD;&#xA;            p.id,&#xD;&#xA;            p.name, &#xD;&#xA;            p.parent_permission_id,&#xD;&#xA;            cte.level &#x2B; 1 AS level,&#xD;&#xA;            (LPAD(&#x27;&#x27;, (cte.level &#x2B; 1) * 4, &#x27; &#x27;) || p.name::text)::text AS tree_name,&#xD;&#xA;            (cte.sort_key || &#x27; &gt; &#x27; || p.name::text)::text AS sort_key,&#xD;&#xA;            p.description&#xD;&#xA;        FROM &#xD;&#xA;            public.permissions p&#xD;&#xA;        INNER JOIN &#xD;&#xA;            permissions_cte cte ON cte.id = p.parent_permission_id&#xD;&#xA;    )&#xD;&#xA;    SELECT &#xD;&#xA;        cte.id,&#xD;&#xA;        cte.name,&#xD;&#xA;        cte.parent_permission_id,&#xD;&#xA;        cte.tree_name::text,&#xD;&#xA;        cte.description&#xD;&#xA;    FROM &#xD;&#xA;        permissions_cte cte&#xD;&#xA;    ORDER BY&#xD;&#xA;        cte.sort_key;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_permissions()&#xA; RETURNS TABLE(id uuid, name text, parent_permission_id uuid, tree_name text, description text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;BEGIN&#xD;&#xA;    RETURN QUERY&#xD;&#xA;    WITH RECURSIVE permissions_cte AS (&#xD;&#xA;        SELECT &#xD;&#xA;            p.id,&#xD;&#xA;            p.name,&#xD;&#xA;            p.parent_permission_id,&#xD;&#xA;            0 AS level,&#xD;&#xA;            p.name::text AS tree_name,&#xD;&#xA;            p.name::text AS sort_key,&#xD;&#xA;            p.description&#xD;&#xA;        FROM &#xD;&#xA;            public.permissions p&#xD;&#xA;        WHERE &#xD;&#xA;            p.parent_permission_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;&#xD;&#xA;&#xD;&#xA;        UNION ALL&#xD;&#xA;&#xD;&#xA;        SELECT &#xD;&#xA;            p.id,&#xD;&#xA;            p.name, &#xD;&#xA;            p.parent_permission_id,&#xD;&#xA;            cte.level &#x2B; 1 AS level,&#xD;&#xA;            (LPAD(&#x27;&#x27;, (cte.level &#x2B; 1) * 4, &#x27; &#x27;) || p.name::text)::text AS tree_name,&#xD;&#xA;            (cte.sort_key || &#x27; &gt; &#x27; || p.name::text)::text AS sort_key,&#xD;&#xA;            p.description&#xD;&#xA;        FROM &#xD;&#xA;            public.permissions p&#xD;&#xA;        INNER JOIN &#xD;&#xA;            permissions_cte cte ON cte.id = p.parent_permission_id&#xD;&#xA;    )&#xD;&#xA;    SELECT &#xD;&#xA;        cte.id,&#xD;&#xA;        cte.name,&#xD;&#xA;        cte.parent_permission_id,&#xD;&#xA;        cte.tree_name::text,&#xD;&#xA;        cte.description&#xD;&#xA;    FROM &#xD;&#xA;        permissions_cte cte&#xD;&#xA;    ORDER BY&#xD;&#xA;        cte.sort_key;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>get_dashboard_totals_with_previous_year_comparison</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-66')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-66">
                                            CREATE OR REPLACE FUNCTION public.get_dashboard_totals_with_previous_year_comparison(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(income_total numeric, expense_total numeric, pending_dues_total numeric, pending_payments_total numeric, prev_income_total numeric, prev_expense_total numeric, prev_pending_dues_total numeric, prev_pending_payments_total numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_prev_financial_year_start DATE;&#xA;    v_prev_financial_year_end DATE;&#xA;    v_finance_year INTEGER;&#xA;    v_today DATE := CURRENT_DATE;&#xA;BEGIN&#xA;    -- Fetch organization ID&#xA;    SELECT organization_id INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    IF NOT FOUND THEN&#xA;        RAISE EXCEPTION &#x27;Invalid company ID: %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Get financial year integer from &#x27;YYYY-YY&#x27;&#xA;    SELECT LEFT(year, 4)::INTEGER INTO v_finance_year&#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_year_id&#xA;    LIMIT 1;&#xA;&#xA;    IF NOT FOUND THEN&#xA;        RAISE EXCEPTION &#x27;Invalid finance year ID: %&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Define financial year range&#xA;    v_financial_year_start := MAKE_DATE(v_finance_year, 4, 1);&#xA;    v_financial_year_end := MAKE_DATE(v_finance_year &#x2B; 1, 3, 31);&#xA;&#xA;    -- Define previous financial year range&#xA;    v_prev_financial_year_start := MAKE_DATE(v_finance_year - 1, 4, 1);&#xA;    v_prev_financial_year_end := MAKE_DATE(v_finance_year, 3, 31);&#xA;&#xA;    -- Adjust financial year ends if the year is ongoing&#xA;    IF v_today &lt; v_financial_year_end THEN&#xA;        v_financial_year_end := v_today;&#xA;    END IF;&#xA;&#xA;    IF v_today &lt; v_prev_financial_year_end THEN&#xA;        v_prev_financial_year_end := v_today - INTERVAL &#x27;1 year&#x27;;&#xA;    END IF;&#xA;&#xA;    -- Align both end dates to same day/month by limiting to shorter period&#xA;    v_financial_year_end := LEAST(v_financial_year_end, v_prev_financial_year_end &#x2B; INTERVAL &#x27;1 year&#x27;);&#xA;    v_prev_financial_year_end := v_financial_year_end - INTERVAL &#x27;1 year&#x27;;&#xA;&#xA;    -- Return calculated data&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        -- Current Year Income&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 4&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Current Year Expense&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 5&#xA;&#x9;&#x9;&#x9;  AND tr.transaction_source_type  = 2&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Pending Dues&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE at.name IN (&#x27;Accounts Receivable&#x27;, &#x27;Current Assets&#x27;)&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Pending Payments&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ca.account_type_id IN (SELECT id FROM get_account_type_hierarchy(2))&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Income&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 4&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Expense&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 5&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Pending Dues&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE at.name IN (&#x27;Accounts Receivable&#x27;, &#x27;Current Assets&#x27;)&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Pending Payments&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ca.account_type_id IN (SELECT id FROM get_account_type_hierarchy(2))&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2);&#xA;END;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_dashboard_totals_with_previous_year_comparison(p_company_id uuid, p_finance_year_id integer)&#xA; RETURNS TABLE(income_total numeric, expense_total numeric, pending_dues_total numeric, pending_payments_total numeric, prev_income_total numeric, prev_expense_total numeric, prev_pending_dues_total numeric, prev_pending_payments_total numeric)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_organization_id UUID;&#xA;    v_financial_year_start DATE;&#xA;    v_financial_year_end DATE;&#xA;    v_prev_financial_year_start DATE;&#xA;    v_prev_financial_year_end DATE;&#xA;    v_finance_year INTEGER;&#xA;    v_today DATE := CURRENT_DATE;&#xA;BEGIN&#xA;    -- Fetch organization ID&#xA;    SELECT organization_id INTO v_organization_id&#xA;    FROM public.companies&#xA;    WHERE id = p_company_id;&#xA;&#xA;    IF NOT FOUND THEN&#xA;        RAISE EXCEPTION &#x27;Invalid company ID: %&#x27;, p_company_id;&#xA;    END IF;&#xA;&#xA;    -- Get financial year integer from &#x27;YYYY-YY&#x27;&#xA;    SELECT LEFT(year, 4)::INTEGER INTO v_finance_year&#xA;    FROM public.finance_year&#xA;    WHERE id = p_finance_year_id&#xA;    LIMIT 1;&#xA;&#xA;    IF NOT FOUND THEN&#xA;        RAISE EXCEPTION &#x27;Invalid finance year ID: %&#x27;, p_finance_year_id;&#xA;    END IF;&#xA;&#xA;    -- Define financial year range&#xA;    v_financial_year_start := MAKE_DATE(v_finance_year, 4, 1);&#xA;    v_financial_year_end := MAKE_DATE(v_finance_year &#x2B; 1, 3, 31);&#xA;&#xA;    -- Define previous financial year range&#xA;    v_prev_financial_year_start := MAKE_DATE(v_finance_year - 1, 4, 1);&#xA;    v_prev_financial_year_end := MAKE_DATE(v_finance_year, 3, 31);&#xA;&#xA;    -- Adjust financial year ends if the year is ongoing&#xA;    IF v_today &lt; v_financial_year_end THEN&#xA;        v_financial_year_end := v_today;&#xA;    END IF;&#xA;&#xA;    IF v_today &lt; v_prev_financial_year_end THEN&#xA;        v_prev_financial_year_end := v_today - INTERVAL &#x27;1 year&#x27;;&#xA;    END IF;&#xA;&#xA;    -- Align both end dates to same day/month by limiting to shorter period&#xA;    v_financial_year_end := LEAST(v_financial_year_end, v_prev_financial_year_end &#x2B; INTERVAL &#x27;1 year&#x27;);&#xA;    v_prev_financial_year_end := v_financial_year_end - INTERVAL &#x27;1 year&#x27;;&#xA;&#xA;    -- Return calculated data&#xA;    RETURN QUERY&#xA;    SELECT &#xA;        -- Current Year Income&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 4&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Current Year Expense&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 5&#xA;&#x9;&#x9;&#x9;  AND tr.transaction_source_type  = 2&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Pending Dues&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE at.name IN (&#x27;Accounts Receivable&#x27;, &#x27;Current Assets&#x27;)&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Pending Payments&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ca.account_type_id IN (SELECT id FROM get_account_type_hierarchy(2))&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_financial_year_start AND v_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Income&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 4&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Expense&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(je.amount)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN account_categories ac ON at.account_category_id = ac.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ac.id = 5&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Pending Dues&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE at.name IN (&#x27;Accounts Receivable&#x27;, &#x27;Current Assets&#x27;)&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2),&#xA;&#xA;        -- Previous Year Pending Payments&#xA;        ROUND(COALESCE((&#xA;            SELECT SUM(CASE WHEN je.entry_type = &#x27;C&#x27; THEN je.amount ELSE 0 END) -&#xA;                   SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE 0 END)&#xA;            FROM journal_entries je&#xA;            JOIN chart_of_accounts ca ON je.account_id = ca.id&#xA;            JOIN account_types at ON ca.account_type_id = at.id&#xA;            JOIN transaction_headers tr ON je.transaction_id = tr.id&#xA;            WHERE ca.account_type_id IN (SELECT id FROM get_account_type_hierarchy(2))&#xA;              AND tr.company_id = p_company_id&#xA;              AND ca.organization_id = v_organization_id&#xA;              AND je.transaction_date BETWEEN v_prev_financial_year_start AND v_prev_financial_year_end&#xA;              AND je.is_deleted = FALSE&#xA;        ), 0), 2);&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Function</td>
                    <td>pg_get_tabledef</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-67')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-67">
                                            CREATE OR REPLACE FUNCTION public.pg_get_tabledef(p_table_name text)&#xA; RETURNS text&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;                            DECLARE&#xD;&#xA;                                col RECORD;&#xD;&#xA;                                col_defs TEXT := &#x27;&#x27;;&#xD;&#xA;                                pk_cols TEXT := &#x27;&#x27;;&#xD;&#xA;                                result TEXT;&#xD;&#xA;                            BEGIN&#xD;&#xA;                                FOR col IN&#xD;&#xA;                                    SELECT &#xD;&#xA;                                        column_name,&#xD;&#xA;                                        data_type,&#xD;&#xA;                                        character_maximum_length,&#xD;&#xA;                                        numeric_precision,&#xD;&#xA;                                        numeric_scale,&#xD;&#xA;                                        is_nullable,&#xD;&#xA;                                        column_default&#xD;&#xA;                                    FROM information_schema.columns&#xD;&#xA;                                    WHERE table_schema = &#x27;public&#x27; AND table_name = p_table_name&#xD;&#xA;                                    ORDER BY ordinal_position&#xD;&#xA;                                LOOP&#xD;&#xA;                                    col_defs := col_defs || &#xD;&#xA;                                        format(&#x27;&quot;%s&quot; %s%s%s%s, &#x27;,&#xD;&#xA;                                            col.column_name,&#xD;&#xA;                                            CASE &#xD;&#xA;                                                WHEN col.data_type = &#x27;character varying&#x27; THEN format(&#x27;varchar(%s)&#x27;, col.character_maximum_length)&#xD;&#xA;                                                WHEN col.data_type = &#x27;numeric&#x27; THEN format(&#x27;numeric(%s,%s)&#x27;, col.numeric_precision, col.numeric_scale)&#xD;&#xA;                                                ELSE col.data_type&#xD;&#xA;                                            END,&#xD;&#xA;                                            CASE WHEN col.column_default IS NOT NULL THEN &#x27; DEFAULT &#x27; || col.column_default ELSE &#x27;&#x27; END,&#xD;&#xA;                                            CASE WHEN col.is_nullable = &#x27;NO&#x27; THEN &#x27; NOT NULL&#x27; ELSE &#x27;&#x27; END,&#xD;&#xA;                                            &#x27;&#x27;&#xD;&#xA;                                        );&#xD;&#xA;                                END LOOP;&#xD;&#xA;&#xD;&#xA;                                -- Get primary key columns&#xD;&#xA;                                SELECT string_agg(format(&#x27;&quot;%s&quot;&#x27;, kcu.column_name), &#x27;, &#x27;)&#xD;&#xA;                                INTO pk_cols&#xD;&#xA;                                FROM information_schema.table_constraints tc&#xD;&#xA;                                JOIN information_schema.key_column_usage kcu &#xD;&#xA;                                  ON tc.constraint_name = kcu.constraint_name&#xD;&#xA;                                WHERE tc.table_schema = &#x27;public&#x27; &#xD;&#xA;                                  AND tc.table_name = p_table_name &#xD;&#xA;                                  AND tc.constraint_type = &#x27;PRIMARY KEY&#x27;;&#xD;&#xA;&#xD;&#xA;                                IF pk_cols IS NOT NULL THEN&#xD;&#xA;                                    col_defs := col_defs || format(&#x27;PRIMARY KEY (%s), &#x27;, pk_cols);&#xD;&#xA;                                END IF;&#xD;&#xA;&#xD;&#xA;                                col_defs := left(col_defs, length(col_defs) - 2);&#xD;&#xA;                                result := format(&#x27;CREATE TABLE &quot;%s&quot; (%s);&#x27;, p_table_name, col_defs);&#xD;&#xA;                                RETURN result;&#xD;&#xA;                            END;&#xD;&#xA;                            $function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.pg_get_tabledef(p_table_name text)&#xA; RETURNS text&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;                            DECLARE&#xD;&#xA;                                col RECORD;&#xD;&#xA;                                col_defs TEXT := &#x27;&#x27;;&#xD;&#xA;                                pk_cols TEXT := &#x27;&#x27;;&#xD;&#xA;                                result TEXT;&#xD;&#xA;                            BEGIN&#xD;&#xA;                                FOR col IN&#xD;&#xA;                                    SELECT &#xD;&#xA;                                        column_name,&#xD;&#xA;                                        data_type,&#xD;&#xA;                                        character_maximum_length,&#xD;&#xA;                                        numeric_precision,&#xD;&#xA;                                        numeric_scale,&#xD;&#xA;                                        is_nullable,&#xD;&#xA;                                        column_default&#xD;&#xA;                                    FROM information_schema.columns&#xD;&#xA;                                    WHERE table_schema = &#x27;public&#x27; AND table_name = p_table_name&#xD;&#xA;                                    ORDER BY ordinal_position&#xD;&#xA;                                LOOP&#xD;&#xA;                                    col_defs := col_defs || &#xD;&#xA;                                        format(&#x27;&quot;%s&quot; %s%s%s%s, &#x27;,&#xD;&#xA;                                            col.column_name,&#xD;&#xA;                                            CASE &#xD;&#xA;                                                WHEN col.data_type = &#x27;character varying&#x27; THEN format(&#x27;varchar(%s)&#x27;, col.character_maximum_length)&#xD;&#xA;                                                WHEN col.data_type = &#x27;numeric&#x27; THEN format(&#x27;numeric(%s,%s)&#x27;, col.numeric_precision, col.numeric_scale)&#xD;&#xA;                                                ELSE col.data_type&#xD;&#xA;                                            END,&#xD;&#xA;                                            CASE WHEN col.column_default IS NOT NULL THEN &#x27; DEFAULT &#x27; || col.column_default ELSE &#x27;&#x27; END,&#xD;&#xA;                                            CASE WHEN col.is_nullable = &#x27;NO&#x27; THEN &#x27; NOT NULL&#x27; ELSE &#x27;&#x27; END,&#xD;&#xA;                                            &#x27;&#x27;&#xD;&#xA;                                        );&#xD;&#xA;                                END LOOP;&#xD;&#xA;&#xD;&#xA;                                -- Get primary key columns&#xD;&#xA;                                SELECT string_agg(format(&#x27;&quot;%s&quot;&#x27;, kcu.column_name), &#x27;, &#x27;)&#xD;&#xA;                                INTO pk_cols&#xD;&#xA;                                FROM information_schema.table_constraints tc&#xD;&#xA;                                JOIN information_schema.key_column_usage kcu &#xD;&#xA;                                  ON tc.constraint_name = kcu.constraint_name&#xD;&#xA;                                WHERE tc.table_schema = &#x27;public&#x27; &#xD;&#xA;                                  AND tc.table_name = p_table_name &#xD;&#xA;                                  AND tc.constraint_type = &#x27;PRIMARY KEY&#x27;;&#xD;&#xA;&#xD;&#xA;                                IF pk_cols IS NOT NULL THEN&#xD;&#xA;                                    col_defs := col_defs || format(&#x27;PRIMARY KEY (%s), &#x27;, pk_cols);&#xD;&#xA;                                END IF;&#xD;&#xA;&#xD;&#xA;                                col_defs := left(col_defs, length(col_defs) - 2);&#xD;&#xA;                                result := format(&#x27;CREATE TABLE &quot;%s&quot; (%s);&#x27;, p_table_name, col_defs);&#xD;&#xA;                                RETURN result;&#xD;&#xA;                            END;&#xD;&#xA;                            $function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="mismatch" data-comparison="Not Matching">
                    <td>Function</td>
                    <td>get_ledger_report</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Not Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-68')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-68">
                                            CREATE OR REPLACE FUNCTION public.get_ledger_report(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(sl_no integer, ledger text, general_ledger text, opening_balance numeric, total_debit numeric, total_credit numeric, closing_balance numeric, parent_ledger text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;DECLARE&#xD;&#xA;    v_start_date DATE;&#xD;&#xA;    v_end_date DATE;&#xD;&#xA;BEGIN&#xD;&#xA;    -- Get financial year start and end date if not provided&#xD;&#xA;    SELECT fy.start_date, fy.end_date &#xD;&#xA;    INTO v_start_date, v_end_date&#xD;&#xA;    FROM public.finance_year fy&#xD;&#xA;    WHERE fy.id = p_fin_year_id&#xD;&#xA;    LIMIT 1;&#xD;&#xA;&#xD;&#xA;    -- Override with provided values if they are not NULL&#xD;&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xD;&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xD;&#xA;&#xD;&#xA;    RETURN QUERY&#xD;&#xA;    WITH trial_balance AS (&#xD;&#xA;        SELECT &#xD;&#xA;            account_type AS account_category,&#xD;&#xA;            account_number,&#xD;&#xA;            account_name,&#xD;&#xA;            debit,&#xD;&#xA;            credit&#xD;&#xA;        FROM public.get_trial_balance_by_date_range(&#xD;&#xA;            p_company_id, p_fin_year_id, v_start_date, v_end_date&#xD;&#xA;        )&#xD;&#xA;    ),&#xD;&#xA;    opening_balances AS (&#xD;&#xA;        SELECT &#xD;&#xA;            je.account_id::TEXT AS account_id,&#xD;&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE -je.amount END) AS opening_balance&#xD;&#xA;        FROM public.journal_entries je&#xD;&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xD;&#xA;        WHERE th.company_id = p_company_id&#xD;&#xA;          AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xD;&#xA;        GROUP BY je.account_id&#xD;&#xA;    )&#xD;&#xA;    SELECT &#xD;&#xA;        CAST(ROW_NUMBER() OVER() AS INTEGER) AS sl_no, &#xD;&#xA;        tb.account_name AS ledger,&#xD;&#xA;        tb.account_category AS general_ledger,&#xD;&#xA;        COALESCE(ob.opening_balance, 0) AS opening_balance,&#xD;&#xA;        COALESCE(tb.debit, 0) AS total_debit,&#xD;&#xA;        COALESCE(tb.credit, 0) AS total_credit,&#xD;&#xA;        COALESCE(ob.opening_balance, 0) &#x2B; COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0) AS closing_balance,&#xD;&#xA;        CASE &#xD;&#xA;            WHEN tb.account_category IN (&#x27;Assets&#x27;, &#x27;Current Assets&#x27;, &#x27;Non-Current Assets&#x27;, &#x27;Cash&#x27;, &#x27;Bank&#x27;) THEN &#x27;Asset&#x27;&#xD;&#xA;            WHEN tb.account_category IN (&#x27;Liabilities&#x27;, &#x27;Current Liabilities&#x27;, &#x27;Non-Current Liabilities&#x27;) THEN &#x27;Liability&#x27;&#xD;&#xA;            WHEN tb.account_category IN (&#x27;Revenue&#x27;, &#x27;Sales Revenue&#x27;, &#x27;Service Revenue&#x27;, &#x27;Non Member Income&#x27;, &#x27;Member Income&#x27;) THEN &#x27;Income&#x27;&#xD;&#xA;            WHEN tb.account_category IN (&#x27;Expenses&#x27;, &#x27;Direct Expenses&#x27;, &#x27;Indirect Expenses&#x27;, &#x27;Operating Expenses&#x27;, &#x27;Cost of Goods Sold&#x27;, &#x27;Non-Operating Expense&#x27;) THEN &#x27;Expense&#x27;&#xD;&#xA;            ELSE NULL&#xD;&#xA;        END AS parent_ledger&#xD;&#xA;    FROM trial_balance tb&#xD;&#xA;    LEFT JOIN opening_balances ob ON tb.account_number::TEXT = ob.account_id&#xD;&#xA;&#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Debtors Parent Row&#xD;&#xA;    SELECT 9999, &#x27;Sundry Debtors&#x27;, &#x27;Assets&#x27;, 0, 0, 0, 0, &#x27;Asset&#x27;&#xD;&#xA;    &#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Debtors Children&#xD;&#xA;    SELECT &#xD;&#xA;        sd.sl_no &#x2B; 10000,&#xD;&#xA;        sd.ledger, &#xD;&#xA;        sd.general_ledger, &#xD;&#xA;        sd.opening_balance, &#xD;&#xA;        sd.debit AS total_debit, &#xD;&#xA;        sd.credit AS total_credit, &#xD;&#xA;        sd.closing_balance, &#xD;&#xA;        &#x27;Asset&#x27;&#xD;&#xA;    FROM public.get_sundry_debtors_ledger(p_company_id, p_fin_year_id, v_start_date, v_end_date) sd&#xD;&#xA;&#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Creditors Parent Row&#xD;&#xA;    SELECT 9998, &#x27;Sundry Creditors&#x27;, &#x27;Liabilities&#x27;, 0, 0, 0, 0, &#x27;Liability&#x27;&#xD;&#xA;&#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Creditors Children&#xD;&#xA;    SELECT &#xD;&#xA;        sc.sl_no &#x2B; 20000,&#xD;&#xA;        sc.ledger, &#xD;&#xA;        sc.general_ledger, &#xD;&#xA;        sc.opening_balance, &#xD;&#xA;        sc.debit AS total_debit, &#xD;&#xA;        sc.credit AS total_credit, &#xD;&#xA;        sc.closing_balance, &#xD;&#xA;        &#x27;Liability&#x27;&#xD;&#xA;    FROM public.get_sundry_creditors_ledger(p_company_id, p_fin_year_id, v_start_date, v_end_date) sc&#xD;&#xA;&#xD;&#xA;    ORDER BY parent_ledger NULLS FIRST, ledger;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;
                                            CREATE OR REPLACE FUNCTION public.get_ledger_report(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(sl_no integer, ledger text, general_ledger text, opening_balance numeric, debit numeric, credit numeric, closing_balance numeric, parent_ledger text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xA;DECLARE&#xA;    v_start_date DATE;&#xA;    v_end_date DATE;&#xA;BEGIN&#xA;    -- Get financial year start and end date if not provided&#xA;    SELECT fy.start_date, fy.end_date &#xA;    INTO v_start_date, v_end_date&#xA;    FROM public.finance_year fy&#xA;    WHERE fy.id = p_fin_year_id&#xA;    LIMIT 1;&#xA;&#xA;    -- Override with provided values if they are not NULL&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xA;&#xA;    RETURN QUERY&#xA;    WITH trial_balance AS (&#xA;    SELECT &#xA;        account_category,&#xA;        account_number,&#xA;        account_name,&#xA;        total_debits,&#xA;        total_credits&#xA;    FROM public.get_trial_balance_by_date_range(p_company_id, p_fin_year_id, v_start_date, v_end_date)&#xA;),&#xA;    opening_balances AS (&#xA;        SELECT &#xA;            je.account_id::TEXT AS account_id,&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE -je.amount END) AS opening_balance&#xA;        FROM public.journal_entries je&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xA;        WHERE th.company_id = p_company_id&#xA;          AND th.transaction_date BETWEEN v_start_date AND v_end_date  -- Fetch transactions before the period&#xA;        GROUP BY je.account_id&#xA;    )&#xA;    SELECT &#xA;        CAST(ROW_NUMBER() OVER() AS INTEGER) AS sl_no, &#xA;        tb.account_name AS ledger,&#xA;        tb.account_category AS general_ledger,&#xA;        COALESCE(ob.opening_balance, 0) AS opening_balance,&#xA;        COALESCE(tb.total_debits, 0) AS debit,&#xA;        COALESCE(tb.total_credits, 0) AS credit,&#xA;        COALESCE(ob.opening_balance, 0) &#x2B; COALESCE(tb.total_debits, 0) - COALESCE(tb.total_credits, 0) AS closing_balance,&#xA;&#xA;        -- Assign Parent Ledger based on General Ledger (Singular values)&#xA;        CASE &#xA;            WHEN tb.account_category = &#x27;Sundry Debtors&#x27; OR tb.account_category = &#x27;Assets&#x27; THEN &#x27;Asset&#x27;&#xA;            WHEN tb.account_category = &#x27;Sundry Creditors&#x27; OR tb.account_category = &#x27;Liabilities&#x27; THEN &#x27;Liability&#x27;&#xA;            WHEN tb.account_category = &#x27;Revenue&#x27; OR tb.account_category = &#x27;Income Accounts&#x27; THEN &#x27;Income&#x27;&#xA;            WHEN tb.account_category = &#x27;Expenses&#x27; OR tb.account_category = &#x27;Direct Expenses&#x27; OR tb.account_category = &#x27;Indirect Expenses&#x27; THEN &#x27;Expense&#x27;&#xA;            ELSE NULL&#xA;        END AS parent_ledger&#xA;&#xA;    FROM trial_balance tb&#xA;    LEFT JOIN opening_balances ob ON tb.account_number::TEXT = ob.account_id&#xA;    &#xA;    UNION ALL&#xA;    &#xA;    -- Sundry Debtors Parent Row&#xA;    SELECT 9999 AS sl_no, &#x27;Sundry Debtors&#x27; AS ledger, &#x27;Assets&#x27; AS general_ledger, &#xA;           0 AS opening_balance, 0 AS debit, 0 AS credit, 0 AS closing_balance, &#x27;Asset&#x27; AS parent_ledger&#xA;    &#xA;    UNION ALL&#xA;    &#xA;    -- Sundry Debtors Children&#xA;    SELECT CAST(sd.sl_no &#x2B; 10000 AS INTEGER) AS sl_no, -- Ensure unique sl_no&#xA;           sd.ledger, &#xA;           sd.general_ledger, &#xA;           sd.opening_balance, &#xA;           sd.debit, &#xA;           sd.credit, &#xA;           sd.closing_balance, &#xA;           &#x27;Asset&#x27; AS parent_ledger&#xA;    FROM public.get_sundry_debtors_ledger(p_company_id, p_fin_year_id, v_start_date, v_end_date) sd&#xA;    &#xA;    UNION ALL&#xA;    &#xA;    -- Sundry Creditors Parent Row&#xA;    SELECT 9998 AS sl_no, &#x27;Sundry Creditors&#x27; AS ledger, &#x27;Liabilities&#x27; AS general_ledger, &#xA;           0 AS opening_balance, 0 AS debit, 0 AS credit, 0 AS closing_balance, &#x27;Liability&#x27; AS parent_ledger&#xA;    &#xA;    UNION ALL&#xA;    &#xA;    -- Sundry Creditors Children&#xA;    SELECT CAST(sc.sl_no &#x2B; 20000 AS INTEGER) AS sl_no, -- Ensure unique sl_no&#xA;           sc.ledger, &#xA;           sc.general_ledger, &#xA;           sc.opening_balance, &#xA;           sc.debit, &#xA;           sc.credit, &#xA;           sc.closing_balance, &#xA;           &#x27;Liability&#x27; AS parent_ledger&#xA;    FROM public.get_sundry_creditors_ledger(p_company_id, p_fin_year_id, v_start_date, v_end_date) sc&#xA;    &#xA;    ORDER BY parent_ledger NULLS FIRST, ledger;&#xA;END;&#xA;$function$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Function</td>
                    <td>get_account_transactions</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Function</td>
                    <td>get_all_coa_with_pi</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Function</td>
                    <td>get_cash_flow</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Function</td>
                    <td>get_dashboard_totals_by_company_id</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Function</td>
                    <td>get_expense_overview</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Function</td>
                    <td>get_trial_balance_of_company_fin_year</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Function</td>
                    <td>get_dashboard_totals_test</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>create_company1</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-69')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-69">
                                            CREATE OR REPLACE PROCEDURE public.create_company1(IN p_id uuid, IN p_organization_id uuid, IN p_name text, IN p_description text, IN p_account_id uuid, IN p_gstin text, IN p_pan text, IN p_tan text, IN p_currency text, IN p_short_name text, IN p_tag_line text, IN p_proprietor_name text, IN p_outstanding_limit numeric, IN p_is_non_work boolean, IN p_interest_percentage numeric, IN p_created_by uuid, IN p_created_on_utc timestamp without time zone)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    INSERT INTO public.companies (&#xA;        id, organization_id, name, description, account_id, gstin, pan, tan, &#xA;        currency, short_name, tag_line, proprietor_name, outstanding_limit, &#xA;        is_non_work, interest_percentage, created_on_utc, created_by, modified_by&#xA;    ) VALUES (&#xA;        p_id, p_organization_id, p_name, p_description, p_account_id, p_gstin, &#xA;        p_pan, p_tan, p_currency, p_short_name, p_tag_line, p_proprietor_name, &#xA;        p_outstanding_limit, p_is_non_work, p_interest_percentage, &#xA;        p_created_on_utc, p_created_by&#xA;    );&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.create_company1(IN p_id uuid, IN p_organization_id uuid, IN p_name text, IN p_description text, IN p_account_id uuid, IN p_gstin text, IN p_pan text, IN p_tan text, IN p_currency text, IN p_short_name text, IN p_tag_line text, IN p_proprietor_name text, IN p_outstanding_limit numeric, IN p_is_non_work boolean, IN p_interest_percentage numeric, IN p_created_by uuid, IN p_created_on_utc timestamp without time zone)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    INSERT INTO public.companies (&#xA;        id, organization_id, name, description, account_id, gstin, pan, tan, &#xA;        currency, short_name, tag_line, proprietor_name, outstanding_limit, &#xA;        is_non_work, interest_percentage, created_on_utc, created_by, modified_by&#xA;    ) VALUES (&#xA;        p_id, p_organization_id, p_name, p_description, p_account_id, p_gstin, &#xA;        p_pan, p_tan, p_currency, p_short_name, p_tag_line, p_proprietor_name, &#xA;        p_outstanding_limit, p_is_non_work, p_interest_percentage, &#xA;        p_created_on_utc, p_created_by&#xA;    );&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_company_finance_years</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-70')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-70">
                                            CREATE OR REPLACE PROCEDURE public.insert_company_finance_years(IN p_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_finance_year_id INTEGER;&#xA;    v_prev_finance_year_id INTEGER;&#xA;    v_next_finance_year_id INTEGER;&#xA;BEGIN&#xA;    -- Get the financial year ID based on the current date&#xA;    SELECT id INTO v_finance_year_id&#xA;    FROM finance_year&#xA;    WHERE start_date &lt;= NOW() AND end_date &gt;= NOW();&#xA;&#xA;    -- Get the previous financial year ID&#xA;    SELECT id INTO v_prev_finance_year_id&#xA;    FROM finance_year&#xA;    WHERE id = v_finance_year_id - 1;&#xA;&#xA;    -- Get the next financial year ID&#xA;    SELECT id INTO v_next_finance_year_id&#xA;    FROM finance_year&#xA;    WHERE id = v_finance_year_id &#x2B; 1;&#xA;&#xA;    -- Ensure the sequence is correctly set&#xA;    PERFORM setval(&#xA;        &#x27;company_finance_year_id_seq&#x27;,&#xA;        (SELECT COALESCE(MAX(id), 0) FROM company_finance_year),&#xA;        true&#xA;    );&#xA;&#xA;    -- Insert for the current financial year&#xA;    IF v_finance_year_id IS NOT NULL THEN&#xA;        INSERT INTO company_finance_year (&#xA;            id, &#xA;            company_id, &#xA;            finance_year_id&#xA;        ) VALUES (&#xA;            nextval(&#x27;company_finance_year_id_seq&#x27;),&#xA;            p_company_id,&#xA;            v_finance_year_id&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Insert for the previous financial year&#xA;    IF v_prev_finance_year_id IS NOT NULL THEN&#xA;        INSERT INTO company_finance_year (&#xA;            id, &#xA;            company_id, &#xA;            finance_year_id&#xA;        ) VALUES (&#xA;            nextval(&#x27;company_finance_year_id_seq&#x27;),&#xA;            p_company_id,&#xA;            v_prev_finance_year_id&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Insert for the next financial year&#xA;    IF v_next_finance_year_id IS NOT NULL THEN&#xA;        INSERT INTO company_finance_year (&#xA;            id, &#xA;            company_id, &#xA;            finance_year_id&#xA;        ) VALUES (&#xA;            nextval(&#x27;company_finance_year_id_seq&#x27;),&#xA;            p_company_id,&#xA;            v_next_finance_year_id&#xA;        );&#xA;    END IF;&#xA;&#xA;    RAISE NOTICE &#x27;Data inserted for company_id: %&#x27;, p_company_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_company_finance_years(IN p_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_finance_year_id INTEGER;&#xA;    v_prev_finance_year_id INTEGER;&#xA;    v_next_finance_year_id INTEGER;&#xA;BEGIN&#xA;    -- Get the financial year ID based on the current date&#xA;    SELECT id INTO v_finance_year_id&#xA;    FROM finance_year&#xA;    WHERE start_date &lt;= NOW() AND end_date &gt;= NOW();&#xA;&#xA;    -- Get the previous financial year ID&#xA;    SELECT id INTO v_prev_finance_year_id&#xA;    FROM finance_year&#xA;    WHERE id = v_finance_year_id - 1;&#xA;&#xA;    -- Get the next financial year ID&#xA;    SELECT id INTO v_next_finance_year_id&#xA;    FROM finance_year&#xA;    WHERE id = v_finance_year_id &#x2B; 1;&#xA;&#xA;    -- Ensure the sequence is correctly set&#xA;    PERFORM setval(&#xA;        &#x27;company_finance_year_id_seq&#x27;,&#xA;        (SELECT COALESCE(MAX(id), 0) FROM company_finance_year),&#xA;        true&#xA;    );&#xA;&#xA;    -- Insert for the current financial year&#xA;    IF v_finance_year_id IS NOT NULL THEN&#xA;        INSERT INTO company_finance_year (&#xA;            id, &#xA;            company_id, &#xA;            finance_year_id&#xA;        ) VALUES (&#xA;            nextval(&#x27;company_finance_year_id_seq&#x27;),&#xA;            p_company_id,&#xA;            v_finance_year_id&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Insert for the previous financial year&#xA;    IF v_prev_finance_year_id IS NOT NULL THEN&#xA;        INSERT INTO company_finance_year (&#xA;            id, &#xA;            company_id, &#xA;            finance_year_id&#xA;        ) VALUES (&#xA;            nextval(&#x27;company_finance_year_id_seq&#x27;),&#xA;            p_company_id,&#xA;            v_prev_finance_year_id&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Insert for the next financial year&#xA;    IF v_next_finance_year_id IS NOT NULL THEN&#xA;        INSERT INTO company_finance_year (&#xA;            id, &#xA;            company_id, &#xA;            finance_year_id&#xA;        ) VALUES (&#xA;            nextval(&#x27;company_finance_year_id_seq&#x27;),&#xA;            p_company_id,&#xA;            v_next_finance_year_id&#xA;        );&#xA;    END IF;&#xA;&#xA;    RAISE NOTICE &#x27;Data inserted for company_id: %&#x27;, p_company_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_bank_statement_by_excel</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-71')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-71">
                                            CREATE OR REPLACE PROCEDURE public.insert_bank_statement_by_excel(IN p_company_id uuid, IN p_txn_date date, IN p_cheque_number text, IN p_description text, IN p_value_date date, IN p_branch_code text, IN p_debit_amount numeric, IN p_credit_amount numeric, IN p_balance numeric, IN p_bank_id uuid, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xD;&#xA;DECLARE&#xD;&#xA;    existing_id INT;&#xD;&#xA;BEGIN&#xD;&#xA;    -- Check if a record with same txn_date and description already exists for the company and bank&#xD;&#xA;    SELECT id INTO existing_id&#xD;&#xA;    FROM public.bank_statements&#xD;&#xA;    WHERE company_id = p_company_id&#xD;&#xA;      AND bank_id = p_bank_id&#xD;&#xA;      AND txn_date = p_txn_date&#xD;&#xA;      AND description = p_description&#xD;&#xA;      AND is_deleted = false&#xD;&#xA;    LIMIT 1;&#xD;&#xA;&#xD;&#xA;    IF existing_id IS NOT NULL THEN&#xD;&#xA;        -- Update the existing record&#xD;&#xA;        UPDATE public.bank_statements&#xD;&#xA;        SET&#xD;&#xA;            cheque_number = p_cheque_number,&#xD;&#xA;            value_date = p_value_date,&#xD;&#xA;            branch_code = p_branch_code,&#xD;&#xA;            debit_amount = p_debit_amount,&#xD;&#xA;            credit_amount = p_credit_amount,&#xD;&#xA;            balance = p_balance,&#xD;&#xA;            modified_by = p_created_by,&#xD;&#xA;            modified_on_utc = (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp&#xD;&#xA;        WHERE id = existing_id;&#xD;&#xA;&#xD;&#xA;        RAISE NOTICE &#x27;Updated existing bank statement with ID: %&#x27;, existing_id;&#xD;&#xA;    ELSE&#xD;&#xA;        -- Insert a new record (let PostgreSQL handle ID generation)&#xD;&#xA;        INSERT INTO public.bank_statements (&#xD;&#xA;            company_id,&#xD;&#xA;            txn_date,&#xD;&#xA;            cheque_number,&#xD;&#xA;            description,&#xD;&#xA;            value_date,&#xD;&#xA;            branch_code,&#xD;&#xA;            debit_amount,&#xD;&#xA;            credit_amount,&#xD;&#xA;            balance,&#xD;&#xA;            bank_id,&#xD;&#xA;            created_by,&#xD;&#xA;            created_on_utc,&#xD;&#xA;            is_deleted&#xD;&#xA;        ) VALUES (&#xD;&#xA;            p_company_id,&#xD;&#xA;            p_txn_date,&#xD;&#xA;            p_cheque_number,&#xD;&#xA;            p_description,&#xD;&#xA;            p_value_date,&#xD;&#xA;            p_branch_code,&#xD;&#xA;            p_debit_amount,&#xD;&#xA;            p_credit_amount,&#xD;&#xA;            p_balance,&#xD;&#xA;            p_bank_id,&#xD;&#xA;            p_created_by,&#xD;&#xA;            (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp,&#xD;&#xA;            false&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        RAISE NOTICE &#x27;Inserted new bank statement&#x27;;&#xD;&#xA;    END IF;&#xD;&#xA;EXCEPTION&#xD;&#xA;    WHEN OTHERS THEN&#xD;&#xA;        RAISE EXCEPTION &#x27;Bank Statement insert/update failed: %&#x27;, SQLERRM;&#xD;&#xA;END;&#xD;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_bank_statement_by_excel(IN p_company_id uuid, IN p_txn_date date, IN p_cheque_number text, IN p_description text, IN p_value_date date, IN p_branch_code text, IN p_debit_amount numeric, IN p_credit_amount numeric, IN p_balance numeric, IN p_bank_id uuid, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xD;&#xA;DECLARE&#xD;&#xA;    existing_id INT;&#xD;&#xA;BEGIN&#xD;&#xA;    -- Check if a record with same txn_date and description already exists for the company and bank&#xD;&#xA;    SELECT id INTO existing_id&#xD;&#xA;    FROM public.bank_statements&#xD;&#xA;    WHERE company_id = p_company_id&#xD;&#xA;      AND bank_id = p_bank_id&#xD;&#xA;      AND txn_date = p_txn_date&#xD;&#xA;      AND description = p_description&#xD;&#xA;      AND is_deleted = false&#xD;&#xA;    LIMIT 1;&#xD;&#xA;&#xD;&#xA;    IF existing_id IS NOT NULL THEN&#xD;&#xA;        -- Update the existing record&#xD;&#xA;        UPDATE public.bank_statements&#xD;&#xA;        SET&#xD;&#xA;            cheque_number = p_cheque_number,&#xD;&#xA;            value_date = p_value_date,&#xD;&#xA;            branch_code = p_branch_code,&#xD;&#xA;            debit_amount = p_debit_amount,&#xD;&#xA;            credit_amount = p_credit_amount,&#xD;&#xA;            balance = p_balance,&#xD;&#xA;            modified_by = p_created_by,&#xD;&#xA;            modified_on_utc = (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp&#xD;&#xA;        WHERE id = existing_id;&#xD;&#xA;&#xD;&#xA;        RAISE NOTICE &#x27;Updated existing bank statement with ID: %&#x27;, existing_id;&#xD;&#xA;    ELSE&#xD;&#xA;        -- Insert a new record (let PostgreSQL handle ID generation)&#xD;&#xA;        INSERT INTO public.bank_statements (&#xD;&#xA;            company_id,&#xD;&#xA;            txn_date,&#xD;&#xA;            cheque_number,&#xD;&#xA;            description,&#xD;&#xA;            value_date,&#xD;&#xA;            branch_code,&#xD;&#xA;            debit_amount,&#xD;&#xA;            credit_amount,&#xD;&#xA;            balance,&#xD;&#xA;            bank_id,&#xD;&#xA;            created_by,&#xD;&#xA;            created_on_utc,&#xD;&#xA;            is_deleted&#xD;&#xA;        ) VALUES (&#xD;&#xA;            p_company_id,&#xD;&#xA;            p_txn_date,&#xD;&#xA;            p_cheque_number,&#xD;&#xA;            p_description,&#xD;&#xA;            p_value_date,&#xD;&#xA;            p_branch_code,&#xD;&#xA;            p_debit_amount,&#xD;&#xA;            p_credit_amount,&#xD;&#xA;            p_balance,&#xD;&#xA;            p_bank_id,&#xD;&#xA;            p_created_by,&#xD;&#xA;            (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp,&#xD;&#xA;            false&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        RAISE NOTICE &#x27;Inserted new bank statement&#x27;;&#xD;&#xA;    END IF;&#xD;&#xA;EXCEPTION&#xD;&#xA;    WHEN OTHERS THEN&#xD;&#xA;        RAISE EXCEPTION &#x27;Bank Statement insert/update failed: %&#x27;, SQLERRM;&#xD;&#xA;END;&#xD;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Procedure</td>
                    <td>dummy_log_procedure</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>copy_user_permissions</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-72')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-72">
                                            CREATE OR REPLACE PROCEDURE public.copy_user_permissions(IN p_source_user_id uuid, IN p_target_user_id uuid, IN p_created_by uuid, IN p_is_override boolean)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_new_id INTEGER;&#xA;BEGIN&#xA;    -- If override is true, delete existing permissions for the target user&#xA;    IF p_is_override THEN&#xA;        DELETE FROM public.user_permissions&#xA;        WHERE user_id = p_target_user_id;&#xA;    END IF;&#xA;&#xA;    -- Get the current maximum id from user_permissions&#xA;    SELECT COALESCE(MAX(id), 0) INTO v_new_id FROM public.user_permissions;&#xA;&#xA;    -- Insert permissions from the source user to the target user, with checks to avoid duplicates and child assignments if parent exists&#xA;    INSERT INTO public.user_permissions (&#xA;        id,&#xA;        user_id,&#xA;        organization_id,&#xA;        permission_id,&#xA;        created_on_utc,&#xA;        created_by&#xA;    )&#xA;    SELECT&#xA;        v_new_id &#x2B; ROW_NUMBER() OVER (),  -- generate incremented ids starting from max_id &#x2B; 1&#xA;        p_target_user_id,&#xA;        up.organization_id,&#xA;        up.permission_id,&#xA;        NOW(), &#xA;        p_created_by&#xA;    FROM&#xA;        public.user_permissions AS up&#xA;    WHERE&#xA;        up.user_id = p_source_user_id&#xA;        AND up.is_deleted = false&#xA;        -- Avoid assigning child permissions if a parent permission is already assigned&#xA;        AND NOT EXISTS (&#xA;            SELECT 1 &#xA;            FROM public.user_permissions AS target_up&#xA;            JOIN public.permissions AS parent_perm ON target_up.permission_id = parent_perm.id&#xA;            WHERE target_up.user_id = p_target_user_id&#xA;              AND parent_perm.id = up.permission_id&#xA;              AND parent_perm.parent_permission_id IS NULL  -- Checking only for root or parent permissions&#xA;              AND parent_perm.is_deleted = false&#xA;        )&#xA;        -- Avoid duplicate permission entries&#xA;        AND NOT EXISTS (&#xA;            SELECT 1 &#xA;            FROM public.user_permissions AS target_up&#xA;            WHERE target_up.user_id = p_target_user_id&#xA;              AND target_up.permission_id = up.permission_id&#xA;              AND target_up.is_deleted = false&#xA;        );&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.copy_user_permissions(IN p_source_user_id uuid, IN p_target_user_id uuid, IN p_created_by uuid, IN p_is_override boolean)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_new_id INTEGER;&#xA;BEGIN&#xA;    -- If override is true, delete existing permissions for the target user&#xA;    IF p_is_override THEN&#xA;        DELETE FROM public.user_permissions&#xA;        WHERE user_id = p_target_user_id;&#xA;    END IF;&#xA;&#xA;    -- Get the current maximum id from user_permissions&#xA;    SELECT COALESCE(MAX(id), 0) INTO v_new_id FROM public.user_permissions;&#xA;&#xA;    -- Insert permissions from the source user to the target user, with checks to avoid duplicates and child assignments if parent exists&#xA;    INSERT INTO public.user_permissions (&#xA;        id,&#xA;        user_id,&#xA;        organization_id,&#xA;        permission_id,&#xA;        created_on_utc,&#xA;        created_by&#xA;    )&#xA;    SELECT&#xA;        v_new_id &#x2B; ROW_NUMBER() OVER (),  -- generate incremented ids starting from max_id &#x2B; 1&#xA;        p_target_user_id,&#xA;        up.organization_id,&#xA;        up.permission_id,&#xA;        NOW(), &#xA;        p_created_by&#xA;    FROM&#xA;        public.user_permissions AS up&#xA;    WHERE&#xA;        up.user_id = p_source_user_id&#xA;        AND up.is_deleted = false&#xA;        -- Avoid assigning child permissions if a parent permission is already assigned&#xA;        AND NOT EXISTS (&#xA;            SELECT 1 &#xA;            FROM public.user_permissions AS target_up&#xA;            JOIN public.permissions AS parent_perm ON target_up.permission_id = parent_perm.id&#xA;            WHERE target_up.user_id = p_target_user_id&#xA;              AND parent_perm.id = up.permission_id&#xA;              AND parent_perm.parent_permission_id IS NULL  -- Checking only for root or parent permissions&#xA;              AND parent_perm.is_deleted = false&#xA;        )&#xA;        -- Avoid duplicate permission entries&#xA;        AND NOT EXISTS (&#xA;            SELECT 1 &#xA;            FROM public.user_permissions AS target_up&#xA;            WHERE target_up.user_id = p_target_user_id&#xA;              AND target_up.permission_id = up.permission_id&#xA;              AND target_up.is_deleted = false&#xA;        );&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>create_organization</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-73')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-73">
                                            CREATE OR REPLACE PROCEDURE public.create_organization(IN p_id uuid, IN p_name text, IN p_description text, IN p_phone_number text, IN p_email text, IN p_address_line text, IN p_gstin text, IN p_tag_line text, IN p_city_id uuid, IN p_short_name text, IN p_pan text, IN p_tan text, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Step 1: Insert into organizations table&#xA;    INSERT INTO public.organizations (&#xA;        id, &#xA;        name, &#xA;        description, &#xA;        phone_number, &#xA;        email, &#xA;        address_line, &#xA;        gstin, &#xA;        tag_line, &#xA;        city_id, &#xA;        short_name, &#xA;        pan, &#xA;        tan,&#xA;        outstanding_limit,&#xA;        is_non_work,&#xA;        interest_percentage,&#xA;        created_on_utc, &#xA;        created_by&#xA;    ) VALUES (&#xA;        p_id,                -- Organization ID&#xA;        p_name,              -- Organization Name&#xA;        p_description,       -- Description&#xA;        p_phone_number,      -- Phone Number&#xA;        p_email,             -- Email&#xA;        p_address_line,      -- Address Line&#xA;        p_gstin,             -- GSTIN&#xA;        p_tag_line,          -- Tag Line&#xA;        p_city_id,           -- City ID&#xA;        p_short_name,        -- Short Name&#xA;        p_pan,               -- PAN&#xA;        p_tan,               -- TAN&#xA;        0,                   -- Outstanding Limit&#xA;        false,               -- Is Non-Work&#xA;        0,                   -- Interest Percentage&#xA;        NOW(),               -- Created On Timestamp&#xA;        p_created_by         -- Created By&#xA;    );&#xA;&#xA;    -- Notify the successful creation of the organization&#xA;    RAISE NOTICE &#x27;Organization created successfully with ID: %&#x27;, p_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.create_organization(IN p_id uuid, IN p_name text, IN p_description text, IN p_phone_number text, IN p_email text, IN p_address_line text, IN p_gstin text, IN p_tag_line text, IN p_city_id uuid, IN p_short_name text, IN p_pan text, IN p_tan text, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Step 1: Insert into organizations table&#xA;    INSERT INTO public.organizations (&#xA;        id, &#xA;        name, &#xA;        description, &#xA;        phone_number, &#xA;        email, &#xA;        address_line, &#xA;        gstin, &#xA;        tag_line, &#xA;        city_id, &#xA;        short_name, &#xA;        pan, &#xA;        tan,&#xA;        outstanding_limit,&#xA;        is_non_work,&#xA;        interest_percentage,&#xA;        created_on_utc, &#xA;        created_by&#xA;    ) VALUES (&#xA;        p_id,                -- Organization ID&#xA;        p_name,              -- Organization Name&#xA;        p_description,       -- Description&#xA;        p_phone_number,      -- Phone Number&#xA;        p_email,             -- Email&#xA;        p_address_line,      -- Address Line&#xA;        p_gstin,             -- GSTIN&#xA;        p_tag_line,          -- Tag Line&#xA;        p_city_id,           -- City ID&#xA;        p_short_name,        -- Short Name&#xA;        p_pan,               -- PAN&#xA;        p_tan,               -- TAN&#xA;        0,                   -- Outstanding Limit&#xA;        false,               -- Is Non-Work&#xA;        0,                   -- Interest Percentage&#xA;        NOW(),               -- Created On Timestamp&#xA;        p_created_by         -- Created By&#xA;    );&#xA;&#xA;    -- Notify the successful creation of the organization&#xA;    RAISE NOTICE &#x27;Organization created successfully with ID: %&#x27;, p_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>delete_journal_entries_by_account</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-74')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-74">
                                            CREATE OR REPLACE PROCEDURE public.delete_journal_entries_by_account(IN p_account_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    DELETE FROM ONLY public.journal_entries &#xA;    WHERE account_id = p_account_id;&#xA;&#xA;    RAISE NOTICE &#x27;Deleted entries for Account ID: %&#x27;, p_account_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.delete_journal_entries_by_account(IN p_account_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    DELETE FROM ONLY public.journal_entries &#xA;    WHERE account_id = p_account_id;&#xA;&#xA;    RAISE NOTICE &#x27;Deleted entries for Account ID: %&#x27;, p_account_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>delete_journal_entries_by_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-75')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-75">
                                            CREATE OR REPLACE PROCEDURE public.delete_journal_entries_by_accounts(IN p_account_ids uuid[])&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    DELETE FROM ONLY public.journal_entries &#xA;    WHERE account_id = ANY(p_account_ids);&#xA;&#xA;    RAISE NOTICE &#x27;Deleted entries for Account IDs: %&#x27;, p_account_ids;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.delete_journal_entries_by_accounts(IN p_account_ids uuid[])&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    DELETE FROM ONLY public.journal_entries &#xA;    WHERE account_id = ANY(p_account_ids);&#xA;&#xA;    RAISE NOTICE &#x27;Deleted entries for Account IDs: %&#x27;, p_account_ids;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>delete_journal_vouchers_by_company</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-76')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-76">
                                            CREATE OR REPLACE PROCEDURE public.delete_journal_vouchers_by_company(IN p_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Delete from journal_voucher_details first to maintain referential integrity&#xA;    DELETE FROM public.journal_voucher_details&#xA;    WHERE journal_header_id IN (&#xA;        SELECT id FROM public.journal_voucher_headers WHERE company_id = p_company_id&#xA;    );&#xA;&#xA;    -- Delete from journal_voucher_headers&#xA;    DELETE FROM public.journal_voucher_headers&#xA;    WHERE company_id = p_company_id;&#xA;&#xA;    RAISE NOTICE &#x27;Data deleted successfully for company_id: %&#x27;, p_company_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.delete_journal_vouchers_by_company(IN p_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Delete from journal_voucher_details first to maintain referential integrity&#xA;    DELETE FROM public.journal_voucher_details&#xA;    WHERE journal_header_id IN (&#xA;        SELECT id FROM public.journal_voucher_headers WHERE company_id = p_company_id&#xA;    );&#xA;&#xA;    -- Delete from journal_voucher_headers&#xA;    DELETE FROM public.journal_voucher_headers&#xA;    WHERE company_id = p_company_id;&#xA;&#xA;    RAISE NOTICE &#x27;Data deleted successfully for company_id: %&#x27;, p_company_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>delete_transactions_by_company</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-77')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-77">
                                            CREATE OR REPLACE PROCEDURE public.delete_transactions_by_company(IN p_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Delete from journal_entries first to maintain referential integrity&#xA;    DELETE FROM public.journal_entries&#xA;    WHERE transaction_id IN (&#xA;        SELECT id FROM public.transaction_headers WHERE company_id = p_company_id&#xA;    );&#xA;&#xA;    -- Delete from transaction_headers&#xA;    DELETE FROM public.transaction_headers&#xA;    WHERE company_id = p_company_id;&#xA;&#xA;    RAISE NOTICE &#x27;Data deleted successfully for company_id: %&#x27;, p_company_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.delete_transactions_by_company(IN p_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Delete from journal_entries first to maintain referential integrity&#xA;    DELETE FROM public.journal_entries&#xA;    WHERE transaction_id IN (&#xA;        SELECT id FROM public.transaction_headers WHERE company_id = p_company_id&#xA;    );&#xA;&#xA;    -- Delete from transaction_headers&#xA;    DELETE FROM public.transaction_headers&#xA;    WHERE company_id = p_company_id;&#xA;&#xA;    RAISE NOTICE &#x27;Data deleted successfully for company_id: %&#x27;, p_company_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>get_all_chart_of_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-78')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-78">
                                            CREATE OR REPLACE PROCEDURE public.get_all_chart_of_accounts()&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;&#xA;                begin&#xA;                    select * from chart_of_accounts;&#xA;                end;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.get_all_chart_of_accounts()&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;&#xA;                begin&#xA;                    select * from chart_of_accounts;&#xA;                end;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_transaction_and_journal_entries</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-79')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-79">
                                            CREATE OR REPLACE PROCEDURE public.insert_transaction_and_journal_entries(IN p_company_id uuid, IN p_customer_id uuid, IN p_vendor_id uuid, IN p_employee_id uuid, IN p_transaction_date date, IN p_transaction_source_type integer, IN p_status_id integer, IN p_document_id uuid, IN p_document_number character varying, IN p_description text, IN p_created_by uuid, IN journal_entries_data jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    transaction_id BIGINT;&#xA;    journal_entry JSONB;&#xA;BEGIN&#xA;        INSERT INTO public.transaction_headers (&#xA;            company_id,&#xA;            customer_id,&#xA;            vendor_id,&#xA;            employee_id,&#xA;            transaction_date,&#xA;            transaction_source_type,&#xA;            status_id,&#xA;            document_id,&#xA;            document_number,&#xA;            description,&#xA;            created_by,&#xA;            created_on_utc&#xA;        )&#xA;        VALUES (&#xA;            p_company_id,&#xA;            NULLIF(p_customer_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF(p_vendor_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF(p_employee_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            p_transaction_date,&#xA;            p_transaction_source_type,&#xA;            p_status_id,&#xA;            p_document_id,&#xA;            p_document_number,&#xA;            p_description,&#xA;            p_created_by,&#xA;            CURRENT_TIMESTAMP&#xA;        )&#xA;        RETURNING id INTO transaction_id;&#xA;&#xA;        -- Loop through each journal entry and insert&#xA;        FOR journal_entry IN SELECT * FROM jsonb_array_elements(journal_entries_data)&#xA;        LOOP&#xA;            RAISE NOTICE &#x27;transaction_date: %&#x27;, (journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::DATE;&#xA;            INSERT INTO public.journal_entries (&#xA;                transaction_id,&#xA;                account_id,&#xA;                transaction_date,&#xA;                amount,&#xA;                entry_type,&#xA;                description_template_id,&#xA;                dynamic_data,&#xA;                entry_source_id&#xA;            )&#xA;            VALUES (&#xA;                transaction_id,&#xA;                (journal_entry-&gt;&gt;&#x27;account_id&#x27;)::UUID,&#xA;                (journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::DATE,&#xA;                (journal_entry-&gt;&gt;&#x27;amount&#x27;)::DECIMAL,&#xA;                (journal_entry-&gt;&gt;&#x27;entry_type&#x27;)::CHAR,&#xA;                (journal_entry-&gt;&gt;&#x27;description_template_id&#x27;)::INT,&#xA;                (journal_entry-&gt;&gt;&#x27;dynamic_data&#x27;)::JSONB,&#xA;                (journal_entry-&gt;&gt;&#x27;entry_source_id&#x27;)::INT&#xA;            );&#xA;        END LOOP;&#xA;        &#xA;    EXCEPTION&#xA;        -- Catch any error and rollback the transaction&#xA;        WHEN OTHERS THEN&#xA;            RAISE EXCEPTION &#x27;Error occurred: %&#x27;, SQLERRM;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_transaction_and_journal_entries(IN p_company_id uuid, IN p_customer_id uuid, IN p_vendor_id uuid, IN p_employee_id uuid, IN p_transaction_date date, IN p_transaction_source_type integer, IN p_status_id integer, IN p_document_id uuid, IN p_document_number character varying, IN p_description text, IN p_created_by uuid, IN journal_entries_data jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    transaction_id BIGINT;&#xA;    journal_entry JSONB;&#xA;BEGIN&#xA;        INSERT INTO public.transaction_headers (&#xA;            company_id,&#xA;            customer_id,&#xA;            vendor_id,&#xA;            employee_id,&#xA;            transaction_date,&#xA;            transaction_source_type,&#xA;            status_id,&#xA;            document_id,&#xA;            document_number,&#xA;            description,&#xA;            created_by,&#xA;            created_on_utc&#xA;        )&#xA;        VALUES (&#xA;            p_company_id,&#xA;            NULLIF(p_customer_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF(p_vendor_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            NULLIF(p_employee_id, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;            p_transaction_date,&#xA;            p_transaction_source_type,&#xA;            p_status_id,&#xA;            p_document_id,&#xA;            p_document_number,&#xA;            p_description,&#xA;            p_created_by,&#xA;            CURRENT_TIMESTAMP&#xA;        )&#xA;        RETURNING id INTO transaction_id;&#xA;&#xA;        -- Loop through each journal entry and insert&#xA;        FOR journal_entry IN SELECT * FROM jsonb_array_elements(journal_entries_data)&#xA;        LOOP&#xA;            RAISE NOTICE &#x27;transaction_date: %&#x27;, (journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::DATE;&#xA;            INSERT INTO public.journal_entries (&#xA;                transaction_id,&#xA;                account_id,&#xA;                transaction_date,&#xA;                amount,&#xA;                entry_type,&#xA;                description_template_id,&#xA;                dynamic_data,&#xA;                entry_source_id&#xA;            )&#xA;            VALUES (&#xA;                transaction_id,&#xA;                (journal_entry-&gt;&gt;&#x27;account_id&#x27;)::UUID,&#xA;                (journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::DATE,&#xA;                (journal_entry-&gt;&gt;&#x27;amount&#x27;)::DECIMAL,&#xA;                (journal_entry-&gt;&gt;&#x27;entry_type&#x27;)::CHAR,&#xA;                (journal_entry-&gt;&gt;&#x27;description_template_id&#x27;)::INT,&#xA;                (journal_entry-&gt;&gt;&#x27;dynamic_data&#x27;)::JSONB,&#xA;                (journal_entry-&gt;&gt;&#x27;entry_source_id&#x27;)::INT&#xA;            );&#xA;        END LOOP;&#xA;        &#xA;    EXCEPTION&#xA;        -- Catch any error and rollback the transaction&#xA;        WHEN OTHERS THEN&#xA;            RAISE EXCEPTION &#x27;Error occurred: %&#x27;, SQLERRM;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>initialize_company</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-80')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-80">
                                            CREATE OR REPLACE PROCEDURE public.initialize_company(IN p_id uuid, IN p_organization_id uuid, IN p_name text, IN p_description text, IN p_gstin text, IN p_pan text, IN p_tan text, IN p_currency text, IN p_short_name text, IN p_tag_line text, IN p_proprietor_name text, IN p_phone_number character varying, IN p_email character varying, IN p_created_by uuid, IN p_user_id uuid, IN p_default_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_contact_id uuid := gen_random_uuid();&#xA;    v_company_contact_id uuid := gen_random_uuid();&#xA;    v_finance_year_id int;&#xA;    v_prev_finance_year_id INTEGER;&#xA;    v_next_finance_year_id INTEGER;&#xA;    DEFAULT_USER_ID CONSTANT uuid := &#x27;50fd5012-940b-4fec-ad0a-2ac900239c8b&#x27;;&#xA;    v_company_exists boolean;&#xA;    v_contact_exists boolean;&#xA;    v_company_contact_exists boolean;&#xA;    v_user_company_exists boolean;&#xA;    v_default_user_company_exists boolean;&#xA;BEGIN&#xA;    -- Check if company already exists&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM public.companies &#xA;        WHERE id = p_id &#xA;           OR (organization_id = p_organization_id AND name = p_name)&#xA;    ) INTO v_company_exists;&#xA;    &#xA;    IF NOT v_company_exists THEN&#xA;        -- Insert into companies table&#xA;        INSERT INTO public.companies (&#xA;            id, organization_id, name, description, gstin, pan, tan, &#xA;            currency, short_name, tag_line, proprietor_name, &#xA;            outstanding_limit, is_non_work, is_apartment, interest_percentage, &#xA;            created_on_utc, created_by&#xA;        ) VALUES (&#xA;            p_id, p_organization_id, p_name, p_description, p_gstin, p_pan, p_tan, &#xA;            p_currency, p_short_name, p_tag_line, p_proprietor_name, &#xA;            0, false, true, 0, NOW(), p_created_by&#xA;        );&#xA;        RAISE NOTICE &#x27;Company % created successfully.&#x27;, p_name;&#xA;    ELSE&#xA;        RAISE NOTICE &#x27;Company with ID %, name %, or GSTIN/PAN % already exists. Skipping company creation.&#x27;, &#xA;            p_id, p_name, p_gstin;&#xA;    END IF;&#xA;&#xA;    -- Check if contact already exists for this email/phone&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM contacts &#xA;        WHERE email = p_email OR phone_number = p_phone_number&#xA;    ) INTO v_contact_exists;&#xA;    &#xA;    IF NOT v_contact_exists THEN&#xA;        -- Insert contact&#xA;        INSERT INTO contacts (&#xA;            id, salutation, first_name, last_name, email, &#xA;            phone_number, mobile_number, is_primary, &#xA;            created_on_utc, created_by&#xA;        ) VALUES (&#xA;            v_contact_id, &#x27;Mr.&#x27;, p_proprietor_name, NULL, p_email, &#xA;            p_phone_number, p_phone_number, TRUE, &#xA;            NOW(), p_created_by&#xA;        );&#xA;        RAISE NOTICE &#x27;Contact created for company % with email %.&#x27;, p_name, p_email;&#xA;    ELSE&#xA;        -- Get existing contact ID&#xA;        SELECT id INTO v_contact_id &#xA;        FROM contacts &#xA;        WHERE email = p_email OR phone_number = p_phone_number &#xA;        LIMIT 1;&#xA;        RAISE NOTICE &#x27;Contact with email % or phone % already exists. Using existing contact.&#x27;, p_email, p_phone_number;&#xA;    END IF;&#xA;&#xA;    -- Check if company-contact relationship exists&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM company_contacts &#xA;        WHERE company_id = p_id AND contact_id = v_contact_id&#xA;    ) INTO v_company_contact_exists;&#xA;    &#xA;    IF NOT v_company_contact_exists THEN&#xA;        -- Link company and contact&#xA;        INSERT INTO company_contacts (&#xA;            id, company_id, contact_id, created_on_utc, created_by&#xA;        ) VALUES (&#xA;            v_company_contact_id, p_id, v_contact_id, NOW(), p_created_by&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Check if user-company relationship exists for main user&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM company_users &#xA;        WHERE company_id = p_id AND user_id = p_user_id&#xA;    ) INTO v_user_company_exists;&#xA;    &#xA;    IF NOT v_user_company_exists THEN&#xA;        -- Link main user to company&#xA;        INSERT INTO company_users (&#xA;            id, company_id, user_id, effective_start_date, &#xA;            effective_end_date, created_on_utc, created_by&#xA;        ) VALUES (&#xA;            gen_random_uuid(), p_id, p_user_id, NOW(), &#xA;            DATE &#x27;9999-12-31&#x27;, NOW(), p_created_by&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Check if user-company relationship exists for default user&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM company_users &#xA;        WHERE company_id = p_id AND user_id = DEFAULT_USER_ID&#xA;    ) INTO v_default_user_company_exists;&#xA;    &#xA;    IF NOT v_default_user_company_exists THEN&#xA;        -- Link default user to company&#xA;        INSERT INTO company_users (&#xA;            id, company_id, user_id, effective_start_date, &#xA;            effective_end_date, created_on_utc, created_by&#xA;        ) VALUES (&#xA;            gen_random_uuid(), p_id, DEFAULT_USER_ID, NOW(), &#xA;            DATE &#x27;9999-12-31&#x27;, NOW(), p_created_by&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Initialize finance years if company was newly created&#xA;    IF NOT v_company_exists THEN&#xA;        CALL public.insert_company_finance_years(p_id);&#xA;        CALL public.initialize_journal_voucher_header_ids(p_default_company_id, p_id);&#xA;    END IF;&#xA;&#xA;    RAISE NOTICE &#x27;Company initialization completed for % (ID: %)&#x27;, p_name, p_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.initialize_company(IN p_id uuid, IN p_organization_id uuid, IN p_name text, IN p_description text, IN p_gstin text, IN p_pan text, IN p_tan text, IN p_currency text, IN p_short_name text, IN p_tag_line text, IN p_proprietor_name text, IN p_phone_number character varying, IN p_email character varying, IN p_created_by uuid, IN p_user_id uuid, IN p_default_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_contact_id uuid := gen_random_uuid();&#xA;    v_company_contact_id uuid := gen_random_uuid();&#xA;    v_finance_year_id int;&#xA;    v_prev_finance_year_id INTEGER;&#xA;    v_next_finance_year_id INTEGER;&#xA;    DEFAULT_USER_ID CONSTANT uuid := &#x27;50fd5012-940b-4fec-ad0a-2ac900239c8b&#x27;;&#xA;    v_company_exists boolean;&#xA;    v_contact_exists boolean;&#xA;    v_company_contact_exists boolean;&#xA;    v_user_company_exists boolean;&#xA;    v_default_user_company_exists boolean;&#xA;BEGIN&#xA;    -- Check if company already exists&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM public.companies &#xA;        WHERE id = p_id &#xA;           OR (organization_id = p_organization_id AND name = p_name)&#xA;    ) INTO v_company_exists;&#xA;    &#xA;    IF NOT v_company_exists THEN&#xA;        -- Insert into companies table&#xA;        INSERT INTO public.companies (&#xA;            id, organization_id, name, description, gstin, pan, tan, &#xA;            currency, short_name, tag_line, proprietor_name, &#xA;            outstanding_limit, is_non_work, is_apartment, interest_percentage, &#xA;            created_on_utc, created_by&#xA;        ) VALUES (&#xA;            p_id, p_organization_id, p_name, p_description, p_gstin, p_pan, p_tan, &#xA;            p_currency, p_short_name, p_tag_line, p_proprietor_name, &#xA;            0, false, true, 0, NOW(), p_created_by&#xA;        );&#xA;        RAISE NOTICE &#x27;Company % created successfully.&#x27;, p_name;&#xA;    ELSE&#xA;        RAISE NOTICE &#x27;Company with ID %, name %, or GSTIN/PAN % already exists. Skipping company creation.&#x27;, &#xA;            p_id, p_name, p_gstin;&#xA;    END IF;&#xA;&#xA;    -- Check if contact already exists for this email/phone&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM contacts &#xA;        WHERE email = p_email OR phone_number = p_phone_number&#xA;    ) INTO v_contact_exists;&#xA;    &#xA;    IF NOT v_contact_exists THEN&#xA;        -- Insert contact&#xA;        INSERT INTO contacts (&#xA;            id, salutation, first_name, last_name, email, &#xA;            phone_number, mobile_number, is_primary, &#xA;            created_on_utc, created_by&#xA;        ) VALUES (&#xA;            v_contact_id, &#x27;Mr.&#x27;, p_proprietor_name, NULL, p_email, &#xA;            p_phone_number, p_phone_number, TRUE, &#xA;            NOW(), p_created_by&#xA;        );&#xA;        RAISE NOTICE &#x27;Contact created for company % with email %.&#x27;, p_name, p_email;&#xA;    ELSE&#xA;        -- Get existing contact ID&#xA;        SELECT id INTO v_contact_id &#xA;        FROM contacts &#xA;        WHERE email = p_email OR phone_number = p_phone_number &#xA;        LIMIT 1;&#xA;        RAISE NOTICE &#x27;Contact with email % or phone % already exists. Using existing contact.&#x27;, p_email, p_phone_number;&#xA;    END IF;&#xA;&#xA;    -- Check if company-contact relationship exists&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM company_contacts &#xA;        WHERE company_id = p_id AND contact_id = v_contact_id&#xA;    ) INTO v_company_contact_exists;&#xA;    &#xA;    IF NOT v_company_contact_exists THEN&#xA;        -- Link company and contact&#xA;        INSERT INTO company_contacts (&#xA;            id, company_id, contact_id, created_on_utc, created_by&#xA;        ) VALUES (&#xA;            v_company_contact_id, p_id, v_contact_id, NOW(), p_created_by&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Check if user-company relationship exists for main user&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM company_users &#xA;        WHERE company_id = p_id AND user_id = p_user_id&#xA;    ) INTO v_user_company_exists;&#xA;    &#xA;    IF NOT v_user_company_exists THEN&#xA;        -- Link main user to company&#xA;        INSERT INTO company_users (&#xA;            id, company_id, user_id, effective_start_date, &#xA;            effective_end_date, created_on_utc, created_by&#xA;        ) VALUES (&#xA;            gen_random_uuid(), p_id, p_user_id, NOW(), &#xA;            DATE &#x27;9999-12-31&#x27;, NOW(), p_created_by&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Check if user-company relationship exists for default user&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM company_users &#xA;        WHERE company_id = p_id AND user_id = DEFAULT_USER_ID&#xA;    ) INTO v_default_user_company_exists;&#xA;    &#xA;    IF NOT v_default_user_company_exists THEN&#xA;        -- Link default user to company&#xA;        INSERT INTO company_users (&#xA;            id, company_id, user_id, effective_start_date, &#xA;            effective_end_date, created_on_utc, created_by&#xA;        ) VALUES (&#xA;            gen_random_uuid(), p_id, DEFAULT_USER_ID, NOW(), &#xA;            DATE &#x27;9999-12-31&#x27;, NOW(), p_created_by&#xA;        );&#xA;    END IF;&#xA;&#xA;    -- Initialize finance years if company was newly created&#xA;    IF NOT v_company_exists THEN&#xA;        CALL public.insert_company_finance_years(p_id);&#xA;        CALL public.initialize_journal_voucher_header_ids(p_default_company_id, p_id);&#xA;    END IF;&#xA;&#xA;    RAISE NOTICE &#x27;Company initialization completed for % (ID: %)&#x27;, p_name, p_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>initialize_journal_voucher_header_ids</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-81')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-81">
                                            CREATE OR REPLACE PROCEDURE public.initialize_journal_voucher_header_ids(IN old_company_id uuid, IN new_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_max_id bigint;&#xA;BEGIN&#xA;&#x9;-- Ensure the sequence is correctly set&#xA;&#x9;SELECT COALESCE(MAX(id), 0) INTO v_max_id FROM journal_voucher_header_id;&#xA;&#x9;PERFORM setval(&#x27;journal_voucher_header_id_id_seq&#x27;, v_max_id, true);&#xA;&#xA;&#x9;-- Insert new records for the new company, skipping duplicates&#xA;&#x9;INSERT INTO journal_voucher_header_id (&#xA;&#x9;&#x9;id,&#xA;&#x9;&#x9;company_id,&#xA;&#x9;&#x9;fin_year,&#xA;&#x9;&#x9;voucher_prefix,&#xA;&#x9;&#x9;voucher_length,&#xA;&#x9;&#x9;last_voucher_id&#xA;&#x9;)&#xA;&#x9;SELECT&#xA;&#x9;&#x9;nextval(&#x27;journal_voucher_header_id_id_seq&#x27;),&#xA;&#x9;&#x9;new_company_id,&#xA;&#x9;&#x9;fin_year,&#xA;&#x9;&#x9;voucher_prefix,&#xA;&#x9;&#x9;voucher_length,&#xA;&#x9;&#x9;last_voucher_id&#xA;&#x9;FROM journal_voucher_header_id AS j&#xA;&#x9;WHERE company_id = old_company_id&#xA;&#x9;AND NOT EXISTS (&#xA;&#x9;&#x9;SELECT 1&#xA;&#x9;&#x9;FROM journal_voucher_header_id&#xA;&#x9;&#x9;WHERE company_id = new_company_id&#xA;&#x9;&#x9;AND fin_year = j.fin_year &#xA;&#x9;);&#xA;&#xA;&#x9;RAISE NOTICE &#x27;Journal voucher header IDs initialized successfully for new company ID: %&#x27;, new_company_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.initialize_journal_voucher_header_ids(IN old_company_id uuid, IN new_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_max_id bigint;&#xA;BEGIN&#xA;&#x9;-- Ensure the sequence is correctly set&#xA;&#x9;SELECT COALESCE(MAX(id), 0) INTO v_max_id FROM journal_voucher_header_id;&#xA;&#x9;PERFORM setval(&#x27;journal_voucher_header_id_id_seq&#x27;, v_max_id, true);&#xA;&#xA;&#x9;-- Insert new records for the new company, skipping duplicates&#xA;&#x9;INSERT INTO journal_voucher_header_id (&#xA;&#x9;&#x9;id,&#xA;&#x9;&#x9;company_id,&#xA;&#x9;&#x9;fin_year,&#xA;&#x9;&#x9;voucher_prefix,&#xA;&#x9;&#x9;voucher_length,&#xA;&#x9;&#x9;last_voucher_id&#xA;&#x9;)&#xA;&#x9;SELECT&#xA;&#x9;&#x9;nextval(&#x27;journal_voucher_header_id_id_seq&#x27;),&#xA;&#x9;&#x9;new_company_id,&#xA;&#x9;&#x9;fin_year,&#xA;&#x9;&#x9;voucher_prefix,&#xA;&#x9;&#x9;voucher_length,&#xA;&#x9;&#x9;last_voucher_id&#xA;&#x9;FROM journal_voucher_header_id AS j&#xA;&#x9;WHERE company_id = old_company_id&#xA;&#x9;AND NOT EXISTS (&#xA;&#x9;&#x9;SELECT 1&#xA;&#x9;&#x9;FROM journal_voucher_header_id&#xA;&#x9;&#x9;WHERE company_id = new_company_id&#xA;&#x9;&#x9;AND fin_year = j.fin_year &#xA;&#x9;);&#xA;&#xA;&#x9;RAISE NOTICE &#x27;Journal voucher header IDs initialized successfully for new company ID: %&#x27;, new_company_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>initialize_org_coa</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-82')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-82">
                                            CREATE OR REPLACE PROCEDURE public.initialize_org_coa(IN old_org_id uuid, IN new_org_id uuid, IN new_company_ids text, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    account_mapping RECORD;&#xA;    old_organization_account RECORD; -- To store the old organization_accounts record&#xA;    defualt_company_preference RECORD; -- to store default company preference record&#xA;&#x9;v_company_id_array uuid[];&#xA;&#x9;v_company_id uuid;&#xA;    v_coa_exists boolean;&#xA;&#x9;DEFAULT_COMPANY_ID CONSTANT uuid := &#x27;048000ba-e62c-474b-b5eb-fe629a4dc863&#x27;;&#xA;BEGIN&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM chart_of_accounts WHERE organization_id = new_org_id&#xA;    ) INTO v_coa_exists;&#xA;    &#xA;    IF v_coa_exists THEN&#xA;        RAISE NOTICE &#x27;Chart of accounts already exists for organization %. Skipping initialization.&#x27;, new_org_id;&#xA;        RETURN;&#xA;    END IF;&#xA;&#x9;-- Parse the comma-separated company IDs into an array&#xA;    v_company_id_array := string_to_array(new_company_ids, &#x27;,&#x27;);&#xA;&#xA;    -- Create a temporary table for mapping old account IDs to new account IDs&#xA;    CREATE TEMP TABLE temp_account_mapping (&#xA;        old_id UUID,&#xA;        new_id UUID&#xA;    );&#xA;&#xA;    -- Populate the temporary mapping table with old IDs and their new UUIDs&#xA;    INSERT INTO temp_account_mapping (old_id, new_id)&#xA;    SELECT id, gen_random_uuid()&#xA;    FROM chart_of_accounts&#xA;    WHERE organization_id = old_org_id;&#xA;&#xA;    -- Insert new records into chart_of_accounts for the new organization&#xA;    INSERT INTO chart_of_accounts (&#xA;        id,&#xA;        account_number,&#xA;        name,&#xA;        organization_id,&#xA;        parent_account_id,&#xA;        description,&#xA;        account_type_id,&#xA;        account_group_code,&#xA;        second_group_code,&#xA;        alternative_name,&#xA;        is_ledger_total,&#xA;        is_show_outs,&#xA;        is_tds_tcs,&#xA;        opening_balance,&#xA;        current_balance,&#xA;        created_by,&#xA;        created_on_utc,&#xA;        is_default_account&#xA;    )&#xA;    SELECT&#xA;        tm.new_id, -- Use the new ID from the mapping table&#xA;        coa.account_number,&#xA;        coa.name,&#xA;        new_org_id, -- Assign to the new organization&#xA;        (SELECT tm2.new_id FROM temp_account_mapping tm2 WHERE tm2.old_id = coa.parent_account_id), -- Map the parent ID&#xA;        coa.description,&#xA;        coa.account_type_id,&#xA;        coa.account_group_code,&#xA;        coa.second_group_code,&#xA;        coa.alternative_name,&#xA;        coa.is_ledger_total,&#xA;        coa.is_show_outs,&#xA;        coa.is_tds_tcs,&#xA;        0,&#xA;        0,&#xA;        p_created_by,&#xA;        NOW(),&#xA;        coa.is_default_account&#xA;    FROM chart_of_accounts coa&#xA;    INNER JOIN temp_account_mapping tm ON coa.id = tm.old_id;&#xA;&#xA;    -- Fetch the old organization_accounts record&#xA;    SELECT * INTO old_organization_account&#xA;    FROM organization_accounts&#xA;    WHERE organization_id = old_org_id;&#xA;&#xA;    -- Insert a single entry into organization_accounts for the new organization&#xA;    INSERT INTO organization_accounts (&#xA;        id, &#xA;        organization_id, &#xA;        accounts_receivable_account_id, &#xA;        accounts_payable_account_id, &#xA;        sales_revenue_account_id, &#xA;        cgst_receivable_account_id, &#xA;        sgst_receivable_account_id, &#xA;        igst_receivable_account_id, &#xA;        cgst_payable_account_id, &#xA;        sgst_payable_account_id, &#xA;        igst_payable_account_id, &#xA;        round_off_gain_account_id, &#xA;        round_off_loss_account_id, &#xA;        sales_tax_payable_account_id, &#xA;        purchase_tax_receivable_account_id, &#xA;        discounts_given_account_id, &#xA;        discounts_received_account_id, &#xA;        interest_income_account_id, &#xA;        interest_expense_account_id, &#xA;        depreciation_expense_account_id, &#xA;        bad_debt_expense_account_id, &#xA;        bank_charges_account_id, &#xA;        foreign_exchange_gain_loss_account_id, &#xA;        created_on_utc, &#xA;        created_by, &#xA;        cost_of_goods_sold_account_id, &#xA;        inventory_account_id, &#xA;        salary_expense_account_id, &#xA;        salary_payable_account_id, &#xA;        tds_receivable_account_id, &#xA;        penalty_receivable_account_id, &#xA;        tds_payable_account_id&#xA;    )&#xA;    VALUES (&#xA;         nextval(&#x27;organization_accounts_id_seq&#x27;),                           -- Generate a new ID for organization_accounts&#xA;        new_org_id,                                  -- Assign to the new organization&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.accounts_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.accounts_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sales_revenue_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.cgst_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sgst_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.igst_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.cgst_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sgst_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.igst_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.round_off_gain_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.round_off_loss_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sales_tax_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.purchase_tax_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.discounts_given_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.discounts_received_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.interest_income_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.interest_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.depreciation_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.bad_debt_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.bank_charges_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.foreign_exchange_gain_loss_account_id),&#xA;        NOW(),&#xA;        p_created_by,&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.cost_of_goods_sold_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.inventory_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.salary_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.salary_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.tds_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.penalty_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.tds_payable_account_id)&#xA;    );&#xA;&#xA;&#x9;--fetch old company_preference data&#xA;&#x9;SELECT * INTO defualt_company_preference&#xA;    FROM public.company_preferences&#xA;    WHERE company_id = DEFAULT_COMPANY_ID;&#xA;&#xA;&#x9;-- Loop over the company IDs to insert records into company_preferences&#xA;    FOREACH v_company_id IN ARRAY v_company_id_array LOOP&#xA;        INSERT INTO public.company_preferences (&#xA;            id,&#xA;            company_id,&#xA;            default_sales_account_id,&#xA;            default_purchase_account_id,&#xA;            default_cash_account_id,&#xA;            default_bank_account_id,&#xA;            created_on_utc,&#xA;            created_by&#xA;        )&#xA;        VALUES (&#xA;            gen_random_uuid(),&#xA;            v_company_id,&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_sales_account_id),&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_purchase_account_id),&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_cash_account_id),&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_bank_account_id),&#xA;            NOW(),&#xA;            p_created_by&#xA;        );&#xA;    END LOOP;&#xA;&#xA;    -- Drop the temporary mapping table&#xA;    DROP TABLE temp_account_mapping;&#xA;&#xA;&#x9;UPDATE public.chart_of_accounts &#xA;&#x9;set parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;&#xA;&#x9;where organization_id = new_org_id&#xA;&#x9;And account_number in (&#x27;1000000&#x27;,&#x27;2000000&#x27;,&#x27;3000000&#x27;,&#x27;4000000&#x27;,&#x27;5000000&#x27;);&#xA;&#x9;&#x9;&#xA;    -- Log theparent_account_id completion of the procedure&#xA;    RAISE NOTICE &#x27;Chart of accounts and organization accounts successfully copied from organization % to %.&#x27;, old_org_id, new_org_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.initialize_org_coa(IN old_org_id uuid, IN new_org_id uuid, IN new_company_ids text, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    account_mapping RECORD;&#xA;    old_organization_account RECORD; -- To store the old organization_accounts record&#xA;    defualt_company_preference RECORD; -- to store default company preference record&#xA;&#x9;v_company_id_array uuid[];&#xA;&#x9;v_company_id uuid;&#xA;    v_coa_exists boolean;&#xA;&#x9;DEFAULT_COMPANY_ID CONSTANT uuid := &#x27;048000ba-e62c-474b-b5eb-fe629a4dc863&#x27;;&#xA;BEGIN&#xA;    SELECT EXISTS (&#xA;        SELECT 1 FROM chart_of_accounts WHERE organization_id = new_org_id&#xA;    ) INTO v_coa_exists;&#xA;    &#xA;    IF v_coa_exists THEN&#xA;        RAISE NOTICE &#x27;Chart of accounts already exists for organization %. Skipping initialization.&#x27;, new_org_id;&#xA;        RETURN;&#xA;    END IF;&#xA;&#x9;-- Parse the comma-separated company IDs into an array&#xA;    v_company_id_array := string_to_array(new_company_ids, &#x27;,&#x27;);&#xA;&#xA;    -- Create a temporary table for mapping old account IDs to new account IDs&#xA;    CREATE TEMP TABLE temp_account_mapping (&#xA;        old_id UUID,&#xA;        new_id UUID&#xA;    );&#xA;&#xA;    -- Populate the temporary mapping table with old IDs and their new UUIDs&#xA;    INSERT INTO temp_account_mapping (old_id, new_id)&#xA;    SELECT id, gen_random_uuid()&#xA;    FROM chart_of_accounts&#xA;    WHERE organization_id = old_org_id;&#xA;&#xA;    -- Insert new records into chart_of_accounts for the new organization&#xA;    INSERT INTO chart_of_accounts (&#xA;        id,&#xA;        account_number,&#xA;        name,&#xA;        organization_id,&#xA;        parent_account_id,&#xA;        description,&#xA;        account_type_id,&#xA;        account_group_code,&#xA;        second_group_code,&#xA;        alternative_name,&#xA;        is_ledger_total,&#xA;        is_show_outs,&#xA;        is_tds_tcs,&#xA;        opening_balance,&#xA;        current_balance,&#xA;        created_by,&#xA;        created_on_utc,&#xA;        is_default_account&#xA;    )&#xA;    SELECT&#xA;        tm.new_id, -- Use the new ID from the mapping table&#xA;        coa.account_number,&#xA;        coa.name,&#xA;        new_org_id, -- Assign to the new organization&#xA;        (SELECT tm2.new_id FROM temp_account_mapping tm2 WHERE tm2.old_id = coa.parent_account_id), -- Map the parent ID&#xA;        coa.description,&#xA;        coa.account_type_id,&#xA;        coa.account_group_code,&#xA;        coa.second_group_code,&#xA;        coa.alternative_name,&#xA;        coa.is_ledger_total,&#xA;        coa.is_show_outs,&#xA;        coa.is_tds_tcs,&#xA;        0,&#xA;        0,&#xA;        p_created_by,&#xA;        NOW(),&#xA;        coa.is_default_account&#xA;    FROM chart_of_accounts coa&#xA;    INNER JOIN temp_account_mapping tm ON coa.id = tm.old_id;&#xA;&#xA;    -- Fetch the old organization_accounts record&#xA;    SELECT * INTO old_organization_account&#xA;    FROM organization_accounts&#xA;    WHERE organization_id = old_org_id;&#xA;&#xA;    -- Insert a single entry into organization_accounts for the new organization&#xA;    INSERT INTO organization_accounts (&#xA;        id, &#xA;        organization_id, &#xA;        accounts_receivable_account_id, &#xA;        accounts_payable_account_id, &#xA;        sales_revenue_account_id, &#xA;        cgst_receivable_account_id, &#xA;        sgst_receivable_account_id, &#xA;        igst_receivable_account_id, &#xA;        cgst_payable_account_id, &#xA;        sgst_payable_account_id, &#xA;        igst_payable_account_id, &#xA;        round_off_gain_account_id, &#xA;        round_off_loss_account_id, &#xA;        sales_tax_payable_account_id, &#xA;        purchase_tax_receivable_account_id, &#xA;        discounts_given_account_id, &#xA;        discounts_received_account_id, &#xA;        interest_income_account_id, &#xA;        interest_expense_account_id, &#xA;        depreciation_expense_account_id, &#xA;        bad_debt_expense_account_id, &#xA;        bank_charges_account_id, &#xA;        foreign_exchange_gain_loss_account_id, &#xA;        created_on_utc, &#xA;        created_by, &#xA;        cost_of_goods_sold_account_id, &#xA;        inventory_account_id, &#xA;        salary_expense_account_id, &#xA;        salary_payable_account_id, &#xA;        tds_receivable_account_id, &#xA;        penalty_receivable_account_id, &#xA;        tds_payable_account_id&#xA;    )&#xA;    VALUES (&#xA;         nextval(&#x27;organization_accounts_id_seq&#x27;),                           -- Generate a new ID for organization_accounts&#xA;        new_org_id,                                  -- Assign to the new organization&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.accounts_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.accounts_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sales_revenue_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.cgst_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sgst_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.igst_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.cgst_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sgst_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.igst_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.round_off_gain_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.round_off_loss_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.sales_tax_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.purchase_tax_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.discounts_given_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.discounts_received_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.interest_income_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.interest_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.depreciation_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.bad_debt_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.bank_charges_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.foreign_exchange_gain_loss_account_id),&#xA;        NOW(),&#xA;        p_created_by,&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.cost_of_goods_sold_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.inventory_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.salary_expense_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.salary_payable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.tds_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.penalty_receivable_account_id),&#xA;        (SELECT new_id FROM temp_account_mapping WHERE old_id = old_organization_account.tds_payable_account_id)&#xA;    );&#xA;&#xA;&#x9;--fetch old company_preference data&#xA;&#x9;SELECT * INTO defualt_company_preference&#xA;    FROM public.company_preferences&#xA;    WHERE company_id = DEFAULT_COMPANY_ID;&#xA;&#xA;&#x9;-- Loop over the company IDs to insert records into company_preferences&#xA;    FOREACH v_company_id IN ARRAY v_company_id_array LOOP&#xA;        INSERT INTO public.company_preferences (&#xA;            id,&#xA;            company_id,&#xA;            default_sales_account_id,&#xA;            default_purchase_account_id,&#xA;            default_cash_account_id,&#xA;            default_bank_account_id,&#xA;            created_on_utc,&#xA;            created_by&#xA;        )&#xA;        VALUES (&#xA;            gen_random_uuid(),&#xA;            v_company_id,&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_sales_account_id),&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_purchase_account_id),&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_cash_account_id),&#xA;            (SELECT new_id FROM temp_account_mapping WHERE old_id = defualt_company_preference.default_bank_account_id),&#xA;            NOW(),&#xA;            p_created_by&#xA;        );&#xA;    END LOOP;&#xA;&#xA;    -- Drop the temporary mapping table&#xA;    DROP TABLE temp_account_mapping;&#xA;&#xA;&#x9;UPDATE public.chart_of_accounts &#xA;&#x9;set parent_account_id = &#x27;00000000-0000-0000-0000-000000000000&#x27;&#xA;&#x9;where organization_id = new_org_id&#xA;&#x9;And account_number in (&#x27;1000000&#x27;,&#x27;2000000&#x27;,&#x27;3000000&#x27;,&#x27;4000000&#x27;,&#x27;5000000&#x27;);&#xA;&#x9;&#x9;&#xA;    -- Log theparent_account_id completion of the procedure&#xA;    RAISE NOTICE &#x27;Chart of accounts and organization accounts successfully copied from organization % to %.&#x27;, old_org_id, new_org_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>initilize_organization</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-83')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-83">
                                            CREATE OR REPLACE PROCEDURE public.initilize_organization(IN p_id uuid, IN p_name text, IN p_company_guids text, IN p_company_names text, IN p_user_id uuid, IN p_user_first_name text, IN p_user_last_name text, IN p_phone_number character varying, IN p_email character varying, IN p_gstin text, IN p_description text, IN p_tag_line text, IN p_short_name text, IN p_pan text, IN p_tan text, IN p_address_line1 text, IN p_address_line2 text, IN p_country_id uuid, IN p_state_id uuid, IN p_city_name text, IN p_zip_code text, IN p_created_by uuid, IN p_default_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_city_id uuid;&#xA;    v_address_id uuid;     -- Generate a unique address ID&#xA;    v_user_id uuid;        -- Generate a unique user ID&#xA;    v_permission_id uuid; &#xA;    v_company_names text[];  -- Array to hold parsed company names&#xA;    v_company_guids uuid[];  -- Array to hold parsed company GUIDs&#xA;    v_company_name text;     -- Variable for iterating through company names&#xA;    v_company_guid uuid;     -- Variable for iterating through company GUIDs&#xA;&#x9;v_user_company_id uuid;&#xA;&#xA;    -- Constants for default organization and company IDs&#xA;    DEFAULT_ORGANIZATION_ID CONSTANT uuid := &#x27;68929d37-b647-4d7b-8c91-7dfe2396c93b&#x27;; &#xA;    --DEFAULT_COMPANY_ID CONSTANT uuid := &#x27;048000ba-e62c-474b-b5eb-fe629a4dc863&#x27;;&#xA;    ADMIN_PERMISSION CONSTANT text := &#x27;Dhanman.Admin&#x27;;&#xA;BEGIN&#xA;&#x9;&#xA;&#xA;&#x9; -- Parse company names and GUIDs into arrays&#xA;    v_company_names := string_to_array(p_company_names, &#x27;,&#x27;);&#xA;    v_company_guids := string_to_array(p_company_guids, &#x27;,&#x27;);&#xA;&#xA;    -- Get city_id&#xA;    v_city_id := get_city_id(p_city_name, p_zip_code, p_state_id, p_created_by);&#xA;    &#xA;    -- Get address_id&#xA;    v_address_id := get_address_id(p_country_id, p_state_id , v_city_id , p_address_line1, p_zip_code, p_created_by, p_address_line2);&#xA;&#xA;&#x9; v_user_company_id := v_company_guids[1]; -- Pick the first company ID&#xA;   &#xA;    -- Create and get user_id&#xA;    v_user_id := create_user(p_user_id, v_user_company_id, p_email, p_phone_number, p_user_first_name, p_user_last_name, v_address_id,  p_created_by);&#xA;    RAISE NOTICE &#x27;Generated User ID: %&#x27;,v_user_company_id;&#xA;&#xA;    -- Print the generated address_id and fetched state_id and country_id&#xA;    RAISE NOTICE &#x27;Generated address_id: %, City ID: %, Country ID: %, User ID: %&#x27;, v_address_id, v_city_id, p_country_id, v_user_id;&#xA;    &#xA;&#x9;-- Check if organization exists by any unique identifier&#xA;   IF NOT EXISTS (SELECT 1 FROM organizations WHERE id = p_id) THEN&#xA;    -- Only create organization if no matching record exists&#xA;      CALL public.create_organization(&#xA;        p_id,&#xA;        p_name,&#xA;        p_description,&#xA;        p_phone_number,&#xA;        p_email,&#xA;        p_address_line1,&#xA;        p_gstin,&#xA;        p_tag_line,&#xA;        v_city_id,&#xA;        p_short_name,&#xA;        p_pan,&#xA;        p_tan,&#xA;        p_created_by&#xA;      );&#xA;    &#xA;        RAISE NOTICE &#x27;Organization ID % successfully inserted.&#x27;, p_id;&#xA;   ELSE&#xA;        RAISE NOTICE &#x27;Organization with ID % already exists. Skipping organization creation.&#x27;, p_id;&#xA;   END IF;&#xA;&#xA;    -- Insert into organization_users table to link the generated user to the organization&#xA;    CALL public.insert_organization_user(v_user_id, p_created_by, p_id);   &#xA;&#xA;    -- Fetch the permission_id for &#x27;Dhanman.Admin&#x27;&#xA;    SELECT id INTO v_permission_id&#xA;    FROM permissions&#xA;    WHERE name = ADMIN_PERMISSION;&#xA;&#xA;    CALL public.insert_user_permission(&#xA;        v_user_id ,&#xA;        p_id ,&#xA;        v_permission_id,&#xA;        p_created_by&#xA;    );&#xA;&#xA;    -- Assign all default users and default permissions as admin&#xA;    CALL public.assign_default_users_to_organization(p_id, v_permission_id, p_created_by);&#xA;&#xA;    -- Iterate through the company names and GUIDs&#xA;    FOR i IN 1..array_length(v_company_names, 1) LOOP&#xA;        v_company_name := v_company_names[i];&#xA;        v_company_guid := v_company_guids[i];&#xA;        &#xA;        -- Call initialize_company for each company&#xA;        CALL public.initialize_company(&#xA;            v_company_guid, &#xA;            p_id,  &#xA;            v_company_name, &#xA;            p_description, &#xA;            p_gstin, &#xA;            p_pan, &#xA;            p_tan, &#xA;            &#x27;INR&#x27;, &#xA;            p_short_name, &#xA;            p_tag_line, &#xA;            p_name, &#xA;            p_phone_number, &#xA;            p_email, &#xA;            p_created_by, &#xA;            v_user_id,&#xA;&#x9;&#x9;&#x9;p_default_company_id&#xA;        );&#xA;        &#xA;        RAISE NOTICE &#x27;Company % initialized with GUID %.&#x27;, v_company_name, v_company_guid;&#xA;    END LOOP;&#xA;&#xA;    -- Call initialize_org_coa to copy chart_of_accounts from the old organization to the new organization&#xA;    CALL public.initialize_org_coa(&#xA;        DEFAULT_ORGANIZATION_ID, -- Old organization ID&#xA;        p_id,       -- New organization ID&#xA;        p_company_guids, -- New Company Id&#xA;        p_created_by&#xA;    ); &#xA;&#xA;    -- Print a confirmation after the chart_of_accounts is copied&#xA;    RAISE NOTICE &#x27;Chart of accounts successfully copied from organization % to %.&#x27;, DEFAULT_ORGANIZATION_ID, p_id;&#xA;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.initilize_organization(IN p_id uuid, IN p_name text, IN p_company_guids text, IN p_company_names text, IN p_user_id uuid, IN p_user_first_name text, IN p_user_last_name text, IN p_phone_number character varying, IN p_email character varying, IN p_gstin text, IN p_description text, IN p_tag_line text, IN p_short_name text, IN p_pan text, IN p_tan text, IN p_address_line1 text, IN p_address_line2 text, IN p_country_id uuid, IN p_state_id uuid, IN p_city_name text, IN p_zip_code text, IN p_created_by uuid, IN p_default_company_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_city_id uuid;&#xA;    v_address_id uuid;     -- Generate a unique address ID&#xA;    v_user_id uuid;        -- Generate a unique user ID&#xA;    v_permission_id uuid; &#xA;    v_company_names text[];  -- Array to hold parsed company names&#xA;    v_company_guids uuid[];  -- Array to hold parsed company GUIDs&#xA;    v_company_name text;     -- Variable for iterating through company names&#xA;    v_company_guid uuid;     -- Variable for iterating through company GUIDs&#xA;&#x9;v_user_company_id uuid;&#xA;&#xA;    -- Constants for default organization and company IDs&#xA;    DEFAULT_ORGANIZATION_ID CONSTANT uuid := &#x27;68929d37-b647-4d7b-8c91-7dfe2396c93b&#x27;; &#xA;    --DEFAULT_COMPANY_ID CONSTANT uuid := &#x27;048000ba-e62c-474b-b5eb-fe629a4dc863&#x27;;&#xA;    ADMIN_PERMISSION CONSTANT text := &#x27;Dhanman.Admin&#x27;;&#xA;BEGIN&#xA;&#x9;&#xA;&#xA;&#x9; -- Parse company names and GUIDs into arrays&#xA;    v_company_names := string_to_array(p_company_names, &#x27;,&#x27;);&#xA;    v_company_guids := string_to_array(p_company_guids, &#x27;,&#x27;);&#xA;&#xA;    -- Get city_id&#xA;    v_city_id := get_city_id(p_city_name, p_zip_code, p_state_id, p_created_by);&#xA;    &#xA;    -- Get address_id&#xA;    v_address_id := get_address_id(p_country_id, p_state_id , v_city_id , p_address_line1, p_zip_code, p_created_by, p_address_line2);&#xA;&#xA;&#x9; v_user_company_id := v_company_guids[1]; -- Pick the first company ID&#xA;   &#xA;    -- Create and get user_id&#xA;    v_user_id := create_user(p_user_id, v_user_company_id, p_email, p_phone_number, p_user_first_name, p_user_last_name, v_address_id,  p_created_by);&#xA;    RAISE NOTICE &#x27;Generated User ID: %&#x27;,v_user_company_id;&#xA;&#xA;    -- Print the generated address_id and fetched state_id and country_id&#xA;    RAISE NOTICE &#x27;Generated address_id: %, City ID: %, Country ID: %, User ID: %&#x27;, v_address_id, v_city_id, p_country_id, v_user_id;&#xA;    &#xA;&#x9;-- Check if organization exists by any unique identifier&#xA;   IF NOT EXISTS (SELECT 1 FROM organizations WHERE id = p_id) THEN&#xA;    -- Only create organization if no matching record exists&#xA;      CALL public.create_organization(&#xA;        p_id,&#xA;        p_name,&#xA;        p_description,&#xA;        p_phone_number,&#xA;        p_email,&#xA;        p_address_line1,&#xA;        p_gstin,&#xA;        p_tag_line,&#xA;        v_city_id,&#xA;        p_short_name,&#xA;        p_pan,&#xA;        p_tan,&#xA;        p_created_by&#xA;      );&#xA;    &#xA;        RAISE NOTICE &#x27;Organization ID % successfully inserted.&#x27;, p_id;&#xA;   ELSE&#xA;        RAISE NOTICE &#x27;Organization with ID % already exists. Skipping organization creation.&#x27;, p_id;&#xA;   END IF;&#xA;&#xA;    -- Insert into organization_users table to link the generated user to the organization&#xA;    CALL public.insert_organization_user(v_user_id, p_created_by, p_id);   &#xA;&#xA;    -- Fetch the permission_id for &#x27;Dhanman.Admin&#x27;&#xA;    SELECT id INTO v_permission_id&#xA;    FROM permissions&#xA;    WHERE name = ADMIN_PERMISSION;&#xA;&#xA;    CALL public.insert_user_permission(&#xA;        v_user_id ,&#xA;        p_id ,&#xA;        v_permission_id,&#xA;        p_created_by&#xA;    );&#xA;&#xA;    -- Assign all default users and default permissions as admin&#xA;    CALL public.assign_default_users_to_organization(p_id, v_permission_id, p_created_by);&#xA;&#xA;    -- Iterate through the company names and GUIDs&#xA;    FOR i IN 1..array_length(v_company_names, 1) LOOP&#xA;        v_company_name := v_company_names[i];&#xA;        v_company_guid := v_company_guids[i];&#xA;        &#xA;        -- Call initialize_company for each company&#xA;        CALL public.initialize_company(&#xA;            v_company_guid, &#xA;            p_id,  &#xA;            v_company_name, &#xA;            p_description, &#xA;            p_gstin, &#xA;            p_pan, &#xA;            p_tan, &#xA;            &#x27;INR&#x27;, &#xA;            p_short_name, &#xA;            p_tag_line, &#xA;            p_name, &#xA;            p_phone_number, &#xA;            p_email, &#xA;            p_created_by, &#xA;            v_user_id,&#xA;&#x9;&#x9;&#x9;p_default_company_id&#xA;        );&#xA;        &#xA;        RAISE NOTICE &#x27;Company % initialized with GUID %.&#x27;, v_company_name, v_company_guid;&#xA;    END LOOP;&#xA;&#xA;    -- Call initialize_org_coa to copy chart_of_accounts from the old organization to the new organization&#xA;    CALL public.initialize_org_coa(&#xA;        DEFAULT_ORGANIZATION_ID, -- Old organization ID&#xA;        p_id,       -- New organization ID&#xA;        p_company_guids, -- New Company Id&#xA;        p_created_by&#xA;    ); &#xA;&#xA;    -- Print a confirmation after the chart_of_accounts is copied&#xA;    RAISE NOTICE &#x27;Chart of accounts successfully copied from organization % to %.&#x27;, DEFAULT_ORGANIZATION_ID, p_id;&#xA;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_into_manual_journal</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-84')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-84">
                                            CREATE OR REPLACE PROCEDURE public.insert_into_manual_journal(IN p_company_id uuid, IN p_journal_header_id uuid, IN p_date date, IN p_amount numeric, IN p_note text, IN p_description text, IN p_is_debit boolean, IN p_account_id uuid, IN p_created_by uuid, IN p_journal_details_data jsonb, IN p_transaction_header_data jsonb, IN journal_entries_data jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;&#x9;v_voucher_number character varying;&#xA;    v_voucher_detail JSONB;&#xA; &#x9;v_transaction_id BIGINT;&#xA;    v_journal_entry JSONB;&#xA;BEGIN&#xA;     v_voucher_number := get_new_voucher_number(p_company_id,p_date);&#xA;     RAISE NOTICE &#x27;new v_voucher_number: %&#x27;, v_voucher_number;&#xA;&#xA;    -- Insert into journal_voucher_headers&#xA;    INSERT INTO public.journal_voucher_headers(&#xA;        id,&#xA;&#x9;&#x9;company_id,&#xA;        date,&#xA;        amount,&#xA;        note,&#xA;&#x9;&#x9;is_debit,&#xA;&#x9;&#x9;account_id,&#xA;&#x9;&#x9;voucher_number,&#xA;        created_by,&#xA;        created_on_utc,&#xA;        is_deleted&#xA;    )&#xA;    VALUES (&#xA;        p_journal_header_id,&#xA;&#x9;&#x9;p_company_id,&#xA;        p_date,&#xA;        p_amount,&#xA;        p_note,&#xA;&#x9;&#x9;p_is_debit,&#xA;&#x9;&#x9;p_account_id,&#xA;&#x9;&#x9;v_voucher_number,&#xA;        p_created_by,&#xA;        CURRENT_TIMESTAMP,&#xA;        FALSE&#xA;    ); &#xA;&#xA;    RAISE NOTICE &#x27;Inserted into journal_voucher_headers: %&#x27;, p_journal_header_id;&#xA;&#xA;    -- Loop through each journal entry and insert into journal_voucher_details&#xA;    FOR v_voucher_detail IN SELECT * FROM jsonb_array_elements(p_journal_details_data)&#xA;    LOOP&#xA;        INSERT INTO public.journal_voucher_details(&#xA;            id,        &#xA;            journal_header_id,&#xA;            credit_account_id,&#xA;            debit_account_id,&#xA;            amount,&#xA;            tds_tcs,&#xA;            narration,&#xA;            created_by,&#xA;            created_on_utc,&#xA;            is_deleted&#xA;        )&#xA;        VALUES (&#xA;            (v_voucher_detail-&gt;&gt;&#x27;detail_id&#x27;)::UUID,&#xA;            p_journal_header_id,&#xA;            (v_voucher_detail-&gt;&gt;&#x27;credit_account_id&#x27;)::UUID,&#xA;            (v_voucher_detail-&gt;&gt;&#x27;debit_account_id&#x27;)::UUID, &#xA;            (v_voucher_detail-&gt;&gt;&#x27;amount&#x27;)::NUMERIC,&#xA;            v_voucher_detail-&gt;&gt;&#x27;tds_tcs&#x27;,&#xA;            v_voucher_detail-&gt;&gt;&#x27;narration&#x27;,&#xA;            p_created_by,&#xA;            CURRENT_TIMESTAMP,&#xA;            FALSE&#xA;        ); &#xA;        RAISE NOTICE &#x27;Inserted into journal_voucher_details&#x27;;&#xA;    END LOOP;&#xA;&#xA;&#x9;INSERT INTO public.transaction_headers (&#xA;            company_id,&#xA;            customer_id,&#xA;            vendor_id,&#xA;            employee_id,&#xA;            transaction_date,&#xA;            transaction_source_type,&#xA;            status_id,&#xA;            document_id,&#xA;            document_number,&#xA;            description,&#xA;            created_by,&#xA;            created_on_utc&#xA;    )&#xA;&#x9;VALUES(&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;company_id&#x27;)::UUID,&#xA;        NULLIF((p_transaction_header_data-&gt;&gt;&#x27;customer_id&#x27;)::UUID, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;        NULLIF((p_transaction_header_data-&gt;&gt;&#x27;vendor_id&#x27;)::UUID, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;        NULLIF((p_transaction_header_data-&gt;&gt;&#x27;employee_id&#x27;)::UUID, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;transaction_date&#x27;)::DATE,&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;transaction_source_type&#x27;)::INT,&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;status_id&#x27;)::INT,&#xA;&#x9;&#x9;(p_transaction_header_data-&gt;&gt;&#x27;document_id&#x27;)::UUID,&#xA;        v_voucher_number,&#xA;&#x9;&#x9;(p_transaction_header_data-&gt;&gt;&#x27;description&#x27;)::TEXT,&#xA;        p_created_by,&#xA;        CURRENT_TIMESTAMP&#xA;    )&#xA;    RETURNING id INTO v_transaction_id;&#xA;    &#xA;&#x9;-- Loop through each journal entry and insert&#xA;    FOR v_journal_entry IN SELECT * FROM jsonb_array_elements(journal_entries_data)&#xA;    LOOP&#xA;&#x9;&#x9;RAISE NOTICE &#x27;transaction_date: %&#x27;, (v_journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::DATE;&#xA;         INSERT INTO public.journal_entries (&#xA;            transaction_id,&#xA;            account_id,&#xA;            transaction_date,&#xA;            amount,&#xA;            entry_type,&#xA;            description_template_id,&#xA;            dynamic_data,&#xA;            entry_source_id&#xA;        )&#xA;        VALUES (&#xA;            v_transaction_id,&#xA;            (v_journal_entry-&gt;&gt;&#x27;account_id&#x27;)::uuid,&#xA;            (v_journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::date,&#xA;            (v_journal_entry-&gt;&gt;&#x27;amount&#x27;)::decimal,&#xA;            (v_journal_entry-&gt;&gt;&#x27;entry_type&#x27;)::char,&#xA;            (v_journal_entry-&gt;&gt;&#x27;description_template_id&#x27;)::int,&#xA;            (v_journal_entry-&gt;&gt;&#x27;dynamic_data&#x27;)::jsonb,&#xA;            (v_journal_entry-&gt;&gt;&#x27;entry_source_id&#x27;)::int&#xA;        );&#xA;    END LOOP;&#xA;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_into_manual_journal(IN p_company_id uuid, IN p_journal_header_id uuid, IN p_date date, IN p_amount numeric, IN p_note text, IN p_description text, IN p_is_debit boolean, IN p_account_id uuid, IN p_created_by uuid, IN p_journal_details_data jsonb, IN p_transaction_header_data jsonb, IN journal_entries_data jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;&#x9;v_voucher_number character varying;&#xA;    v_voucher_detail JSONB;&#xA; &#x9;v_transaction_id BIGINT;&#xA;    v_journal_entry JSONB;&#xA;BEGIN&#xA;     v_voucher_number := get_new_voucher_number(p_company_id,p_date);&#xA;     RAISE NOTICE &#x27;new v_voucher_number: %&#x27;, v_voucher_number;&#xA;&#xA;    -- Insert into journal_voucher_headers&#xA;    INSERT INTO public.journal_voucher_headers(&#xA;        id,&#xA;&#x9;&#x9;company_id,&#xA;        date,&#xA;        amount,&#xA;        note,&#xA;&#x9;&#x9;is_debit,&#xA;&#x9;&#x9;account_id,&#xA;&#x9;&#x9;voucher_number,&#xA;        created_by,&#xA;        created_on_utc,&#xA;        is_deleted&#xA;    )&#xA;    VALUES (&#xA;        p_journal_header_id,&#xA;&#x9;&#x9;p_company_id,&#xA;        p_date,&#xA;        p_amount,&#xA;        p_note,&#xA;&#x9;&#x9;p_is_debit,&#xA;&#x9;&#x9;p_account_id,&#xA;&#x9;&#x9;v_voucher_number,&#xA;        p_created_by,&#xA;        CURRENT_TIMESTAMP,&#xA;        FALSE&#xA;    ); &#xA;&#xA;    RAISE NOTICE &#x27;Inserted into journal_voucher_headers: %&#x27;, p_journal_header_id;&#xA;&#xA;    -- Loop through each journal entry and insert into journal_voucher_details&#xA;    FOR v_voucher_detail IN SELECT * FROM jsonb_array_elements(p_journal_details_data)&#xA;    LOOP&#xA;        INSERT INTO public.journal_voucher_details(&#xA;            id,        &#xA;            journal_header_id,&#xA;            credit_account_id,&#xA;            debit_account_id,&#xA;            amount,&#xA;            tds_tcs,&#xA;            narration,&#xA;            created_by,&#xA;            created_on_utc,&#xA;            is_deleted&#xA;        )&#xA;        VALUES (&#xA;            (v_voucher_detail-&gt;&gt;&#x27;detail_id&#x27;)::UUID,&#xA;            p_journal_header_id,&#xA;            (v_voucher_detail-&gt;&gt;&#x27;credit_account_id&#x27;)::UUID,&#xA;            (v_voucher_detail-&gt;&gt;&#x27;debit_account_id&#x27;)::UUID, &#xA;            (v_voucher_detail-&gt;&gt;&#x27;amount&#x27;)::NUMERIC,&#xA;            v_voucher_detail-&gt;&gt;&#x27;tds_tcs&#x27;,&#xA;            v_voucher_detail-&gt;&gt;&#x27;narration&#x27;,&#xA;            p_created_by,&#xA;            CURRENT_TIMESTAMP,&#xA;            FALSE&#xA;        ); &#xA;        RAISE NOTICE &#x27;Inserted into journal_voucher_details&#x27;;&#xA;    END LOOP;&#xA;&#xA;&#x9;INSERT INTO public.transaction_headers (&#xA;            company_id,&#xA;            customer_id,&#xA;            vendor_id,&#xA;            employee_id,&#xA;            transaction_date,&#xA;            transaction_source_type,&#xA;            status_id,&#xA;            document_id,&#xA;            document_number,&#xA;            description,&#xA;            created_by,&#xA;            created_on_utc&#xA;    )&#xA;&#x9;VALUES(&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;company_id&#x27;)::UUID,&#xA;        NULLIF((p_transaction_header_data-&gt;&gt;&#x27;customer_id&#x27;)::UUID, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;        NULLIF((p_transaction_header_data-&gt;&gt;&#x27;vendor_id&#x27;)::UUID, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;        NULLIF((p_transaction_header_data-&gt;&gt;&#x27;employee_id&#x27;)::UUID, &#x27;00000000-0000-0000-0000-000000000000&#x27;),&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;transaction_date&#x27;)::DATE,&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;transaction_source_type&#x27;)::INT,&#xA;        (p_transaction_header_data-&gt;&gt;&#x27;status_id&#x27;)::INT,&#xA;&#x9;&#x9;(p_transaction_header_data-&gt;&gt;&#x27;document_id&#x27;)::UUID,&#xA;        v_voucher_number,&#xA;&#x9;&#x9;(p_transaction_header_data-&gt;&gt;&#x27;description&#x27;)::TEXT,&#xA;        p_created_by,&#xA;        CURRENT_TIMESTAMP&#xA;    )&#xA;    RETURNING id INTO v_transaction_id;&#xA;    &#xA;&#x9;-- Loop through each journal entry and insert&#xA;    FOR v_journal_entry IN SELECT * FROM jsonb_array_elements(journal_entries_data)&#xA;    LOOP&#xA;&#x9;&#x9;RAISE NOTICE &#x27;transaction_date: %&#x27;, (v_journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::DATE;&#xA;         INSERT INTO public.journal_entries (&#xA;            transaction_id,&#xA;            account_id,&#xA;            transaction_date,&#xA;            amount,&#xA;            entry_type,&#xA;            description_template_id,&#xA;            dynamic_data,&#xA;            entry_source_id&#xA;        )&#xA;        VALUES (&#xA;            v_transaction_id,&#xA;            (v_journal_entry-&gt;&gt;&#x27;account_id&#x27;)::uuid,&#xA;            (v_journal_entry-&gt;&gt;&#x27;transaction_date&#x27;)::date,&#xA;            (v_journal_entry-&gt;&gt;&#x27;amount&#x27;)::decimal,&#xA;            (v_journal_entry-&gt;&gt;&#x27;entry_type&#x27;)::char,&#xA;            (v_journal_entry-&gt;&gt;&#x27;description_template_id&#x27;)::int,&#xA;            (v_journal_entry-&gt;&gt;&#x27;dynamic_data&#x27;)::jsonb,&#xA;            (v_journal_entry-&gt;&gt;&#x27;entry_source_id&#x27;)::int&#xA;        );&#xA;    END LOOP;&#xA;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_organization_company</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-85')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-85">
                                            CREATE OR REPLACE PROCEDURE public.insert_organization_company(IN p_organization_id uuid, IN p_organization_name text, IN p_description text, IN p_phone_number character varying, IN p_email character varying, IN p_address_line text, IN p_gstin text, IN p_tag_line text, IN p_city_id uuid, IN p_pin text, IN p_short_name text, IN p_pan text, IN p_tan text, IN p_outstanding_limit numeric, IN p_is_non_work boolean, IN p_interest_percentage numeric, IN p_created_by uuid, IN p_companies jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    company RECORD;&#xA;    v_created_on_utc timestamp without time zone := CURRENT_TIMESTAMP;&#xA;BEGIN&#xA;    -- Insert into the organizations table&#xA;    CALL public.create_organization(&#xA;        p_organization_id,&#xA;        p_organization_name,&#xA;        p_description,&#xA;        p_phone_number,&#xA;        p_email,&#xA;        p_address_line,&#xA;        p_gstin,&#xA;        p_tag_line,&#xA;        p_city_id,&#xA;        p_pin,&#xA;        p_short_name,&#xA;        p_pan,&#xA;        p_tan,&#xA;        p_outstanding_limit,&#xA;        p_is_non_work,&#xA;        p_interest_percentage,&#xA;        p_created_by,&#xA;        v_created_on_utc&#xA;    );&#xA;&#xA;    RAISE NOTICE &#x27;Organization inserted with ID: %&#x27;, p_organization_id;&#xA;&#xA;    -- Loop through the JSONB array of companies&#xA;    FOR company IN&#xA;        SELECT * FROM jsonb_to_recordset(p_companies) AS (&#xA;            id uuid, &#xA;            name text, &#xA;            description text, &#xA;            gstin text,&#xA;            pan text, &#xA;            tan text, &#xA;            currency text, &#xA;            short_name text, &#xA;            tag_line text,&#xA;            proprietor_name text, &#xA;            outstanding_limit numeric, &#xA;            is_non_work boolean,&#xA;            interest_percentage numeric, &#xA;            created_by uuid&#xA;        )&#xA;    LOOP&#xA;        -- Insert into the companies table&#xA;        CALL public.create_company(&#xA;            company.id,&#xA;            p_organization_id,&#xA;            company.name,&#xA;            company.description,&#xA;            company.gstin,&#xA;            company.pan,&#xA;            company.tan,&#xA;            company.currency,&#xA;            company.short_name,&#xA;            company.tag_line,&#xA;            company.proprietor_name,&#xA;            company.outstanding_limit,&#xA;            company.is_non_work,&#xA;            company.interest_percentage,&#xA;            company.created_by,&#xA;            v_created_on_utc&#xA;        );&#xA;&#xA;        RAISE NOTICE &#x27;Company inserted with ID: %&#x27;, company.id;&#xA;    END LOOP;&#xA;&#xA;    RAISE NOTICE &#x27;Transaction completed successfully&#x27;;&#xA;EXCEPTION&#xA;    WHEN OTHERS THEN&#xA;        RAISE NOTICE &#x27;An error occurred: %, transaction rolled back&#x27;, SQLERRM;&#xA;        ROLLBACK;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_organization_company(IN p_organization_id uuid, IN p_organization_name text, IN p_description text, IN p_phone_number character varying, IN p_email character varying, IN p_address_line text, IN p_gstin text, IN p_tag_line text, IN p_city_id uuid, IN p_pin text, IN p_short_name text, IN p_pan text, IN p_tan text, IN p_outstanding_limit numeric, IN p_is_non_work boolean, IN p_interest_percentage numeric, IN p_created_by uuid, IN p_companies jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    company RECORD;&#xA;    v_created_on_utc timestamp without time zone := CURRENT_TIMESTAMP;&#xA;BEGIN&#xA;    -- Insert into the organizations table&#xA;    CALL public.create_organization(&#xA;        p_organization_id,&#xA;        p_organization_name,&#xA;        p_description,&#xA;        p_phone_number,&#xA;        p_email,&#xA;        p_address_line,&#xA;        p_gstin,&#xA;        p_tag_line,&#xA;        p_city_id,&#xA;        p_pin,&#xA;        p_short_name,&#xA;        p_pan,&#xA;        p_tan,&#xA;        p_outstanding_limit,&#xA;        p_is_non_work,&#xA;        p_interest_percentage,&#xA;        p_created_by,&#xA;        v_created_on_utc&#xA;    );&#xA;&#xA;    RAISE NOTICE &#x27;Organization inserted with ID: %&#x27;, p_organization_id;&#xA;&#xA;    -- Loop through the JSONB array of companies&#xA;    FOR company IN&#xA;        SELECT * FROM jsonb_to_recordset(p_companies) AS (&#xA;            id uuid, &#xA;            name text, &#xA;            description text, &#xA;            gstin text,&#xA;            pan text, &#xA;            tan text, &#xA;            currency text, &#xA;            short_name text, &#xA;            tag_line text,&#xA;            proprietor_name text, &#xA;            outstanding_limit numeric, &#xA;            is_non_work boolean,&#xA;            interest_percentage numeric, &#xA;            created_by uuid&#xA;        )&#xA;    LOOP&#xA;        -- Insert into the companies table&#xA;        CALL public.create_company(&#xA;            company.id,&#xA;            p_organization_id,&#xA;            company.name,&#xA;            company.description,&#xA;            company.gstin,&#xA;            company.pan,&#xA;            company.tan,&#xA;            company.currency,&#xA;            company.short_name,&#xA;            company.tag_line,&#xA;            company.proprietor_name,&#xA;            company.outstanding_limit,&#xA;            company.is_non_work,&#xA;            company.interest_percentage,&#xA;            company.created_by,&#xA;            v_created_on_utc&#xA;        );&#xA;&#xA;        RAISE NOTICE &#x27;Company inserted with ID: %&#x27;, company.id;&#xA;    END LOOP;&#xA;&#xA;    RAISE NOTICE &#x27;Transaction completed successfully&#x27;;&#xA;EXCEPTION&#xA;    WHEN OTHERS THEN&#xA;        RAISE NOTICE &#x27;An error occurred: %, transaction rolled back&#x27;, SQLERRM;&#xA;        ROLLBACK;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_organization_user</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-86')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-86">
                                            CREATE OR REPLACE PROCEDURE public.insert_organization_user(IN p_user_id uuid, IN p_created_by uuid, IN p_organization_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Check if this user-organization relationship already exists&#xA;    IF NOT EXISTS (&#xA;        SELECT 1 &#xA;        FROM public.organization_users &#xA;        WHERE user_id = p_user_id &#xA;          AND organization_id = p_organization_id&#xA;    ) THEN&#xA;        -- Only insert if the relationship doesn&#x27;t exist&#xA;        INSERT INTO public.organization_users (&#xA;            id,&#xA;            user_id,&#xA;            effective_start_date,&#xA;            effective_end_date,&#xA;            created_on_utc,&#xA;            created_by,&#xA;            organization_id&#xA;        ) VALUES (&#xA;            gen_random_uuid(),       &#xA;            p_user_id,             &#xA;            NOW(),                  &#xA;            DATE &#x27;9999-12-31&#x27;,    &#xA;            NOW(),                 &#xA;            p_created_by,         &#xA;            p_organization_id     &#xA;        );&#xA;        &#xA;        RAISE NOTICE &#x27;Organization-user relationship created for user % in organization %&#x27;, p_user_id, p_organization_id;&#xA;    ELSE&#xA;        RAISE NOTICE &#x27;User % already exists in organization %. Skipping insertion.&#x27;, p_user_id, p_organization_id;&#xA;    END IF;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_organization_user(IN p_user_id uuid, IN p_created_by uuid, IN p_organization_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;BEGIN&#xA;    -- Check if this user-organization relationship already exists&#xA;    IF NOT EXISTS (&#xA;        SELECT 1 &#xA;        FROM public.organization_users &#xA;        WHERE user_id = p_user_id &#xA;          AND organization_id = p_organization_id&#xA;    ) THEN&#xA;        -- Only insert if the relationship doesn&#x27;t exist&#xA;        INSERT INTO public.organization_users (&#xA;            id,&#xA;            user_id,&#xA;            effective_start_date,&#xA;            effective_end_date,&#xA;            created_on_utc,&#xA;            created_by,&#xA;            organization_id&#xA;        ) VALUES (&#xA;            gen_random_uuid(),       &#xA;            p_user_id,             &#xA;            NOW(),                  &#xA;            DATE &#x27;9999-12-31&#x27;,    &#xA;            NOW(),                 &#xA;            p_created_by,         &#xA;            p_organization_id     &#xA;        );&#xA;        &#xA;        RAISE NOTICE &#x27;Organization-user relationship created for user % in organization %&#x27;, p_user_id, p_organization_id;&#xA;    ELSE&#xA;        RAISE NOTICE &#x27;User % already exists in organization %. Skipping insertion.&#x27;, p_user_id, p_organization_id;&#xA;    END IF;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_user_permission</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-87')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-87">
                                            CREATE OR REPLACE PROCEDURE public.insert_user_permission(IN p_user_id uuid, IN p_organization_id uuid, IN p_permission_id uuid, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_id BIGINT;&#xA;BEGIN&#xA;    -- Check if permission already exists&#xA;    IF NOT EXISTS (&#xA;        SELECT 1&#xA;        FROM public.user_permissions&#xA;        WHERE user_id = p_user_id&#xA;          AND organization_id = p_organization_id&#xA;          AND permission_id = p_permission_id&#xA;          AND is_deleted = FALSE&#xA;    ) THEN&#xA;&#xA;        SELECT nextval(&#x27;user_permissions_id_seq1&#x27;) INTO v_id;&#xA;&#xA;        -- Insert with manual ID&#xA;        INSERT INTO public.user_permissions (&#xA;            id,&#xA;            user_id,&#xA;            organization_id,&#xA;            permission_id,&#xA;            created_on_utc,&#xA;            created_by,&#xA;            is_deleted&#xA;        )&#xA;        VALUES (&#xA;            v_id,&#xA;            p_user_id,&#xA;            p_organization_id,&#xA;            p_permission_id,&#xA;            NOW(),&#xA;            p_created_by,&#xA;            FALSE&#xA;        );&#xA;&#xA;        RAISE NOTICE &#x27;Assigned permission % to user % in organization %, ID used: %&#x27;,&#xA;            p_permission_id, p_user_id, p_organization_id, v_id;&#xA;    ELSE&#xA;        RAISE NOTICE &#x27;Permission already exists for user % in organization %&#x27;, p_user_id, p_organization_id;&#xA;    END IF;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_user_permission(IN p_user_id uuid, IN p_organization_id uuid, IN p_permission_id uuid, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_id BIGINT;&#xA;BEGIN&#xA;    -- Check if permission already exists&#xA;    IF NOT EXISTS (&#xA;        SELECT 1&#xA;        FROM public.user_permissions&#xA;        WHERE user_id = p_user_id&#xA;          AND organization_id = p_organization_id&#xA;          AND permission_id = p_permission_id&#xA;          AND is_deleted = FALSE&#xA;    ) THEN&#xA;&#xA;        SELECT nextval(&#x27;user_permissions_id_seq1&#x27;) INTO v_id;&#xA;&#xA;        -- Insert with manual ID&#xA;        INSERT INTO public.user_permissions (&#xA;            id,&#xA;            user_id,&#xA;            organization_id,&#xA;            permission_id,&#xA;            created_on_utc,&#xA;            created_by,&#xA;            is_deleted&#xA;        )&#xA;        VALUES (&#xA;            v_id,&#xA;            p_user_id,&#xA;            p_organization_id,&#xA;            p_permission_id,&#xA;            NOW(),&#xA;            p_created_by,&#xA;            FALSE&#xA;        );&#xA;&#xA;        RAISE NOTICE &#x27;Assigned permission % to user % in organization %, ID used: %&#x27;,&#xA;            p_permission_id, p_user_id, p_organization_id, v_id;&#xA;    ELSE&#xA;        RAISE NOTICE &#x27;Permission already exists for user % in organization %&#x27;, p_user_id, p_organization_id;&#xA;    END IF;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>assign_default_users_to_organization</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-88')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-88">
                                            CREATE OR REPLACE PROCEDURE public.assign_default_users_to_organization(IN p_organization_id uuid, IN p_permission_id uuid, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;  loop_user_id UUID;&#xA;BEGIN&#xA;    -- Insert default users into organization_users (only if they don&#x27;t exist)&#xA;    INSERT INTO public.organization_users (&#xA;        id,&#xA;        user_id,&#xA;        effective_start_date,&#xA;        effective_end_date,&#xA;        created_on_utc,&#xA;        created_by,&#xA;        organization_id&#xA;    )&#xA;    SELECT&#xA;        gen_random_uuid(),&#xA;        d.user_id,&#xA;        NOW(),&#xA;        DATE &#x27;9999-12-31&#x27;,&#xA;        NOW(),&#xA;        p_created_by,&#xA;        p_organization_id&#xA;    FROM&#xA;        public.default_organization_users d&#xA;    WHERE NOT EXISTS (&#xA;        SELECT 1&#xA;        FROM public.organization_users ou&#xA;        WHERE ou.user_id = d.user_id&#xA;          AND ou.organization_id = p_organization_id&#xA;    );&#xA;&#xA;    RAISE NOTICE &#x27;Added % default users to organization %&#x27;,&#xA;        (SELECT COUNT(*) FROM public.default_organization_users), p_organization_id;&#xA;&#xA;    -- Assign permissions for these users by calling insert_user_permission&#xA;    FOR loop_user_id IN (SELECT d.user_id&#xA;        FROM public.default_organization_users d)&#xA;    LOOP&#xA;        CALL public.insert_user_permission(&#xA;            loop_user_id,&#xA;            p_organization_id,&#xA;            p_permission_id,&#xA;            p_created_by&#xA;        );&#xA;    END LOOP;&#xA;    RAISE NOTICE &#x27;Attempted to assign permission % to default users in organization %&#x27;,&#xA;        p_permission_id,&#xA;        p_organization_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.assign_default_users_to_organization(IN p_organization_id uuid, IN p_permission_id uuid, IN p_created_by uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;  loop_user_id UUID;&#xA;BEGIN&#xA;    -- Insert default users into organization_users (only if they don&#x27;t exist)&#xA;    INSERT INTO public.organization_users (&#xA;        id,&#xA;        user_id,&#xA;        effective_start_date,&#xA;        effective_end_date,&#xA;        created_on_utc,&#xA;        created_by,&#xA;        organization_id&#xA;    )&#xA;    SELECT&#xA;        gen_random_uuid(),&#xA;        d.user_id,&#xA;        NOW(),&#xA;        DATE &#x27;9999-12-31&#x27;,&#xA;        NOW(),&#xA;        p_created_by,&#xA;        p_organization_id&#xA;    FROM&#xA;        public.default_organization_users d&#xA;    WHERE NOT EXISTS (&#xA;        SELECT 1&#xA;        FROM public.organization_users ou&#xA;        WHERE ou.user_id = d.user_id&#xA;          AND ou.organization_id = p_organization_id&#xA;    );&#xA;&#xA;    RAISE NOTICE &#x27;Added % default users to organization %&#x27;,&#xA;        (SELECT COUNT(*) FROM public.default_organization_users), p_organization_id;&#xA;&#xA;    -- Assign permissions for these users by calling insert_user_permission&#xA;    FOR loop_user_id IN (SELECT d.user_id&#xA;        FROM public.default_organization_users d)&#xA;    LOOP&#xA;        CALL public.insert_user_permission(&#xA;            loop_user_id,&#xA;            p_organization_id,&#xA;            p_permission_id,&#xA;            p_created_by&#xA;        );&#xA;    END LOOP;&#xA;    RAISE NOTICE &#x27;Attempted to assign permission % to default users in organization %&#x27;,&#xA;        p_permission_id,&#xA;        p_organization_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>hard_delete_org_common</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-89')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-89">
                                            CREATE OR REPLACE PROCEDURE public.hard_delete_org_common(IN p_organization_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_company_id uuid;&#xA;BEGIN&#xA;    -- ========== Delete Common Organization-Level Data ==========&#xA;    DELETE FROM organization_accounts WHERE organization_id = p_organization_id;&#xA;    DELETE FROM email_templates WHERE organization_id = p_organization_id;&#xA;    DELETE FROM user_permissions WHERE organization_id = p_organization_id;&#xA;    DELETE FROM organization_users WHERE organization_id = p_organization_id;&#xA;&#xA;    -- ========== Delete Company-Level Data ==========&#xA;    FOR v_company_id IN&#xA;        SELECT id FROM companies WHERE organization_id = p_organization_id&#xA;    LOOP&#xA;        -- Journal data&#xA;        DELETE FROM journal_voucher_details WHERE journal_header_id IN (&#xA;            SELECT id FROM journal_voucher_headers WHERE company_id = v_company_id&#xA;        );&#xA;        DELETE FROM journal_voucher_headers WHERE company_id = v_company_id;&#xA;        DELETE FROM journal_voucher_header_id WHERE company_id = v_company_id;&#xA;&#xA;        -- General ledgers&#xA;        DELETE FROM general_ledgers WHERE company_id = v_company_id;&#xA;&#xA;        -- Company-specific info&#xA;        DELETE FROM company_bank_accounts WHERE company_id = v_company_id;&#xA;        DELETE FROM company_contacts WHERE company_id = v_company_id;&#xA;        DELETE FROM company_finance_year WHERE company_id = v_company_id;&#xA;        DELETE FROM company_preferences WHERE company_id = v_company_id;&#xA;        DELETE FROM company_upis WHERE company_id = v_company_id;&#xA;        DELETE FROM company_users WHERE company_id = v_company_id;&#xA;&#xA;        -- Linked business entities&#xA;        DELETE FROM customers WHERE company_id = v_company_id;&#xA;        DELETE FROM vendors WHERE company_id = v_company_id;&#xA;        DELETE FROM warehouses WHERE company_id = v_company_id;&#xA;&#xA;        -- Users&#xA;        DELETE FROM users WHERE company_id = v_company_id;&#xA;&#xA;        -- Journal entries by company-linked transactions&#xA;        DELETE FROM journal_entries WHERE transaction_id IN (&#xA;            SELECT id FROM transaction_headers WHERE company_id = v_company_id&#xA;        );&#xA;&#xA;        -- Transaction headers&#xA;        DELETE FROM transaction_headers WHERE company_id = v_company_id;&#xA;    END LOOP;&#xA;&#xA;    -- Chart of accounts and account-linked entries&#xA;    DELETE FROM general_ledgers&#xA;    WHERE credit_account_id IN (&#xA;        SELECT id FROM chart_of_accounts WHERE organization_id = p_organization_id&#xA;    ) OR debit_account_id IN (&#xA;        SELECT id FROM chart_of_accounts WHERE organization_id = p_organization_id&#xA;    );&#xA;&#xA;    DELETE FROM journal_entries&#xA;    WHERE account_id IN (&#xA;        SELECT id FROM chart_of_accounts WHERE organization_id = p_organization_id&#xA;    );&#xA;&#xA;    DELETE FROM chart_of_accounts WHERE organization_id = p_organization_id;&#xA;&#xA;    -- Delete all companies under the organization&#xA;    DELETE FROM companies WHERE organization_id = p_organization_id;&#xA;&#xA;    -- Delete the organization itself&#xA;    DELETE FROM organizations WHERE id = p_organization_id;&#xA;&#xA;    RAISE NOTICE &#x27;Organization with ID % and related data from all common tables has been deleted.&#x27;, p_organization_id;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.hard_delete_org_common(IN p_organization_id uuid)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;DECLARE&#xA;    v_company_id uuid;&#xA;BEGIN&#xA;    -- ========== Delete Common Organization-Level Data ==========&#xA;    DELETE FROM organization_accounts WHERE organization_id = p_organization_id;&#xA;    DELETE FROM email_templates WHERE organization_id = p_organization_id;&#xA;    DELETE FROM user_permissions WHERE organization_id = p_organization_id;&#xA;    DELETE FROM organization_users WHERE organization_id = p_organization_id;&#xA;&#xA;    -- ========== Delete Company-Level Data ==========&#xA;    FOR v_company_id IN&#xA;        SELECT id FROM companies WHERE organization_id = p_organization_id&#xA;    LOOP&#xA;        -- Journal data&#xA;        DELETE FROM journal_voucher_details WHERE journal_header_id IN (&#xA;            SELECT id FROM journal_voucher_headers WHERE company_id = v_company_id&#xA;        );&#xA;        DELETE FROM journal_voucher_headers WHERE company_id = v_company_id;&#xA;        DELETE FROM journal_voucher_header_id WHERE company_id = v_company_id;&#xA;&#xA;        -- General ledgers&#xA;        DELETE FROM general_ledgers WHERE company_id = v_company_id;&#xA;&#xA;        -- Company-specific info&#xA;        DELETE FROM company_bank_accounts WHERE company_id = v_company_id;&#xA;        DELETE FROM company_contacts WHERE company_id = v_company_id;&#xA;        DELETE FROM company_finance_year WHERE company_id = v_company_id;&#xA;        DELETE FROM company_preferences WHERE company_id = v_company_id;&#xA;        DELETE FROM company_upis WHERE company_id = v_company_id;&#xA;        DELETE FROM company_users WHERE company_id = v_company_id;&#xA;&#xA;        -- Linked business entities&#xA;        DELETE FROM customers WHERE company_id = v_company_id;&#xA;        DELETE FROM vendors WHERE company_id = v_company_id;&#xA;        DELETE FROM warehouses WHERE company_id = v_company_id;&#xA;&#xA;        -- Users&#xA;        DELETE FROM users WHERE company_id = v_company_id;&#xA;&#xA;        -- Journal entries by company-linked transactions&#xA;        DELETE FROM journal_entries WHERE transaction_id IN (&#xA;            SELECT id FROM transaction_headers WHERE company_id = v_company_id&#xA;        );&#xA;&#xA;        -- Transaction headers&#xA;        DELETE FROM transaction_headers WHERE company_id = v_company_id;&#xA;    END LOOP;&#xA;&#xA;    -- Chart of accounts and account-linked entries&#xA;    DELETE FROM general_ledgers&#xA;    WHERE credit_account_id IN (&#xA;        SELECT id FROM chart_of_accounts WHERE organization_id = p_organization_id&#xA;    ) OR debit_account_id IN (&#xA;        SELECT id FROM chart_of_accounts WHERE organization_id = p_organization_id&#xA;    );&#xA;&#xA;    DELETE FROM journal_entries&#xA;    WHERE account_id IN (&#xA;        SELECT id FROM chart_of_accounts WHERE organization_id = p_organization_id&#xA;    );&#xA;&#xA;    DELETE FROM chart_of_accounts WHERE organization_id = p_organization_id;&#xA;&#xA;    -- Delete all companies under the organization&#xA;    DELETE FROM companies WHERE organization_id = p_organization_id;&#xA;&#xA;    -- Delete the organization itself&#xA;    DELETE FROM organizations WHERE id = p_organization_id;&#xA;&#xA;    RAISE NOTICE &#x27;Organization with ID % and related data from all common tables has been deleted.&#x27;, p_organization_id;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Procedure</td>
                    <td>insert_multiple_bank_statements_by_excel</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                            <details>
                                <summary>View</summary>
                                <div class="code-block">
                                    <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard('code-block-90')">Copy</button>
                                    <pre><code class="language-sql" id="code-block-90">
                                            CREATE OR REPLACE PROCEDURE public.insert_multiple_bank_statements_by_excel(IN p_statements jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;&#xA;DECLARE&#xA;    stmt RECORD;&#xA;    v_created_by UUID;&#xA;BEGIN&#xA;    -- Use system user or default to a fallback ID if required&#xA;    SELECT id INTO v_created_by&#xA;    FROM users&#xA;    WHERE first_name = &#x27;System&#x27;&#xA;    LIMIT 1;&#xA;&#xA;    -- Loop through each bank statement in the JSONB array&#xA;    FOR stmt IN&#xA;        SELECT * FROM jsonb_to_recordset(p_statements) AS (&#xA;            company_id UUID,&#xA;            txn_date DATE,&#xA;            cheque_number TEXT,&#xA;            description TEXT,&#xA;            value_date DATE,&#xA;            branch_code TEXT,&#xA;            debit_amount NUMERIC,&#xA;            credit_amount NUMERIC,&#xA;            balance NUMERIC,&#xA;            bank_id UUID&#xA;        )&#xA;    LOOP&#xA;        BEGIN&#xA;            -- Check for existing bank statement with same txn_date and description&#xA;            IF NOT EXISTS (&#xA;                SELECT 1&#xA;                FROM public.bank_statements&#xA;                WHERE company_id = stmt.company_id&#xA;                  AND bank_id = stmt.bank_id&#xA;                  AND txn_date = stmt.txn_date&#xA;                  AND description = stmt.description&#xA;                  AND is_deleted = false&#xA;            ) THEN&#xA;                -- Insert new bank statement&#xA;                INSERT INTO public.bank_statements (&#xA;                    company_id,&#xA;                    txn_date,&#xA;                    cheque_number,&#xA;                    description,&#xA;                    value_date,&#xA;                    branch_code,&#xA;                    debit_amount,&#xA;                    credit_amount,&#xA;                    balance,&#xA;                    bank_id,&#xA;                    created_by,&#xA;                    created_on_utc,&#xA;                    is_deleted,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;has_reconciled&#xA;                ) VALUES (&#xA;                    stmt.company_id,&#xA;                    stmt.txn_date,&#xA;                    stmt.cheque_number,&#xA;                    stmt.description,&#xA;                    stmt.value_date,&#xA;                    stmt.branch_code,&#xA;                    stmt.debit_amount,&#xA;                    stmt.credit_amount,&#xA;                    stmt.balance,&#xA;                    stmt.bank_id,&#xA;                    v_created_by,&#xA;                    (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp,&#xA;                    false,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;false&#xA;                );&#xA;&#xA;                RAISE NOTICE &#x27;Inserted bank statement for date: %, company: %&#x27;, stmt.txn_date, stmt.company_id;&#xA;            ELSE&#xA;                -- Update the existing statement&#xA;                UPDATE public.bank_statements&#xA;                SET&#xA;                    cheque_number = stmt.cheque_number,&#xA;                    value_date = stmt.value_date,&#xA;                    branch_code = stmt.branch_code,&#xA;                    debit_amount = stmt.debit_amount,&#xA;                    credit_amount = stmt.credit_amount,&#xA;                    balance = stmt.balance,&#xA;                    modified_by = v_created_by,&#xA;                    modified_on_utc = (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp&#xA;                WHERE company_id = stmt.company_id&#xA;                  AND bank_id = stmt.bank_id&#xA;                  AND txn_date = stmt.txn_date&#xA;                  AND description = stmt.description&#xA;                  AND is_deleted = false;&#xA;&#xA;                RAISE NOTICE &#x27;Updated existing bank statement for date: %, company: %&#x27;, stmt.txn_date, stmt.company_id;&#xA;            END IF;&#xA;&#xA;        EXCEPTION&#xA;            WHEN OTHERS THEN&#xA;                RAISE EXCEPTION &#x27;Error in processing statement for txn_date: %, description: %, Error: %&#x27;, stmt.txn_date, stmt.description, SQLERRM;&#xA;        END;&#xA;    END LOOP;&#xA;&#xA;    RAISE NOTICE &#x27;All bank statements processed successfully&#x27;;&#xA;END;&#xA;$procedure$&#xA;
                                            CREATE OR REPLACE PROCEDURE public.insert_multiple_bank_statements_by_excel(IN p_statements jsonb)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xA;&#xA;DECLARE&#xA;    stmt RECORD;&#xA;    v_created_by UUID;&#xA;BEGIN&#xA;    -- Use system user or default to a fallback ID if required&#xA;    SELECT id INTO v_created_by&#xA;    FROM users&#xA;    WHERE first_name = &#x27;System&#x27;&#xA;    LIMIT 1;&#xA;&#xA;    -- Loop through each bank statement in the JSONB array&#xA;    FOR stmt IN&#xA;        SELECT * FROM jsonb_to_recordset(p_statements) AS (&#xA;            company_id UUID,&#xA;            txn_date DATE,&#xA;            cheque_number TEXT,&#xA;            description TEXT,&#xA;            value_date DATE,&#xA;            branch_code TEXT,&#xA;            debit_amount NUMERIC,&#xA;            credit_amount NUMERIC,&#xA;            balance NUMERIC,&#xA;            bank_id UUID&#xA;        )&#xA;    LOOP&#xA;        BEGIN&#xA;            -- Check for existing bank statement with same txn_date and description&#xA;            IF NOT EXISTS (&#xA;                SELECT 1&#xA;                FROM public.bank_statements&#xA;                WHERE company_id = stmt.company_id&#xA;                  AND bank_id = stmt.bank_id&#xA;                  AND txn_date = stmt.txn_date&#xA;                  AND description = stmt.description&#xA;                  AND is_deleted = false&#xA;            ) THEN&#xA;                -- Insert new bank statement&#xA;                INSERT INTO public.bank_statements (&#xA;                    company_id,&#xA;                    txn_date,&#xA;                    cheque_number,&#xA;                    description,&#xA;                    value_date,&#xA;                    branch_code,&#xA;                    debit_amount,&#xA;                    credit_amount,&#xA;                    balance,&#xA;                    bank_id,&#xA;                    created_by,&#xA;                    created_on_utc,&#xA;                    is_deleted,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;has_reconciled&#xA;                ) VALUES (&#xA;                    stmt.company_id,&#xA;                    stmt.txn_date,&#xA;                    stmt.cheque_number,&#xA;                    stmt.description,&#xA;                    stmt.value_date,&#xA;                    stmt.branch_code,&#xA;                    stmt.debit_amount,&#xA;                    stmt.credit_amount,&#xA;                    stmt.balance,&#xA;                    stmt.bank_id,&#xA;                    v_created_by,&#xA;                    (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp,&#xA;                    false,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;false&#xA;                );&#xA;&#xA;                RAISE NOTICE &#x27;Inserted bank statement for date: %, company: %&#x27;, stmt.txn_date, stmt.company_id;&#xA;            ELSE&#xA;                -- Update the existing statement&#xA;                UPDATE public.bank_statements&#xA;                SET&#xA;                    cheque_number = stmt.cheque_number,&#xA;                    value_date = stmt.value_date,&#xA;                    branch_code = stmt.branch_code,&#xA;                    debit_amount = stmt.debit_amount,&#xA;                    credit_amount = stmt.credit_amount,&#xA;                    balance = stmt.balance,&#xA;                    modified_by = v_created_by,&#xA;                    modified_on_utc = (CURRENT_TIMESTAMP AT TIME ZONE &#x27;Asia/Kolkata&#x27;)::timestamp&#xA;                WHERE company_id = stmt.company_id&#xA;                  AND bank_id = stmt.bank_id&#xA;                  AND txn_date = stmt.txn_date&#xA;                  AND description = stmt.description&#xA;                  AND is_deleted = false;&#xA;&#xA;                RAISE NOTICE &#x27;Updated existing bank statement for date: %, company: %&#x27;, stmt.txn_date, stmt.company_id;&#xA;            END IF;&#xA;&#xA;        EXCEPTION&#xA;            WHEN OTHERS THEN&#xA;                RAISE EXCEPTION &#x27;Error in processing statement for txn_date: %, description: %, Error: %&#x27;, stmt.txn_date, stmt.description, SQLERRM;&#xA;        END;&#xA;    END LOOP;&#xA;&#xA;    RAISE NOTICE &#x27;All bank statements processed successfully&#x27;;&#xA;END;&#xA;$procedure$&#xA;</code></pre>
                                </div>
                            </details>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Procedure</td>
                    <td>hard_delete_organization</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk___ef_migrations_history</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>__EFMigrationsHistory_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_account_groups</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>account_groups_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_addresses</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>addresses_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_account_types</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>account_types_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_bank_accounts</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>bank_accounts_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>banks_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>account_categories_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_cities</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>cities_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_account_opening_balances</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>chart_of_accounts_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_company_upis</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_company_bank_accounts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_company_contacts</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>company_contacts_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_company_finance_year</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_company_preferences</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>company_preferences_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_company_users</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_companies</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>companies_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_contacts</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_customers</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>customers_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>description_templates_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_currencies</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>currencies_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_d_permission_details</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>d_permission_details_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_countries</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>countries_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_departments</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_designations</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>default_organization_users_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_document_meta_datas</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_email_templates</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_images</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_journal_entries</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_general_ledgers</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>general_ledgers_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_finance_year</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>entry_sources_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>entry_sources_source_name_key</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_journal_voucher_details</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>journal_voucher_details_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_journal_voucher_header_id</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_organization_users</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>organization_users_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_messages</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>messages_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>logs_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_notification_types</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>notification_types_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_organizations</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>organizations_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>opening_balances_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>idx_opening_balances_finyear_account</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_organization_types</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_permission_templates</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_journal_voucher_headers</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>journal_voucher_headers_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_permission_groups</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>permission_groups_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>PK_schema_versions_id</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>schema_versions_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_roles</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>roles_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_transaction_source_types</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_upis</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_states</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>states_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_permissions</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>permissions_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_user_deletion_request_statuses</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_user_deletion_requests</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_user_global_permissions</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>ix_user_global_permissions_user_id_permission_id</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_transaction_headers</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>transaction_header_2022_2023_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>transaction_header_2023_2024_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_vendors</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>vendors_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_user_roles</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>user_roles_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_user_permissions</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>uq_user_permissions</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_warehouses</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>warehouses_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_organization_accounts</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>organization_accounts_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>pk_users</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>uq_users_email_phone</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>users_pkey</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>transaction_header_2024_2025_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>transaction_header_2025_2026_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_permission_template_mappings</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>ix_permission_template_mappings_permission_template_id</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>journal_entries_2025_2026_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_budget_lines</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_budget_statuses</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_budgets</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_budget_workflow</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>pk_bank_statements</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Index</td>
                    <td>journal_entries_2022_2023_pkey</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>journal_entries_2023_2024_pkey</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>journal_entries_2023_2024_pkey1</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Target">
                    <td>Index</td>
                    <td>journal_entries_2024_2025_pkey</td>
                    <td>Present</td>
                    <td>Missing</td>
                    <td>Missing in Target</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Index</td>
                    <td>journal_entries_2024_2025_pkey1</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Sequence</td>
                    <td>banks_id_seq</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Sequence</td>
                    <td>default_organization_users_id_seq</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Sequence</td>
                    <td>description_templates_id_seq</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Sequence</td>
                    <td>entry_sources_id_seq</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Sequence</td>
                    <td>journal_entries_id_seq</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Sequence</td>
                    <td>logs_id_seq</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="" data-comparison="Matching">
                    <td>Sequence</td>
                    <td>user_permissions_id_seq</td>
                    <td>Present</td>
                    <td>Present</td>
                    <td>Matching</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Sequence</td>
                    <td>email_templates_id_seq</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Sequence</td>
                    <td>organization_accounts_id_seq</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
                <tr class="missing" data-comparison="Missing in Source">
                    <td>Sequence</td>
                    <td>user_permissions_id_seq1</td>
                    <td>Missing</td>
                    <td>Present</td>
                    <td>Missing in Source</td>
                    <td>
                    </td>
                </tr>
        </tbody>
    </table>

        <div class="modal fade" id="syncScriptModal" tabindex="-1" aria-labelledby="syncScriptModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-xl modal-dialog-scrollable">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="syncScriptModalLabel">All Sync Scripts</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="code-block">
                            <button class="btn btn-sm btn-primary copy-btn" onclick="copyToClipboard('sync-all-script')">Copy All</button>
                            <pre>
                            <code class="language-sql" id="sync-all-script">-- Function: dummy_hello_function&#xA;-- Function missing: &quot;dummy_hello_function&quot;&#xA;CREATE OR REPLACE FUNCTION public.dummy_hello_function(name text)&#xA; RETURNS text&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;BEGIN&#xD;&#xA;    RETURN &#x27;Hello, &#x27; || name || &#x27;!&#x27;;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;;&#xA;&#xA;-- Function: get_ledger_report&#xA;-- Function not matching: &quot;get_ledger_report&quot;&#xA;CREATE OR REPLACE FUNCTION public.get_ledger_report(p_company_id uuid, p_fin_year_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)&#xA; RETURNS TABLE(sl_no integer, ledger text, general_ledger text, opening_balance numeric, total_debit numeric, total_credit numeric, closing_balance numeric, parent_ledger text)&#xA; LANGUAGE plpgsql&#xA;AS $function$&#xD;&#xA;DECLARE&#xD;&#xA;    v_start_date DATE;&#xD;&#xA;    v_end_date DATE;&#xD;&#xA;BEGIN&#xD;&#xA;    -- Get financial year start and end date if not provided&#xD;&#xA;    SELECT fy.start_date, fy.end_date &#xD;&#xA;    INTO v_start_date, v_end_date&#xD;&#xA;    FROM public.finance_year fy&#xD;&#xA;    WHERE fy.id = p_fin_year_id&#xD;&#xA;    LIMIT 1;&#xD;&#xA;&#xD;&#xA;    -- Override with provided values if they are not NULL&#xD;&#xA;    v_start_date := COALESCE(p_start_date, v_start_date);&#xD;&#xA;    v_end_date := COALESCE(p_end_date, v_end_date);&#xD;&#xA;&#xD;&#xA;    RETURN QUERY&#xD;&#xA;    WITH trial_balance AS (&#xD;&#xA;        SELECT &#xD;&#xA;            account_type AS account_category,&#xD;&#xA;            account_number,&#xD;&#xA;            account_name,&#xD;&#xA;            debit,&#xD;&#xA;            credit&#xD;&#xA;        FROM public.get_trial_balance_by_date_range(&#xD;&#xA;            p_company_id, p_fin_year_id, v_start_date, v_end_date&#xD;&#xA;        )&#xD;&#xA;    ),&#xD;&#xA;    opening_balances AS (&#xD;&#xA;        SELECT &#xD;&#xA;            je.account_id::TEXT AS account_id,&#xD;&#xA;            SUM(CASE WHEN je.entry_type = &#x27;D&#x27; THEN je.amount ELSE -je.amount END) AS opening_balance&#xD;&#xA;        FROM public.journal_entries je&#xD;&#xA;        INNER JOIN public.transaction_headers th ON je.transaction_id = th.id&#xD;&#xA;        WHERE th.company_id = p_company_id&#xD;&#xA;          AND th.transaction_date BETWEEN v_start_date AND v_end_date&#xD;&#xA;        GROUP BY je.account_id&#xD;&#xA;    )&#xD;&#xA;    SELECT &#xD;&#xA;        CAST(ROW_NUMBER() OVER() AS INTEGER) AS sl_no, &#xD;&#xA;        tb.account_name AS ledger,&#xD;&#xA;        tb.account_category AS general_ledger,&#xD;&#xA;        COALESCE(ob.opening_balance, 0) AS opening_balance,&#xD;&#xA;        COALESCE(tb.debit, 0) AS total_debit,&#xD;&#xA;        COALESCE(tb.credit, 0) AS total_credit,&#xD;&#xA;        COALESCE(ob.opening_balance, 0) &#x2B; COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0) AS closing_balance,&#xD;&#xA;        CASE &#xD;&#xA;            WHEN tb.account_category IN (&#x27;Assets&#x27;, &#x27;Current Assets&#x27;, &#x27;Non-Current Assets&#x27;, &#x27;Cash&#x27;, &#x27;Bank&#x27;) THEN &#x27;Asset&#x27;&#xD;&#xA;            WHEN tb.account_category IN (&#x27;Liabilities&#x27;, &#x27;Current Liabilities&#x27;, &#x27;Non-Current Liabilities&#x27;) THEN &#x27;Liability&#x27;&#xD;&#xA;            WHEN tb.account_category IN (&#x27;Revenue&#x27;, &#x27;Sales Revenue&#x27;, &#x27;Service Revenue&#x27;, &#x27;Non Member Income&#x27;, &#x27;Member Income&#x27;) THEN &#x27;Income&#x27;&#xD;&#xA;            WHEN tb.account_category IN (&#x27;Expenses&#x27;, &#x27;Direct Expenses&#x27;, &#x27;Indirect Expenses&#x27;, &#x27;Operating Expenses&#x27;, &#x27;Cost of Goods Sold&#x27;, &#x27;Non-Operating Expense&#x27;) THEN &#x27;Expense&#x27;&#xD;&#xA;            ELSE NULL&#xD;&#xA;        END AS parent_ledger&#xD;&#xA;    FROM trial_balance tb&#xD;&#xA;    LEFT JOIN opening_balances ob ON tb.account_number::TEXT = ob.account_id&#xD;&#xA;&#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Debtors Parent Row&#xD;&#xA;    SELECT 9999, &#x27;Sundry Debtors&#x27;, &#x27;Assets&#x27;, 0, 0, 0, 0, &#x27;Asset&#x27;&#xD;&#xA;    &#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Debtors Children&#xD;&#xA;    SELECT &#xD;&#xA;        sd.sl_no &#x2B; 10000,&#xD;&#xA;        sd.ledger, &#xD;&#xA;        sd.general_ledger, &#xD;&#xA;        sd.opening_balance, &#xD;&#xA;        sd.debit AS total_debit, &#xD;&#xA;        sd.credit AS total_credit, &#xD;&#xA;        sd.closing_balance, &#xD;&#xA;        &#x27;Asset&#x27;&#xD;&#xA;    FROM public.get_sundry_debtors_ledger(p_company_id, p_fin_year_id, v_start_date, v_end_date) sd&#xD;&#xA;&#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Creditors Parent Row&#xD;&#xA;    SELECT 9998, &#x27;Sundry Creditors&#x27;, &#x27;Liabilities&#x27;, 0, 0, 0, 0, &#x27;Liability&#x27;&#xD;&#xA;&#xD;&#xA;    UNION ALL&#xD;&#xA;&#xD;&#xA;    -- Sundry Creditors Children&#xD;&#xA;    SELECT &#xD;&#xA;        sc.sl_no &#x2B; 20000,&#xD;&#xA;        sc.ledger, &#xD;&#xA;        sc.general_ledger, &#xD;&#xA;        sc.opening_balance, &#xD;&#xA;        sc.debit AS total_debit, &#xD;&#xA;        sc.credit AS total_credit, &#xD;&#xA;        sc.closing_balance, &#xD;&#xA;        &#x27;Liability&#x27;&#xD;&#xA;    FROM public.get_sundry_creditors_ledger(p_company_id, p_fin_year_id, v_start_date, v_end_date) sc&#xD;&#xA;&#xD;&#xA;    ORDER BY parent_ledger NULLS FIRST, ledger;&#xD;&#xA;END;&#xD;&#xA;$function$&#xA;;&#xA;&#xA;-- Procedure: dummy_log_procedure&#xA;-- Procedure missing: &quot;dummy_log_procedure&quot;&#xA;CREATE OR REPLACE PROCEDURE public.dummy_log_procedure(IN msg text)&#xA; LANGUAGE plpgsql&#xA;AS $procedure$&#xD;&#xA;BEGIN&#xD;&#xA;    INSERT INTO public.dummy_log_table(message) VALUES (msg);&#xD;&#xA;END;&#xD;&#xA;$procedure$&#xA;;&#xA;&#xA;</code>

                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            hljs.highlightAll();
        });

        function applyFilters() {
            const mismatch = document.getElementById('mismatchOnly').checked;
            const missingSource = document.getElementById('missingSourceOnly').checked;
            const missingTarget = document.getElementById('missingTargetOnly').checked;
            document.querySelectorAll('table tbody tr[data-comparison]').forEach(row => {
                const comparison = row.dataset.comparison;
                let show = true;
                if (mismatch && comparison === 'Matching') show = false;
                if (missingSource && comparison !== 'Missing in Source') show = false;
                if (missingTarget && comparison !== 'Missing in Target') show = false;
                row.style.display = show ? '' : 'none';
            });
        }

        function copyToClipboard(id) {
            const el = document.getElementById(id);
            navigator.clipboard.writeText(el.innerText).then(() => alert('Copied to clipboard'));
        }
    </script>
</body>
</html>
